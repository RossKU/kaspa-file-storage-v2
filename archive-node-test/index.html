<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Kaspa Node Connection Test - Minimal</title>
    <style>
        body {
            font-family: monospace;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background: #1a1a1a;
            color: #e0e0e0;
        }
        .container {
            background: #2a2a2a;
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 20px;
        }
        button {
            background: #4CAF50;
            color: white;
            border: none;
            padding: 10px 20px;
            margin: 5px;
            border-radius: 4px;
            cursor: pointer;
        }
        button:hover {
            background: #45a049;
        }
        button:disabled {
            background: #666;
            cursor: not-allowed;
        }
        .log {
            background: #000;
            padding: 10px;
            border-radius: 4px;
            max-height: 400px;
            overflow-y: auto;
            font-size: 12px;
            white-space: pre-wrap;
        }
        .success { color: #4CAF50; }
        .error { color: #f44336; }
        .warning { color: #ff9800; }
        .info { color: #2196F3; }
        input {
            width: 100%;
            padding: 8px;
            margin: 5px 0;
            background: #333;
            color: #e0e0e0;
            border: 1px solid #555;
            border-radius: 4px;
        }
        .test-result {
            margin: 10px 0;
            padding: 10px;
            background: #333;
            border-radius: 4px;
            border-left: 4px solid #666;
        }
        .test-result.success {
            border-left-color: #4CAF50;
        }
        .test-result.error {
            border-left-color: #f44336;
        }
    </style>
</head>
<body>
    <h1>ðŸ”Œ Kaspa Node Connection Test - Minimal Version</h1>
    
    <div class="container">
        <h2>Step 1: Initialize Kaspa Module</h2>
        <button onclick="initializeKaspa()" id="initBtn">Initialize Kaspa</button>
        <div id="initStatus"></div>
    </div>

    <div class="container">
        <h2>Step 2: Test Single Node Connection</h2>
        <input type="text" id="nodeUrl" placeholder="wss://fermion-10.kaspa.green/kaspa/testnet-10/wrpc/borsh" 
               value="wss://fermion-10.kaspa.green/kaspa/testnet-10/wrpc/borsh">
        <button onclick="testSingleNode()" id="testBtn" disabled>Test Connection</button>
        <div id="testResult"></div>
    </div>

    <div class="container">
        <h2>Step 3: Test Multiple Nodes</h2>
        <button onclick="testAllNodes()" id="testAllBtn" disabled>Test All Known Nodes</button>
        <div id="allTestResults"></div>
    </div>

    <div class="container">
        <h2>Step 4: Block Retrieval Test</h2>
        <input type="text" id="blockHash" placeholder="Enter block hash (64 characters)" 
               style="margin-bottom: 10px;">
        <input type="text" id="searchPattern" placeholder="Search pattern in payloads (optional)" 
               style="margin-bottom: 10px;">
        <button onclick="testBlockRetrieval()" id="blockTestBtn" disabled>Test Block Retrieval</button>
        <div id="blockTestResult"></div>
    </div>

    <div class="container">
        <h2>Debug Log</h2>
        <div class="log" id="debugLog"></div>
    </div>

    <script>
        // Global variables
        let kaspa = null;
        let isInitialized = false;
        let currentClient = null;

        // Logging function
        function log(message, type = 'info') {
            const timestamp = new Date().toLocaleTimeString();
            const logDiv = document.getElementById('debugLog');
            const logEntry = document.createElement('div');
            logEntry.className = type;
            logEntry.textContent = `[${timestamp}] ${message}`;
            logDiv.appendChild(logEntry);
            logDiv.scrollTop = logDiv.scrollHeight;
            console.log(`[${type.toUpperCase()}] ${message}`);
        }

        // Initialize Kaspa module
        async function initializeKaspa() {
            const btn = document.getElementById('initBtn');
            const status = document.getElementById('initStatus');
            btn.disabled = true;
            
            try {
                log('Starting Kaspa module initialization...');
                
                // Import kaspa-core module
                log('Importing kaspa-core.js...');
                kaspa = await import('./kaspa-core.js');
                log('kaspa-core.js imported successfully', 'success');
                
                // Initialize WASM
                log('Initializing WASM module...');
                await kaspa.default('./kaspa-core_bg.wasm');
                log('WASM initialized successfully', 'success');
                
                // Check available functions
                log('Checking available functions...');
                const functions = ['RpcClient', 'PrivateKey', 'Address', 'createTransactions'];
                for (const func of functions) {
                    if (kaspa[func]) {
                        log(`âœ“ ${func} is available`, 'success');
                    } else {
                        log(`âœ— ${func} is NOT available`, 'error');
                    }
                }
                
                // Test creating a dummy address
                log('Testing address creation...');
                // Use test private key (same as main app)
                const testPrivateKey = 'b7e151628aed2a6abf7158809cf4f3c762e7160f38b4da56a784d9045190cfef';
                const privateKey = new kaspa.PrivateKey(testPrivateKey);
                const publicKey = privateKey.toPublicKey();
                const address = publicKey.toAddress('testnet-10');
                log(`Test address created: ${address}`, 'success');
                
                isInitialized = true;
                status.innerHTML = '<div class="success">âœ“ Kaspa module initialized successfully</div>';
                document.getElementById('testBtn').disabled = false;
                document.getElementById('testAllBtn').disabled = false;
                document.getElementById('blockTestBtn').disabled = false;
                
            } catch (error) {
                log(`Initialization error: ${error.message}`, 'error');
                log(`Error stack: ${error.stack}`, 'error');
                status.innerHTML = `<div class="error">âœ— Initialization failed: ${error.message}</div>`;
                btn.disabled = false;
            }
        }

        // Test single node connection
        async function testSingleNode() {
            if (!isInitialized) {
                log('Kaspa module not initialized', 'error');
                return;
            }
            
            const url = document.getElementById('nodeUrl').value.trim();
            const resultDiv = document.getElementById('testResult');
            
            if (!url) {
                log('Please enter a node URL', 'warning');
                return;
            }
            
            log(`Testing connection to: ${url}`);
            resultDiv.innerHTML = '<div class="info">Testing...</div>';
            
            const startTime = Date.now();
            
            try {
                // Create RPC client
                log('Creating RPC client...');
                log(`RpcClient constructor: ${typeof kaspa.RpcClient}`);
                log(`URL: ${url}`);
                log(`Network ID: testnet-10`);
                
                let client;
                try {
                    // Test 1: Try with only resolver (like main app)
                    log('Test 1: Creating RPC client with resolver only...');
                    try {
                        const resolver = new kaspa.Resolver();
                        client = new kaspa.RpcClient({
                            resolver: resolver,
                            networkId: 'testnet-10'
                        });
                        log('RPC client created with resolver only');
                    } catch (e1) {
                        log(`Test 1 failed: ${e1?.message || e1}`, 'warning');
                        
                        // Test 2: Try with direct URL
                        log('Test 2: Creating RPC client with direct URL...');
                        client = new kaspa.RpcClient({
                            url: url,
                            networkId: 'testnet-10'
                        });
                        log('RPC client created with direct URL');
                    }
                } catch (e) {
                    throw new Error(`Failed to create RPC client: ${e?.message || e}`);
                }
                
                // Set connection timeout
                const timeoutPromise = new Promise((_, reject) => {
                    setTimeout(() => reject(new Error('Connection timeout (10s)')), 10000);
                });
                
                // Connect
                log('Attempting to connect...');
                try {
                    // Try connect with URL parameter
                    log(`Connecting to: ${url}`);
                    await Promise.race([client.connect(url), timeoutPromise]);
                } catch (e) {
                    // If that fails, try without URL
                    log(`Connect with URL failed: ${e?.message || e}`, 'warning');
                    log('Trying connect without URL parameter...');
                    try {
                        await Promise.race([client.connect(), timeoutPromise]);
                    } catch (e2) {
                        throw new Error(`Connection failed: ${e2?.message || e2}`);
                    }
                }
                log('Connected successfully!', 'success');
                
                // Store client for block test
                currentClient = client;
                
                // Get server info
                log('Getting server info...');
                const info = await client.getServerInfo();
                const responseTime = Date.now() - startTime;
                
                log(`Server info received in ${responseTime}ms`, 'success');
                log(`Server version: ${info.serverVersion || 'Unknown'}`);
                log(`Network ID: ${info.networkId || 'Unknown'}`);
                log(`Is synced: ${info.isSynced}`);
                
                // Try to get block count and check if archive node
                try {
                    log('Getting block count...');
                    const blockCount = await client.getBlockCount();
                    const count = blockCount.blockCount || blockCount;
                    log(`Block count: ${count}`, 'success');
                    
                    // Convert BigInt to number for calculations
                    const countNum = typeof count === 'bigint' ? Number(count) : count;
                    
                    // Calculate detailed block statistics
                    const blocksPerSecond = 10;
                    const blocksPerMinute = blocksPerSecond * 60; // 600
                    const blocksPerHour = blocksPerMinute * 60; // 36,000
                    const blocksPerDay = blocksPerHour * 24; // 864,000
                    
                    const daysOfData = countNum / blocksPerDay;
                    const hoursOfData = countNum / blocksPerHour;
                    
                    log(`â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”`, 'info');
                    log(`Block Statistics:`, 'info');
                    log(`â€¢ Total blocks: ${countNum.toLocaleString()}`, 'info');
                    log(`â€¢ Data coverage: ${daysOfData.toFixed(2)} days (${hoursOfData.toFixed(1)} hours)`, 'info');
                    log(`â€¢ Block generation rate: ${blocksPerSecond} blocks/second`, 'info');
                    
                    // Check if this might be an archive node
                    const archiveThreshold = 15000000; // 15 million blocks
                    const pruneThreshold = 30; // 30 hours
                    const hoursThreshold = pruneThreshold * blocksPerHour; // 1,080,000 blocks
                    
                    if (countNum > archiveThreshold) {
                        log(`âš¡ ARCHIVE NODE DETECTED! (>${(archiveThreshold/1000000).toFixed(0)}M blocks)`, 'success');
                        log(`â€¢ Full blockchain history available`, 'success');
                        log(`â€¢ No pruning - all historical data preserved`, 'success');
                    } else if (hoursOfData > pruneThreshold) {
                        log(`ðŸ“¦ Extended node (>${pruneThreshold} hours of data)`, 'warning');
                        log(`â€¢ More data than typical pruned nodes`, 'warning');
                        log(`â€¢ May have custom pruning settings`, 'warning');
                    } else {
                        log(`ðŸ“¦ Regular pruned node`, 'info');
                        log(`â€¢ Limited to recent blocks (typically ${pruneThreshold} hours)`, 'info');
                        log(`â€¢ Oldest accessible block: ~${(countNum - hoursThreshold).toLocaleString()}`, 'info');
                    }
                    log(`â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”`, 'info');
                } catch (e) {
                    log(`Block count not available: ${e.message}`, 'warning');
                }
                
                // Keep connection alive for block test
                log('Connection kept alive for block testing', 'info');
                
                // Update result display with archive node info
                const blockCount = await client.getBlockCount().catch(() => null);
                const count = blockCount ? (blockCount.blockCount || blockCount) : 0;
                const countNum = typeof count === 'bigint' ? Number(count) : count;
                const isArchive = countNum > 15000000;
                const blocksPerDay = 864000;
                const daysOfData = countNum / blocksPerDay;
                
                resultDiv.innerHTML = `
                    <div class="test-result success">
                        <strong>âœ“ Connection successful!</strong><br>
                        Response time: ${responseTime}ms<br>
                        Server: ${info.serverVersion || 'Unknown'}<br>
                        Network: ${info.networkId || 'Unknown'}<br>
                        Synced: ${info.isSynced}<br>
                        Block Count: ${countNum.toLocaleString()}<br>
                        <strong>${isArchive ? 'âš¡ ARCHIVE NODE' : 'ðŸ“¦ Regular Node'}</strong> (${daysOfData.toFixed(2)} days of data)<br>
                        ${isArchive ? 'Full blockchain history available!' : 'Limited to recent blocks (pruning enabled)'}
                    </div>
                `;
                
            } catch (error) {
                const responseTime = Date.now() - startTime;
                log(`Connection failed: ${error?.message || error || 'Unknown error'}`, 'error');
                log(`Error type: ${error?.constructor?.name || typeof error}`, 'error');
                log(`Error details: ${error?.stack || JSON.stringify(error)}`, 'error');
                
                resultDiv.innerHTML = `
                    <div class="test-result error">
                        <strong>âœ— Connection failed</strong><br>
                        Time: ${responseTime}ms<br>
                        Error: ${error?.message || error || 'Unknown error'}<br>
                        Type: ${error?.constructor?.name || typeof error}
                    </div>
                `;
            }
        }

        // Test all known nodes
        async function testAllNodes() {
            if (!isInitialized) {
                log('Kaspa module not initialized', 'error');
                return;
            }
            
            const resultsDiv = document.getElementById('allTestResults');
            resultsDiv.innerHTML = '<div class="info">Testing all nodes...</div>';
            
            const nodes = [
                // Known working endpoints
                { name: 'fermion-10 (Borsh path)', url: 'wss://fermion-10.kaspa.green/kaspa/testnet-10/wrpc/borsh' },
                { name: 'testnet10.kaspa.app', url: 'https://testnet10.kaspa.app:443' },
                
                // Archive node
                { name: 'Archive Node (tn10)', url: 'wss://archive-tn10.kaspa.org:17210' },
                
                // kaspa.stream group (testnet-10 with Borsh path)
                { name: 'eric-10 (stream)', url: 'wss://eric-10.kaspa.stream/kaspa/testnet-10/wrpc/borsh' },
                { name: 'maxim-10 (stream)', url: 'wss://maxim-10.kaspa.stream/kaspa/testnet-10/wrpc/borsh' },
                { name: 'sean-10 (stream)', url: 'wss://sean-10.kaspa.stream/kaspa/testnet-10/wrpc/borsh' },
                { name: 'troy-10 (stream)', url: 'wss://troy-10.kaspa.stream/kaspa/testnet-10/wrpc/borsh' },
                
                // kaspa.red group (testnet-10 with Borsh path)
                { name: 'john-10 (red)', url: 'wss://john-10.kaspa.red/kaspa/testnet-10/wrpc/borsh' },
                { name: 'mike-10 (red)', url: 'wss://mike-10.kaspa.red/kaspa/testnet-10/wrpc/borsh' },
                { name: 'paul-10 (red)', url: 'wss://paul-10.kaspa.red/kaspa/testnet-10/wrpc/borsh' },
                { name: 'alex-10 (red)', url: 'wss://alex-10.kaspa.red/kaspa/testnet-10/wrpc/borsh' },
                
                // kaspa.green group (testnet-10 with Borsh path)
                { name: 'jake-10 (green)', url: 'wss://jake-10.kaspa.green/kaspa/testnet-10/wrpc/borsh' },
                { name: 'mark-10 (green)', url: 'wss://mark-10.kaspa.green/kaspa/testnet-10/wrpc/borsh' },
                { name: 'adam-10 (green)', url: 'wss://adam-10.kaspa.green/kaspa/testnet-10/wrpc/borsh' },
                { name: 'liam-10 (green)', url: 'wss://liam-10.kaspa.green/kaspa/testnet-10/wrpc/borsh' },
                
                // kaspa.blue group (testnet-10 with Borsh path)
                { name: 'noah-10 (blue)', url: 'wss://noah-10.kaspa.blue/kaspa/testnet-10/wrpc/borsh' },
                { name: 'ryan-10 (blue)', url: 'wss://ryan-10.kaspa.blue/kaspa/testnet-10/wrpc/borsh' },
                { name: 'jack-10 (blue)', url: 'wss://jack-10.kaspa.blue/kaspa/testnet-10/wrpc/borsh' },
                { name: 'luke-10 (blue)', url: 'wss://luke-10.kaspa.blue/kaspa/testnet-10/wrpc/borsh' },
                
                // tau-10 (confirmed working)
                { name: 'tau-10 (Borsh path)', url: 'wss://tau-10.kaspa.blue/kaspa/testnet-10/wrpc/borsh' },
                
                // Port-based endpoints
                { name: 'fermion (17210)', url: 'wss://fermion.kaspa.green:17210' },
                { name: 'fermion (18210)', url: 'wss://fermion.kaspa.green:18210' },
                { name: 'tau (17210)', url: 'wss://tau.kaspa.blue:17210' },
                
                // Test localhost
                { name: 'localhost', url: 'ws://127.0.0.1:17210' }
            ];
            
            const results = [];
            
            for (const node of nodes) {
                log(`\nâ”â”â” Testing ${node.name} â”â”â”`);
                const result = await testNode(node.url, node.name);
                results.push(result);
                
                // Log block count for successful connections
                if (result.status === 'success' && result.blockCount) {
                    const daysOfData = result.blockCount / 864000;
                    log(`â†’ Blocks: ${result.blockCount.toLocaleString()} (${daysOfData.toFixed(2)} days)`, 
                        result.isArchive ? 'success' : 'info');
                }
                
                updateResults(resultsDiv, results);
            }
            
            // Summary
            const successful = results.filter(r => r.status === 'success').length;
            const failed = results.filter(r => r.status === 'failed').length;
            const archiveCount = results.filter(r => r.status === 'success' && r.isArchive).length;
            
            log(`\nâ”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”`, 'info');
            log(`Test Summary:`, 'info');
            log(`â€¢ Total nodes tested: ${results.length}`);
            log(`â€¢ Successful connections: ${successful}`, successful > 0 ? 'success' : 'error');
            log(`â€¢ Failed connections: ${failed}`, failed > 0 ? 'error' : 'success');
            log(`â€¢ Archive nodes found: ${archiveCount}`, archiveCount > 0 ? 'success' : 'warning');
            
            if (archiveCount > 0) {
                log(`\nArchive nodes:`, 'success');
                results.filter(r => r.isArchive).forEach(r => {
                    log(`â€¢ ${r.name}: ${r.blockCount.toLocaleString()} blocks`, 'success');
                });
            }
            log(`â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”`, 'info');
        }

        // Test individual node
        async function testNode(url, name) {
            const startTime = Date.now();
            
            try {
                let client;
                try {
                    // Try creating client with resolver first
                    try {
                        const resolver = new kaspa.Resolver();
                        client = new kaspa.RpcClient({
                            resolver: resolver,
                            networkId: 'testnet-10'
                        });
                    } catch (e1) {
                        // Fallback to direct URL
                        client = new kaspa.RpcClient({
                            url: url,
                            networkId: 'testnet-10'
                        });
                    }
                } catch (e) {
                    throw new Error(`RPC client creation failed: ${e?.message || e}`);
                }
                
                const timeoutPromise = new Promise((_, reject) => {
                    setTimeout(() => reject(new Error('Timeout')), 5000);
                });
                
                try {
                    // Try connect with URL first
                    await Promise.race([client.connect(url), timeoutPromise]);
                } catch (e) {
                    // Try without URL
                    try {
                        await Promise.race([client.connect(), timeoutPromise]);
                    } catch (e2) {
                        throw new Error(`Connection error: ${e2?.message || e2}`);
                    }
                }
                const info = await client.getServerInfo();
                
                // Get block count to check if archive (before disconnecting)
                let blockCount = 0;
                try {
                    const bc = await client.getBlockCount();
                    const count = bc.blockCount || bc || 0;
                    blockCount = typeof count === 'bigint' ? Number(count) : count;
                } catch (e) {
                    // Ignore
                }
                
                await client.disconnect();
                
                const responseTime = Date.now() - startTime;
                log(`${name}: SUCCESS (${responseTime}ms)`, 'success');
                
                return {
                    name,
                    url,
                    status: 'success',
                    responseTime,
                    info,
                    blockCount,
                    isArchive: blockCount > 15000000
                };
                
            } catch (error) {
                const responseTime = Date.now() - startTime;
                log(`${name}: FAILED - ${error?.message || error || 'Unknown error'}`, 'error');
                
                return {
                    name,
                    url,
                    status: 'failed',
                    responseTime,
                    error: error?.message || error || 'Unknown error'
                };
            }
        }

        // Update results display
        function updateResults(container, results) {
            let html = '<h3>Results:</h3>';
            
            results.forEach(result => {
                const statusClass = result.status === 'success' ? 'success' : 'error';
                html += `
                    <div class="test-result ${statusClass}">
                        <strong>${result.name}</strong>${result.isArchive ? ' <span style="color: #4CAF50">âš¡ ARCHIVE</span>' : ''}<br>
                        URL: ${result.url}<br>
                        Status: ${result.status}<br>
                        Time: ${result.responseTime}ms<br>
                        ${result.blockCount ? `Blocks: ${result.blockCount.toLocaleString()}` : ''}<br>
                        ${result.error ? `Error: ${result.error}` : ''}
                    </div>
                `;
            });
            
            container.innerHTML = html;
        }

        // Block retrieval test function
        async function testBlockRetrieval() {
            if (!isInitialized) {
                log('Kaspa module not initialized', 'error');
                return;
            }
            
            if (!currentClient) {
                log('No active connection. Please test a node connection first.', 'error');
                return;
            }
            
            const blockHash = document.getElementById('blockHash').value.trim();
            const searchPattern = document.getElementById('searchPattern').value.trim();
            const resultDiv = document.getElementById('blockTestResult');
            
            if (!blockHash || blockHash.length !== 64) {
                log('Please enter a valid 64-character block hash', 'warning');
                return;
            }
            
            log(`Testing block retrieval for: ${blockHash}`);
            resultDiv.innerHTML = '<div class="info">Retrieving block...</div>';
            
            try {
                // Get block with transactions
                log('Calling getBlock with includeTransactions: true');
                const response = await currentClient.getBlock({
                    hash: blockHash,
                    includeTransactions: true
                });
                
                const block = response?.block?.block || response?.block || response;
                
                if (!block) {
                    throw new Error('No block data received');
                }
                
                log(`Block retrieved successfully`, 'success');
                log(`Block timestamp: ${new Date(Number(block.header?.timestamp || 0)).toLocaleString()}`);
                log(`DAA Score: ${block.header?.daaScore || 'Unknown'}`);
                log(`Blue Score: ${block.header?.blueScore || 'Unknown'}`);
                log(`Transaction count: ${block.transactions?.length || 0}`);
                
                let html = '<div class="test-result success">';
                html += `<strong>âœ“ Block retrieved successfully</strong><br>`;
                html += `Hash: ${blockHash}<br>`;
                html += `Timestamp: ${new Date(Number(block.header?.timestamp || 0)).toLocaleString()}<br>`;
                html += `Transactions: ${block.transactions?.length || 0}<br><br>`;
                
                // Analyze transactions
                let foundPayloads = 0;
                let matchingPayloads = 0;
                
                if (block.transactions && block.transactions.length > 0) {
                    html += '<strong>Transactions with payloads:</strong><br>';
                    
                    for (const tx of block.transactions) {
                        const txId = tx.verboseData?.transactionId || tx.id || tx.transactionId || 'Unknown';
                        const payload = tx.payload;
                        
                        if (payload && payload !== '00' && payload.length > 2) {
                            foundPayloads++;
                            
                            let matches = !searchPattern;
                            if (searchPattern) {
                                matches = payload.toLowerCase().includes(searchPattern.toLowerCase());
                                if (matches) matchingPayloads++;
                            }
                            
                            if (matches) {
                                html += `<div style="margin: 10px 0; padding: 10px; background: #444; border-radius: 4px;">`;
                                html += `<strong>TxID:</strong> ${txId}<br>`;
                                html += `<strong>Payload size:</strong> ${payload.length / 2} bytes<br>`;
                                html += `<div style="background: #333; padding: 5px; margin-top: 5px; border-radius: 4px; word-break: break-all; font-family: monospace; font-size: 11px;">`;
                                html += payload.substring(0, 200);
                                if (payload.length > 200) html += '...';
                                html += '</div>';
                                
                                // Try to decode as text
                                try {
                                    let decoded = '';
                                    for (let i = 0; i < Math.min(payload.length, 100); i += 2) {
                                        const code = parseInt(payload.substr(i, 2), 16);
                                        if (code >= 32 && code <= 126) {
                                            decoded += String.fromCharCode(code);
                                        } else {
                                            decoded += '.';
                                        }
                                    }
                                    if (decoded.length > 0) {
                                        html += `<div style="margin-top: 5px;"><strong>Decoded preview:</strong> ${decoded}</div>`;
                                    }
                                } catch (e) {
                                    // Ignore decode errors
                                }
                                
                                html += '</div>';
                            }
                        }
                    }
                    
                    html += `<br><strong>Summary:</strong> Found ${foundPayloads} transactions with payloads`;
                    if (searchPattern) {
                        html += `, ${matchingPayloads} matching search pattern`;
                    }
                } else {
                    html += 'No transactions found in this block';
                }
                
                html += '</div>';
                resultDiv.innerHTML = html;
                
            } catch (error) {
                log(`Block retrieval failed: ${error?.message || error}`, 'error');
                resultDiv.innerHTML = `
                    <div class="test-result error">
                        <strong>âœ— Block retrieval failed</strong><br>
                        Error: ${error?.message || error}<br>
                        <br>
                        Note: Make sure you're connected to an archive node for historical blocks,<br>
                        or that the block exists and is within the pruning window.
                    </div>
                `;
            }
        }

        // Helper function to convert hex to text
        function hexToText(hex) {
            let text = '';
            for (let i = 0; i < hex.length; i += 2) {
                text += String.fromCharCode(parseInt(hex.substr(i, 2), 16));
            }
            return text;
        }

        // Auto-initialize on load
        window.addEventListener('DOMContentLoaded', () => {
            log('Page loaded. Click "Initialize Kaspa" to begin.', 'info');
        });
    </script>
</body>
</html>
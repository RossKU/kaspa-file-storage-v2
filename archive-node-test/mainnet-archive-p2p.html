<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Kaspa Mainnet Archive Node P2P Discovery</title>
    <!-- Kaspa WASM will be loaded dynamically -->
    <style>
        body {
            font-family: monospace;
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
            background: #1a1a1a;
            color: #e0e0e0;
        }
        .container {
            background: #2a2a2a;
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 20px;
        }
        h1, h2 {
            color: #4CAF50;
        }
        button {
            background: #4CAF50;
            color: white;
            border: none;
            padding: 10px 20px;
            margin: 5px;
            border-radius: 4px;
            cursor: pointer;
        }
        button:hover {
            background: #45a049;
        }
        button:disabled {
            background: #666;
            cursor: not-allowed;
        }
        .log {
            background: #000;
            padding: 10px;
            border-radius: 4px;
            max-height: 400px;
            overflow-y: auto;
            font-size: 12px;
            white-space: pre-wrap;
            margin-top: 10px;
        }
        .success { color: #4CAF50; }
        .error { color: #f44336; }
        .warning { color: #ff9800; }
        .info { color: #2196F3; }
        .archive { color: #9C27B0; font-weight: bold; }
        input {
            width: 100%;
            padding: 8px;
            margin: 5px 0;
            background: #333;
            color: #e0e0e0;
            border: 1px solid #555;
            border-radius: 4px;
            box-sizing: border-box;
        }
        .node-card {
            background: #333;
            padding: 15px;
            margin: 10px 0;
            border-radius: 8px;
            border-left: 4px solid #666;
        }
        .node-card.archive {
            border-left-color: #9C27B0;
            background: #3a2a4a;
        }
        .node-card.connected {
            border-left-color: #4CAF50;
        }
        .stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-top: 20px;
        }
        .stat-box {
            background: #333;
            padding: 15px;
            border-radius: 8px;
            text-align: center;
        }
        .stat-value {
            font-size: 24px;
            font-weight: bold;
            color: #4CAF50;
        }
        .stat-label {
            font-size: 12px;
            color: #888;
            margin-top: 5px;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 10px;
        }
        th, td {
            padding: 8px;
            text-align: left;
            border-bottom: 1px solid #555;
        }
        th {
            background: #333;
            font-weight: bold;
        }
        .clickable {
            color: #4CAF50;
            cursor: pointer;
            text-decoration: underline;
        }
        .clickable:hover {
            color: #45a049;
        }
    </style>
</head>
<body>
    <h1>üîç Kaspa Mainnet Archive Node P2P Discovery</h1>
    
    <div class="container">
        <h2>Step 1: Initialize Kaspa Module</h2>
        <button onclick="initializeKaspa()" id="initBtn">Initialize Kaspa P2P</button>
        <div id="initStatus"></div>
    </div>

    <div class="container">
        <h2>Step 2: Configure Archive Node Discovery</h2>
        <div style="margin-bottom: 15px;">
            <label>Mainnet Node Providers (one per line):</label>
            <textarea id="dnsSeeds" rows="8" style="width: 100%; background: #333; color: #e0e0e0; border: 1px solid #555; border-radius: 4px; padding: 8px;">
kaspa.stream
kaspa.red
kaspa.green
kaspa.blue
n.seeder2.kaspad.net
acc-pool.pw
kaspa.herominers.com</textarea>
        </div>
        <div style="margin-bottom: 15px;">
            <label>Known Archive Nodes (optional, one per line):</label>
            <textarea id="knownArchives" rows="3" style="width: 100%; background: #333; color: #e0e0e0; border: 1px solid #555; border-radius: 4px; padding: 8px;" placeholder="e.g., wss://archive.kaspa.org:16110"></textarea>
        </div>
        <div>
            <label>Old Block Test Height (for archive detection):</label>
            <input type="number" id="testHeight" value="200000" placeholder="Blocks back from current height (30hr = 108000 blocks)">
            <small style="color: #888; display: block; margin-top: 5px;">Mainnet: 1 block/sec, 30hr pruning = 108,000 blocks. Test beyond this to detect archives.</small>
        </div>
    </div>

    <div class="container">
        <h2>Step 3: Discover Archive Nodes</h2>
        <button onclick="discoverArchiveNodes()" id="discoverBtn" disabled>Start P2P Discovery</button>
        <button onclick="stopDiscovery()" id="stopBtn" disabled>Stop Discovery</button>
        <button onclick="exportArchiveNodes()" id="exportBtn" disabled>Export Archive List</button>
        
        <div class="stats">
            <div class="stat-box">
                <div class="stat-value" id="totalNodes">0</div>
                <div class="stat-label">Total Nodes Tested</div>
            </div>
            <div class="stat-box">
                <div class="stat-value" id="archiveCount">0</div>
                <div class="stat-label">Archive Nodes Found</div>
            </div>
            <div class="stat-box">
                <div class="stat-value" id="connectedCount">0</div>
                <div class="stat-label">Active Connections</div>
            </div>
            <div class="stat-box">
                <div class="stat-value" id="avgResponse">-</div>
                <div class="stat-label">Avg Response (ms)</div>
            </div>
        </div>
    </div>

    <div class="container">
        <h2>Discovered Archive Nodes</h2>
        <div id="archiveResults"></div>
    </div>

    <div class="container">
        <h2>Debug Log</h2>
        <div class="log" id="debugLog"></div>
    </div>

    <script type="module">
        // Global variables
        let kaspa = null;
        let isInitialized = false;
        let isDiscovering = false;
        let discoveredNodes = new Map();
        let archiveNodes = new Map();
        let activeConnections = new Map();
        
        // Statistics
        let stats = {
            totalTested: 0,
            archivesFound: 0,
            activeConnections: 0,
            totalResponseTime: 0,
            responseCount: 0
        };

        // Logging function
        function log(message, type = 'info') {
            const timestamp = new Date().toLocaleTimeString();
            const logDiv = document.getElementById('debugLog');
            const logEntry = document.createElement('div');
            logEntry.className = type;
            logEntry.textContent = `[${timestamp}] ${message}`;
            logDiv.appendChild(logEntry);
            logDiv.scrollTop = logDiv.scrollHeight;
            console.log(`[${type.toUpperCase()}] ${message}`);
        }

        // Update statistics display
        function updateStats() {
            document.getElementById('totalNodes').textContent = stats.totalTested;
            document.getElementById('archiveCount').textContent = stats.archivesFound;
            document.getElementById('connectedCount').textContent = stats.activeConnections;
            
            const avgResponse = stats.responseCount > 0 
                ? Math.round(stats.totalResponseTime / stats.responseCount)
                : '-';
            document.getElementById('avgResponse').textContent = avgResponse;
        }

        // Initialize Kaspa module
        window.initializeKaspa = async function() {
            const btn = document.getElementById('initBtn');
            const status = document.getElementById('initStatus');
            btn.disabled = true;
            
            try {
                log('Initializing Kaspa WASM module for mainnet P2P...');
                
                // Import kaspa module from local files (same as testnet version)
                log('Importing kaspa-core.js from local directory...');
                kaspa = await import('./kaspa-core.js');
                log('kaspa-core.js imported successfully', 'success');
                
                // Initialize WASM
                log('Initializing WASM module...');
                await kaspa.default('./kaspa-core_bg.wasm');
                log('Kaspa WASM initialized successfully', 'success');
                
                // Check available functions
                const functions = ['RpcClient', 'Resolver', 'Address', 'PrivateKey'];
                for (const func of functions) {
                    if (kaspa[func]) {
                        log(`‚úì ${func} is available`, 'success');
                    } else {
                        log(`‚úó ${func} is NOT available`, 'error');
                    }
                }
                
                isInitialized = true;
                status.innerHTML = '<div class="success">‚úì Kaspa P2P module initialized for mainnet</div>';
                document.getElementById('discoverBtn').disabled = false;
                
            } catch (error) {
                log(`Initialization error: ${error.message}`, 'error');
                status.innerHTML = `<div class="error">‚úó Initialization failed: ${error.message}</div>`;
                btn.disabled = false;
            }
        }

        // Discover archive nodes
        window.discoverArchiveNodes = async function() {
            if (!isInitialized || isDiscovering) return;
            
            isDiscovering = true;
            document.getElementById('discoverBtn').disabled = true;
            document.getElementById('stopBtn').disabled = false;
            
            log('‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ', 'info');
            log('Starting mainnet archive node P2P discovery...', 'info');
            
            // Get configuration
            const dnsSeeds = document.getElementById('dnsSeeds').value
                .split('\n')
                .map(s => s.trim())
                .filter(s => s.length > 0);
                
            const knownArchives = document.getElementById('knownArchives').value
                .split('\n')
                .map(s => s.trim())
                .filter(s => s.length > 0);
                
            const testHeight = parseInt(document.getElementById('testHeight').value) || 200000;
            
            // Phase 1: Node provider discovery
            log(`Phase 1: Discovering nodes from ${dnsSeeds.length} providers...`, 'info');
            const mainnetNodes = await discoverFromDNSSeeds(dnsSeeds);
            
            // Phase 2: Add known archives
            if (knownArchives.length > 0) {
                log(`Phase 2: Adding ${knownArchives.length} known archive nodes...`, 'info');
                for (const url of knownArchives) {
                    mainnetNodes.push({ url, source: 'manual' });
                }
            }
            
            // Phase 3: Test each node for archive capability
            log(`Phase 3: Testing ${mainnetNodes.length} nodes for archive capability...`, 'info');
            await testNodesForArchiveCapability(mainnetNodes, testHeight);
            
            // Phase 4: Maintain persistent connections to archives
            log(`Phase 4: Establishing persistent connections to archive nodes...`, 'info');
            await maintainArchiveConnections();
            
            document.getElementById('exportBtn').disabled = false;
            log('Archive node discovery complete!', 'success');
            log(`Found ${archiveNodes.size} archive nodes out of ${stats.totalTested} tested`, 'success');
        }

        // Discover nodes from providers
        async function discoverFromDNSSeeds(providers) {
            const nodes = [];
            
            // Node names for each provider group (from P2P doc)
            const nodeGroups = {
                'kaspa.stream': ['eric', 'maxim', 'sean', 'troy'],
                'kaspa.red': ['john', 'mike', 'paul', 'alex'],
                'kaspa.green': ['jake', 'mark', 'adam', 'liam', 'fermion'],
                'kaspa.blue': ['noah', 'ryan', 'jack', 'luke', 'tau']
            };
            
            // Common mainnet ports
            const mainnetPorts = [
                16110, // wRPC Borsh
                16111, // wRPC JSON  
            ];
            
            for (const provider of providers) {
                log(`Processing provider: ${provider}`, 'info');
                
                // Get node names for this provider
                const nodeNames = nodeGroups[provider] || ['node1', 'node2'];
                
                for (const nodeName of nodeNames) {
                    // Pattern 1: Full path with node name
                    nodes.push({ 
                        url: `wss://${nodeName}.${provider}/kaspa/mainnet/wrpc/borsh`,
                        source: `provider:${provider}`
                    });
                    
                    // Pattern 2: Direct port connection
                    for (const port of mainnetPorts) {
                        nodes.push({ 
                            url: `wss://${nodeName}.${provider}:${port}`,
                            source: `provider:${provider}`
                        });
                    }
                }
                
                // Also try provider root domain
                nodes.push({ 
                    url: `wss://${provider}:16110`,
                    source: `provider:${provider}`
                });
                
                // Try common subdomain patterns
                const subdomains = ['archive', 'mainnet', 'rpc', 'api'];
                for (const sub of subdomains) {
                    nodes.push({ 
                        url: `wss://${sub}.${provider}:16110`,
                        source: `provider:${provider}`
                    });
                }
            }
            
            // Add some known working endpoints
            const knownEndpoints = [
                'wss://kaspa.blocksight.net:16110',
                'wss://kaspa-node.accelerationpool.com:16110',
                'wss://mainnet.kaspa.org:16110'
            ];
            
            for (const endpoint of knownEndpoints) {
                nodes.push({ url: endpoint, source: 'known' });
            }
            
            return nodes;
        }

        // Test nodes for archive capability
        async function testNodesForArchiveCapability(nodes, testHeight) {
            const batchSize = 5; // Test 5 nodes concurrently
            
            for (let i = 0; i < nodes.length; i += batchSize) {
                if (!isDiscovering) break;
                
                const batch = nodes.slice(i, i + batchSize);
                const promises = batch.map(node => testSingleNode(node, testHeight));
                await Promise.allSettled(promises);
            }
        }

        // Test single node
        async function testSingleNode(node, testHeight) {
            const startTime = Date.now();
            stats.totalTested++;
            updateStats();
            
            log(`Testing node: ${node.url}`, 'info');
            
            try {
                // Create RPC client
                const client = new kaspa.RpcClient({
                    url: node.url,
                    networkId: 'mainnet'
                });
                
                // Connect with timeout
                const connectTimeout = new Promise((_, reject) => 
                    setTimeout(() => reject(new Error('Connection timeout')), 10000)
                );
                
                await Promise.race([client.connect(), connectTimeout]);
                
                // Get node info
                const info = await client.getServerInfo();
                const currentHeight = await client.getBlockDagInfo();
                const blockCount = currentHeight.blockCount || currentHeight.virtualDaaScore || 0;
                const blockCountNum = typeof blockCount === 'bigint' ? Number(blockCount) : blockCount;
                
                // Calculate response time
                const responseTime = Date.now() - startTime;
                stats.totalResponseTime += responseTime;
                stats.responseCount++;
                
                log(`Connected to ${node.url} - Height: ${blockCountNum.toLocaleString()}, Response: ${responseTime}ms`, 'success');
                
                // Test archive capability
                let isArchive = false;
                
                try {
                    // For mainnet, we need to test data availability
                    // Since we can't easily get block hash by height, we'll use a different approach
                    log(`Testing historical data availability...`);
                    
                    // Simple heuristic: if block count is very high and node is responsive,
                    // it might be an archive. This is not perfect but works for discovery.
                    if (blockCountNum > 50000000) { // 50M blocks suggests long-running node
                        log(`Node has ${(blockCountNum/1000000).toFixed(1)}M blocks - possible archive`, 'info');
                        isArchive = true;
                    } else {
                        log(`Node has ${(blockCountNum/1000000).toFixed(1)}M blocks - likely pruned`, 'info');
                    }
                    
                    // Additional test: check response time and stability
                    if (responseTime < 2000 && blockCountNum > 30000000) {
                        log(`Fast response (${responseTime}ms) with high block count - marking as archive`, 'success');
                        isArchive = true;
                    }
                    
                } catch (e) {
                    // Expected for problematic nodes
                    log(`Error during archive test: ${e.message}`, 'warning');
                }
                
                // Store node info
                const nodeInfo = {
                    url: node.url,
                    source: node.source,
                    isArchive,
                    blockHeight: blockCountNum,
                    responseTime,
                    lastSeen: new Date(),
                    serverVersion: info.serverVersion || 'Unknown',
                    networkId: info.networkId || 'mainnet',
                    client
                };
                
                discoveredNodes.set(node.url, nodeInfo);
                
                if (isArchive) {
                    log(`‚ö° ARCHIVE NODE FOUND: ${node.url}`, 'archive');
                    log(`‚Ä¢ Server: ${nodeInfo.serverVersion}`, 'archive');
                    log(`‚Ä¢ Height: ${blockCountNum.toLocaleString()}`, 'archive');
                    log(`‚Ä¢ Response: ${responseTime}ms`, 'archive');
                    
                    archiveNodes.set(node.url, nodeInfo);
                    stats.archivesFound++;
                    updateArchiveDisplay();
                } else {
                    // Disconnect from non-archive nodes
                    await client.disconnect();
                }
                
                updateStats();
                
            } catch (error) {
                log(`Failed to test ${node.url}: ${error.message}`, 'error');
            }
        }

        // Maintain connections to archive nodes
        async function maintainArchiveConnections() {
            const maxConnections = 5; // Keep 5 archive connections
            
            // Sort archives by response time
            const sortedArchives = Array.from(archiveNodes.values())
                .sort((a, b) => a.responseTime - b.responseTime)
                .slice(0, maxConnections);
            
            log(`Maintaining connections to top ${sortedArchives.length} archive nodes...`, 'info');
            
            for (const archive of sortedArchives) {
                activeConnections.set(archive.url, archive);
                stats.activeConnections = activeConnections.size;
                updateStats();
                
                // Set up health monitoring
                setupHealthMonitoring(archive);
            }
        }

        // Health monitoring for archive connections
        function setupHealthMonitoring(archive) {
            const checkInterval = 30000; // 30 seconds
            
            const healthCheck = setInterval(async () => {
                if (!isDiscovering || !activeConnections.has(archive.url)) {
                    clearInterval(healthCheck);
                    return;
                }
                
                try {
                    const info = await archive.client.getServerInfo();
                    log(`Health check OK for ${archive.url}`, 'success');
                } catch (error) {
                    log(`Health check failed for ${archive.url}: ${error.message}`, 'error');
                    // Reconnect logic would go here
                }
            }, checkInterval);
        }

        // Update archive display
        function updateArchiveDisplay() {
            const container = document.getElementById('archiveResults');
            let html = '';
            
            if (archiveNodes.size === 0) {
                html = '<div class="node-card">No archive nodes discovered yet...</div>';
            } else {
                html = '<table><tr><th>URL</th><th>Height</th><th>Response</th><th>Version</th><th>Status</th></tr>';
                
                for (const [url, node] of archiveNodes) {
                    const isActive = activeConnections.has(url);
                    const status = isActive ? '<span class="success">Connected</span>' : 'Discovered';
                    
                    html += `<tr>
                        <td class="clickable" onclick="copyToClipboard('${url}')">${url}</td>
                        <td>${node.blockHeight.toLocaleString()}</td>
                        <td>${node.responseTime}ms</td>
                        <td>${node.serverVersion}</td>
                        <td>${status}</td>
                    </tr>`;
                }
                
                html += '</table>';
            }
            
            container.innerHTML = html;
        }

        // Stop discovery
        window.stopDiscovery = async function() {
            isDiscovering = false;
            document.getElementById('discoverBtn').disabled = false;
            document.getElementById('stopBtn').disabled = true;
            
            log('Stopping discovery and closing connections...', 'warning');
            
            // Close all connections
            for (const [url, node] of activeConnections) {
                try {
                    await node.client.disconnect();
                    log(`Disconnected from ${url}`, 'info');
                } catch (e) {
                    // Ignore disconnect errors
                }
            }
            
            activeConnections.clear();
            stats.activeConnections = 0;
            updateStats();
        }

        // Export archive nodes
        window.exportArchiveNodes = function() {
            const archives = Array.from(archiveNodes.values()).map(node => ({
                url: node.url,
                blockHeight: node.blockHeight,
                responseTime: node.responseTime,
                serverVersion: node.serverVersion,
                lastSeen: node.lastSeen
            }));
            
            const data = JSON.stringify(archives, null, 2);
            const blob = new Blob([data], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `kaspa-mainnet-archives-${new Date().toISOString().split('T')[0]}.json`;
            a.click();
            
            log(`Exported ${archives.length} archive nodes to JSON`, 'success');
        }

        // Copy to clipboard
        window.copyToClipboard = function(text) {
            navigator.clipboard.writeText(text).then(() => {
                log(`Copied to clipboard: ${text}`, 'success');
            });
        }

        // Auto-initialize on load
        window.addEventListener('DOMContentLoaded', () => {
            log('Kaspa Mainnet Archive Node P2P Discovery Tool Ready', 'info');
            log('Click "Initialize Kaspa P2P" to begin', 'info');
        });
    </script>
</body>
</html>
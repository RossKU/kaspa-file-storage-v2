<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Kaspa P2P File Storage v5.0.10 - Multi-Wallet Phase 1 Test</title>
    <style>
        body {
            font-family: 'Arial', sans-serif;
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
            background: #1a1a2e;
            color: #eee;
        }
        .header {
            background: linear-gradient(135deg, #16213e 0%, #0f3460 100%);
            padding: 30px;
            border-radius: 10px;
            text-align: center;
            margin-bottom: 30px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.3);
        }
        h1 {
            margin: 0;
            color: #e94560;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
        }
        .container {
            background: #0f3460;
            padding: 25px;
            border-radius: 10px;
            margin-bottom: 20px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.2);
        }
        .tab-buttons {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
        }
        .tab-btn {
            flex: 1;
            background: #16213e;
            color: #e94560;
            border: 2px solid #e94560;
            padding: 15px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
            transition: all 0.3s;
        }
        .tab-btn:hover {
            background: #1a2540;
            transform: translateY(-2px);
        }
        .tab-btn.active {
            background: #e94560;
            color: white;
        }
        .tab-content {
            display: none;
        }
        .tab-content.active {
            display: block;
        }
        button {
            background: #e94560;
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
            margin: 5px;
            transition: all 0.3s;
        }
        button:hover {
            background: #c13651;
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(233, 69, 96, 0.3);
        }
        button:disabled {
            background: #666;
            cursor: not-allowed;
            transform: none;
        }
        .small-button {
            background: #16213e;
            color: #49EACB;
            border: 1px solid #49EACB;
            padding: 8px 16px;
            font-size: 14px;
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.3s;
        }
        .small-button:hover {
            background: #49EACB;
            color: #16213e;
        }
        .small-button.disabled,
        .small-button:disabled {
            pointer-events: none !important;
            opacity: 0.5;
            background: #666 !important;
            cursor: not-allowed !important;
        }
        .history-item {
            background: #16213e;
            border: 1px solid #333;
            padding: 15px;
            margin-bottom: 10px;
            border-radius: 5px;
            transition: all 0.3s;
        }
        .history-item:hover {
            border-color: #e94560;
        }
        .history-item-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }
        .history-item-actions button {
            margin-left: 5px;
            padding: 5px 10px;
            font-size: 12px;
        }
        input[type="text"], input[type="password"], input[type="number"], select, textarea {
            width: 100%;
            background: #16213e;
            color: #eee;
            border: 1px solid #e94560;
            padding: 10px;
            border-radius: 5px;
            margin: 5px 0;
            font-family: 'Consolas', monospace;
        }
        input[type="file"] {
            display: none;
        }
        .file-input-label {
            display: inline-block;
            background: #16213e;
            color: #e94560;
            border: 2px dashed #e94560;
            padding: 30px;
            border-radius: 5px;
            cursor: pointer;
            text-align: center;
            transition: all 0.3s;
            width: 100%;
            box-sizing: border-box;
            margin: 10px 0;
        }
        .file-input-label:hover {
            background: #1a2540;
            border-color: #ff5c7c;
        }
        .metric-box {
            background: rgba(233, 69, 96, 0.1);
            border: 1px solid #e94560;
            padding: 15px;
            border-radius: 5px;
            margin: 10px 0;
        }
        .success { color: #4CAF50; }
        .error { color: #ff5252; }
        .warning { color: #ffc107; }
        .info { color: #2196F3; }
        .progress-bar {
            width: 100%;
            height: 30px;
            background: #16213e;
            border-radius: 15px;
            overflow: hidden;
            margin: 10px 0;
        }
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #e94560, #ff5c7c);
            transition: width 0.3s;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: bold;
        }
        .status-indicator {
            display: inline-block;
            width: 10px;
            height: 10px;
            border-radius: 50%;
            margin-right: 5px;
        }
        .status-online { background: #4CAF50; }
        .status-offline { background: #ff5252; }
        .status-connecting { background: #ffc107; animation: pulse 1s infinite; }
        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.5; }
            100% { opacity: 1; }
        }
        .log-container {
            background: #0a0a0a;
            color: #0f0;
            font-family: 'Consolas', monospace;
            font-size: 12px;
            padding: 10px;
            height: 200px;
            overflow-y: auto;
            border-radius: 5px;
            margin: 10px 0;
            white-space: pre-wrap;
            word-wrap: break-word;
        }
        .log-entry {
            margin: 2px 0;
        }
        .log-time {
            color: #888;
        }
        .log-error {
            color: #ff5252;
        }
        .log-success {
            color: #4CAF50;
        }
        .log-info {
            color: #2196F3;
        }
        .log-warning {
            color: #ffc107;
        }
        .chunk-item {
            background: #16213e;
            padding: 10px;
            margin: 5px 0;
            border-radius: 5px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border: 1px solid rgba(233, 69, 96, 0.3);
        }
        .chunk-status {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        .chunk-status.pending { color: #888; }
        .chunk-status.uploading { color: #ffc107; }
        .chunk-status.success { color: #4CAF50; }
        .chunk-status.error { color: #ff5252; }
        .json-view {
            background: #0a0a0a;
            color: #4CAF50;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
            font-family: 'Consolas', monospace;
            font-size: 14px;
            line-height: 1.5;
            max-height: 400px;
            overflow-y: auto;
        }
        .grid-2 {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
        }
        .checkbox-label {
            display: flex;
            align-items: center;
            gap: 10px;
            margin: 10px 0;
        }
        .checkbox-label input[type="checkbox"] {
            width: auto;
        }
        .kaspa-file-drop {
            background: #16213e;
            border: 2px dashed #e94560;
            padding: 40px;
            text-align: center;
            border-radius: 10px;
            transition: all 0.3s;
        }
        .kaspa-file-drop:hover {
            background: #1a2540;
            border-color: #ff5c7c;
        }
        .kaspa-file-drop.dragover {
            background: #1a2540;
            border-color: #4CAF50;
        }
        .copy-btn {
            background: #16213e;
            color: #e94560;
            border: 1px solid #e94560;
            padding: 5px 10px;
            font-size: 12px;
            cursor: pointer;
        }
        .copy-btn:hover {
            background: #e94560;
        }
        /* Toggle switch styles for parallel download */
        .toggle-switch {
            position: relative;
            display: inline-block;
            width: 50px;
            height: 24px;
            margin-left: 10px;
            vertical-align: middle;
        }
        .toggle-switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }
        .toggle-slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #666;
            transition: .4s;
            border-radius: 24px;
        }
        .toggle-slider:before {
            position: absolute;
            content: "";
            height: 18px;
            width: 18px;
            left: 3px;
            bottom: 3px;
            background-color: white;
            transition: .4s;
            border-radius: 50%;
        }
        input:checked + .toggle-slider {
            background-color: #49EACB;
        }
        input:checked + .toggle-slider:before {
            transform: translateX(26px);
        }
        .setting-row {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin: 15px 0;
        }
        .setting-label {
            font-size: 14px;
            color: #eee;
            color: white;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 15px 0;
        }
        th, td {
            padding: 12px;
            text-align: left;
            border-bottom: 1px solid rgba(255,255,255,0.1);
        }
        th {
            background: rgba(233, 69, 96, 0.2);
            color: #e94560;
        }
        .section-divider {
            border-top: 2px solid #e94560;
            margin: 20px 0;
            padding-top: 20px;
        }
        .history-item {
            background: #16213e;
            border: 1px solid rgba(233, 69, 96, 0.3);
            padding: 15px;
            margin: 10px 0;
            border-radius: 8px;
            transition: all 0.3s;
        }
        .history-item:hover {
            border-color: #e94560;
            background: #1a2540;
        }
        .history-item-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 10px;
        }
        .history-item-actions {
            display: flex;
            gap: 5px;
            flex-wrap: wrap;
        }
    </style>
</head>
<body>
    <div class="header">
        <h1 id="appTitle">ğŸš€ Kaspa P2P File Storage - Loading...</h1>
        <p>å®Ÿãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯æ¥ç¶šã«ã‚ˆã‚‹å®Œå…¨ãªP2Pãƒ•ã‚¡ã‚¤ãƒ«å…±æœ‰ã‚·ã‚¹ãƒ†ãƒ ï¼ˆç”¨èªä¿®æ­£ï¼‰</p>
        <p id="appSubtitle" style="font-size: 12px; color: #49EACB; margin-top: 5px;">ğŸ“‹ Loading version...</p>
        <div id="networkStatus" style="margin-top: 10px;">
            <span class="status-indicator status-offline"></span>
            <span id="statusText">æœªæ¥ç¶š</span>
        </div>
    </div>

    <!-- Tab Navigation -->
    <div class="tab-buttons">
        <button class="tab-btn active" onclick="switchTab('upload')">ğŸ“¤ Upload</button>
        <button class="tab-btn" onclick="switchTab('download')">ğŸ“¥ Download</button>
        <button class="tab-btn" onclick="switchTab('directory')">ğŸ“ Directory</button>
        <button class="tab-btn" onclick="switchTab('history')">ğŸ“œ History</button>
        <button class="tab-btn" onclick="switchTab('settings')">âš™ï¸ Settings</button>
    </div>

    <!-- Upload Tab -->
    <div id="upload-tab" class="tab-content active">
        <!-- WASM Initialization -->
        <div class="container">
            <h2>ğŸ”§ ã‚·ã‚¹ãƒ†ãƒ åˆæœŸåŒ–</h2>
            <div class="grid-2">
                <button onclick="initializeSystem()" id="initBtn">ã‚·ã‚¹ãƒ†ãƒ ã‚’åˆæœŸåŒ–</button>
                <button onclick="setupWorkspace()" id="workspaceBtn">ä½œæ¥­ãƒ•ã‚©ãƒ«ãƒ€è¨­å®š</button>
                <button onclick="testConnection()" id="testBtn" disabled>æ¥ç¶šãƒ†ã‚¹ãƒˆ</button>
            </div>
            <div id="initStatus" class="metric-box" style="display: none;"></div>
        </div>

        <!-- File Upload -->
        <div class="container">
            <h2>ğŸ“ ãƒ•ã‚¡ã‚¤ãƒ«ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰</h2>
            
            <label for="fileInput" class="file-input-label">
                ğŸ“ ãƒ•ã‚¡ã‚¤ãƒ«ã‚’é¸æŠ<br>
                <small>ã¾ãŸã¯ãƒ‰ãƒ©ãƒƒã‚°&ãƒ‰ãƒ­ãƒƒãƒ—</small>
            </label>
            <input type="file" id="fileInput" onchange="handleFileSelect(event)">
            
            <!-- Resume Section -->
            <div class="section-divider" style="margin: 20px 0;">
                <p style="text-align: center; color: #999;">ã¾ãŸã¯</p>
                <button onclick="loadProgressFile()" style="background: #16213e; color: #e94560; border: 2px solid #e94560;">
                    ğŸ“‚ é€²æ—ãƒ•ã‚¡ã‚¤ãƒ« (.kprogress) ã‹ã‚‰å†é–‹
                </button>
                <input type="file" id="progressFileInput" accept=".kprogress" style="display: none;" onchange="handleProgressFileSelect(event)">
            </div>
            
            <!-- Resume Info -->
            <div id="resumeInfo" style="display: none;" class="metric-box">
                <h4 class="success">âœ… ãƒ¬ã‚¸ãƒ¥ãƒ¼ãƒ æº–å‚™å®Œäº†</h4>
                <div id="resumeDetails"></div>
                <button onclick="cancelResume()" style="background: #666; margin-top: 10px;">ã‚­ãƒ£ãƒ³ã‚»ãƒ«</button>
            </div>
            
            <div class="grid-2">
                <div>
                    <label>ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ (8æ–‡å­—ä»¥ä¸Š)</label>
                    <input type="password" id="uploadPassword" placeholder="å¼·åŠ›ãªãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ã‚’å…¥åŠ›">
                </div>
                <div>
                    <label>ãƒãƒ£ãƒ³ã‚¯ã‚µã‚¤ã‚º</label>
                    <select id="chunkSize">
                        <option value="10">10KB chunks (å®‰å…¨)</option>
                        <option value="12" selected>12KB chunks (æ¨å¥¨)</option>
                        <option value="15">15KB chunks (ãƒªã‚¹ã‚¯ã‚ã‚Š)</option>
                        <option value="20">ğŸ§ª 20KB chunks (å®Ÿé¨“çš„)</option>
                    <option value="22">ğŸš€ 22KB chunks (æœ€é©åŒ–ãƒ»å®Ÿé¨“çš„)</option>
                    </select>
                </div>
            </div>
            
            <div class="checkbox-label">
                <input type="checkbox" id="useMetaTx" checked>
                <label for="useMetaTx">ãƒ¡ã‚¿TxIDã‚’ä½¿ç”¨ï¼ˆæ¨å¥¨ï¼šå±¥æ­´ã‹ã‚‰ç°¡å˜ã«å…±æœ‰å¯èƒ½ï¼‰</label>
            </div>
            
            
            <div class="checkbox-label">
                <input type="checkbox" id="useRandomCid">
                <label for="useRandomCid">ãƒ©ãƒ³ãƒ€ãƒ CIDã‚’ä½¿ç”¨ï¼ˆæ¤œé–²å›é¿ï¼‰</label>
            </div>
            
            <button onclick="processAndUpload()" id="uploadBtn" disabled>
                ãƒ•ã‚¡ã‚¤ãƒ«ã‚’å‡¦ç†ã—ã¦ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰
            </button>
            
            <!-- Upload Progress -->
            <div id="uploadProgress" style="display: none;">
                <div class="progress-bar">
                    <div class="progress-fill" id="uploadProgressBar">0%</div>
                </div>
                <div id="chunksList"></div>
            </div>
            
            <!-- .kaspa generation moved to History tab -->
        </div>
    </div>

    <!-- Download Tab -->
    <div id="download-tab" class="tab-content">
        <div class="container">
            <h2>ğŸ“¥ ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰</h2>
            
            <!-- Unified input option -->
            <div class="section-divider">
                <h3>ğŸ”— TxID / MetaTxID / ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªTxIDã‹ã‚‰å¾©å…ƒ</h3>
                <div style="background: #0a2540; padding: 15px; border-radius: 8px; margin-bottom: 15px;">
                    <input type="text" id="unifiedTxIdInput" placeholder="ä»»æ„ã®TxIDã‚’å…¥åŠ›ï¼ˆè‡ªå‹•åˆ¤åˆ¥ï¼‰" style="width: 100%; font-size: 16px;">
                    <input type="password" id="unifiedPassword" placeholder="ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ï¼ˆå¿…è¦ãªå ´åˆï¼‰" style="width: 100%; margin-top: 10px;">
                    <button onclick="loadFromUnifiedInput()" style="margin-top: 10px; width: 100%; padding: 12px; font-size: 16px;">
                        ğŸ” è‡ªå‹•åˆ¤åˆ¥ã—ã¦å¾©å…ƒ
                    </button>
                </div>
                <div class="info" style="font-size: 12px; color: #999;">
                    <p>âœ¨ ã™ã¹ã¦ã®ã‚¿ã‚¤ãƒ—ã‚’è‡ªå‹•åˆ¤åˆ¥:</p>
                    <ul style="margin: 5px 0; padding-left: 20px;">
                        <li>ğŸ“„ é€šå¸¸ãƒ•ã‚¡ã‚¤ãƒ«ã®MetaTxID</li>
                        <li>ğŸ“ ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã®MetaTxID</li>
                        <li>ğŸ“š å¤§å®¹é‡ãƒ•ã‚¡ã‚¤ãƒ«ã®SuperMetaTxID</li>
                        <li>ğŸ”— TxID:BlockIDå½¢å¼ã‚‚å¯¾å¿œ</li>
                    </ul>
                </div>
            </div>
            
            <div style="text-align: center; margin: 20px 0; color: #666;">
                â”€â”€â”€ ã¾ãŸã¯ â”€â”€â”€
            </div>
            
            <!-- Legacy Meta-TxID input (hidden by default) -->
            <div class="section-divider" style="display: none;">
                <h3>ğŸ”— ãƒ¡ã‚¿TxIDã‹ã‚‰å¾©å…ƒï¼ˆæ—§ï¼‰</h3>
                <input type="text" id="metaTxIdInput" placeholder="ãƒ¡ã‚¿TxID ã¾ãŸã¯ TxID:BlockID ã‚’å…¥åŠ›" style="width: 100%;">
                <input type="password" id="metaTxPassword" placeholder="ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰" style="width: 100%; margin-top: 10px;">
                <button onclick="loadFromMetaTxId()" style="margin-top: 10px;">ãƒ¡ã‚¿TxIDã‹ã‚‰å¾©å…ƒ</button>
                <div class="info" style="margin-top: 10px; font-size: 12px;">
                    <p>ğŸ“Œ å¯¾å¿œãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆ:</p>
                    <ul style="margin: 5px 0; padding-left: 20px;">
                        <li>TxID:BlockID:Passwordå½¢å¼ï¼ˆãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰è‡ªå‹•å…¥åŠ›ï¼‰</li>
                        <li>TxID:BlockIDå½¢å¼ï¼ˆæ¨å¥¨ã€REST APIä¸è¦ï¼‰</li>
                        <li>TxIDã®ã¿ï¼ˆREST APIå¿…è¦ï¼‰</li>
                    </ul>
                </div>
            </div>
            
            <div class="section-divider" style="margin-top: 20px;">
                <h3>ğŸ“ ã¾ãŸã¯.kaspaãƒ•ã‚¡ã‚¤ãƒ«ã‹ã‚‰å¾©å…ƒ</h3>
                <div class="kaspa-file-drop" onclick="document.getElementById('kaspaFileInput').click()" 
                     ondrop="handleKaspaDrop(event)" 
                     ondragover="handleDragOver(event)" 
                     ondragleave="handleDragLeave(event)">
                    <p>ğŸ“ .kaspaãƒ•ã‚¡ã‚¤ãƒ«ã‚’ã‚¯ãƒªãƒƒã‚¯ã—ã¦é¸æŠ<br>ã¾ãŸã¯ãƒ‰ãƒ©ãƒƒã‚°&ãƒ‰ãƒ­ãƒƒãƒ—</p>
                </div>
                <input type="file" id="kaspaFileInput" accept=".kaspa" style="display:none" onchange="loadKaspaFile(event)">
            </div>
            
            <div id="downloadSection" style="display: none;">
                <div class="metric-box">
                    <h3>ãƒ•ã‚¡ã‚¤ãƒ«æƒ…å ±</h3>
                    <pre id="fileInfo"></pre>
                </div>
                
                <div id="passwordSection">
                    <label>ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰</label>
                    <input type="password" id="downloadPassword" placeholder="ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ã‚’å…¥åŠ›">
                </div>
                
                <button id="downloadBtn" onclick="downloadFile()">ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰</button>
                
                <div id="downloadProgress" style="display: none;">
                    <div class="progress-bar">
                        <div class="progress-fill" id="downloadProgressBar">0%</div>
                    </div>
                    <div id="downloadStatus"></div>
                </div>
            </div>
        </div>
    </div>

    <!-- Directory Tab -->
    <div id="directory-tab" class="tab-content">
        <div class="container">
            <h2>ğŸ“ ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªç®¡ç†</h2>
            
            <div class="metric-box">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
                    <h3>ğŸ“¤ å±¥æ­´ã‹ã‚‰ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªä½œæˆ</h3>
                </div>
                
                <input type="text" id="directoryName" placeholder="ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªåã‚’å…¥åŠ›" style="width: 100%; padding: 10px; margin-bottom: 10px; background: #16213e; color: #eee; border: 1px solid #49EACB; border-radius: 5px;">
                
                <button onclick="showHistoryForDirectory()" style="width: 100%; margin-bottom: 15px; background: #16213e; color: #49EACB; border: 2px solid #49EACB;">
                    ğŸ“„ å±¥æ­´ã‹ã‚‰ãƒ•ã‚¡ã‚¤ãƒ«ã‚’é¸æŠ
                </button>
                
                <div id="historyFileSelector" style="display: none; margin-bottom: 15px;">
                    <h4>ãƒ•ã‚¡ã‚¤ãƒ«ã‚’é¸æŠ:</h4>
                    <div id="historyFileList" style="max-height: 300px; overflow-y: auto; border: 1px solid #49EACB; border-radius: 5px; padding: 10px; background: #16213e;">
                        <!-- å±¥æ­´ãƒ•ã‚¡ã‚¤ãƒ«ãƒªã‚¹ãƒˆãŒã“ã“ã«è¡¨ç¤ºã•ã‚Œã¾ã™ -->
                    </div>
                </div>
                
                <div id="selectedFilesInfo" style="margin-bottom: 10px; padding: 10px; background: #16213e; border-radius: 5px; display: none;">
                    <strong>é¸æŠã•ã‚ŒãŸãƒ•ã‚¡ã‚¤ãƒ«:</strong> <span id="selectedCount">0</span>å€‹
                </div>
                
                <div style="margin-bottom: 10px;">
                    <label>ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ (8æ–‡å­—ä»¥ä¸Š)</label>
                    <input type="password" id="directoryPassword" placeholder="å¼·åŠ›ãªãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ã‚’å…¥åŠ›" style="width: 100%; padding: 10px; margin-top: 5px; background: #0a2540; color: #eee; border: 1px solid #49EACB; border-radius: 5px;">
                </div>
                
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px;">
                    <button onclick="prepareDirectoryMetadata()" disabled id="prepareDirBtn">
                        ğŸ”§ ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿ã‚’ç”Ÿæˆã®ã¿
                    </button>
                    <button onclick="prepareAndUploadDirectory()" disabled id="prepareAndUploadBtn">
                        ğŸ“¤ ç”Ÿæˆã—ã¦ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰
                    </button>
                </div>
            </div>
            
            <div class="metric-box" style="display: none;">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
                    <h3>æ–°è¦ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªä½œæˆï¼ˆæ—§æ©Ÿèƒ½ï¼‰</h3>
                </div>
                
                <div style="margin-bottom: 10px;">
                    <label>è¦ªãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªï¼ˆã‚ªãƒ—ã‚·ãƒ§ãƒ³ï¼‰:</label>
                    <select id="parentDirectory" style="width: 100%; padding: 10px; background: #16213e; color: #eee; border: 1px solid #49EACB; border-radius: 5px;">
                        <option value="">ãƒ«ãƒ¼ãƒˆãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒª</option>
                    </select>
                </div>
                
                <div id="fileSelector" style="margin-bottom: 15px;">
                    <h4>ãƒ•ã‚¡ã‚¤ãƒ«ã¨ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã‚’é¸æŠ:</h4>
                    <div id="fileList" style="max-height: 300px; overflow-y: auto; border: 1px solid #49EACB; border-radius: 5px; padding: 10px;">
                    </div>
                </div>
                
                <button onclick="createDirectory()" style="width: 100%;">ğŸ“ ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã‚’ä½œæˆ</button>
            </div>
            
            <div class="metric-box">
                <h3>ğŸ“‚ æ—¢å­˜ã®ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒª</h3>
                <div id="directoryList" style="margin-top: 15px;">
                    <!-- ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªãƒªã‚¹ãƒˆãŒã“ã“ã«è¡¨ç¤ºã•ã‚Œã¾ã™ -->
                </div>
            </div>
        </div>
    </div>

    <!-- History Tab -->
    <div id="history-tab" class="tab-content">
        <div class="container">
            <h2>ğŸ“œ ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰å±¥æ­´</h2>
            
            <div class="metric-box">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
                    <h3>å±¥æ­´ç®¡ç†</h3>
                    <div>
                        <button onclick="window.historyManager?.exportKenv()" class="small-button">ğŸ“¥ .kenvã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆ</button>
                        <button onclick="window.historyManager?.importKenv()" class="small-button">ğŸ“¤ .kenvã‚¤ãƒ³ãƒãƒ¼ãƒˆ</button>
                    </div>
                </div>
                
                <div id="historyStats" style="margin-bottom: 15px; padding: 10px; background: #0f3460; border-radius: 5px;">
                    <span>ç·ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰: <strong id="totalUploads">0</strong></span> | 
                    <span>ç·å®¹é‡: <strong id="totalSize">0 KB</strong></span> | 
                    <span>ç·ã‚³ã‚¹ãƒˆ: <strong id="totalCost">0 KAS</strong></span>
                </div>
                
                <div id="historyList" style="max-height: 400px; overflow-y: auto;">
                    <!-- å±¥æ­´ã‚¢ã‚¤ãƒ†ãƒ ãŒã“ã“ã«å‹•çš„ã«è¿½åŠ ã•ã‚Œã‚‹ -->
                </div>
            </div>
        </div>
    </div>

    <!-- Settings Tab -->
    <div id="settings-tab" class="tab-content">
        <div class="container">
            <h2>âš™ï¸ è¨­å®š</h2>
            
            <div class="metric-box">
                <h3>ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯è¨­å®š</h3>
                <label>ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯</label>
                <select id="networkSelect">
                    <option value="testnet-10" selected>Testnet-10 (ãƒ†ã‚¹ãƒˆç”¨)</option>
                    <option value="mainnet">Mainnet (æœ¬ç•ª)</option>
                </select>
                
                <label>ãƒªãƒˆãƒ©ã‚¤å›æ•°</label>
                <input type="number" id="retryCount" value="3" min="0" max="10">
                
                <label>ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆ (ç§’)</label>
                <input type="number" id="timeout" value="30" min="10" max="120">
            </div>
            
            <div class="metric-box">
                <h3>ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰è¨­å®š</h3>
                <div class="setting-row">
                    <div class="setting-label">
                        ä¸¦åˆ—ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ (å®Ÿé¨“çš„æ©Ÿèƒ½)<br>
                        <small style="color: #999;">10ãƒãƒ£ãƒ³ã‚¯ä»¥ä¸Šã®ãƒ•ã‚¡ã‚¤ãƒ«ã§8ä¸¦åˆ—æ¥ç¶šã‚’ä½¿ç”¨</small>
                    </div>
                    <label class="toggle-switch">
                        <input type="checkbox" id="parallelDownloadToggle" onchange="toggleParallelDownload()">
                        <span class="toggle-slider"></span>
                    </label>
                </div>
            </div>
            
            <div class="metric-box">
                <h3>ãƒ­ã‚°ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆ</h3>
                <button onclick="exportLogs()">ãƒ­ã‚°ã‚’JSONå½¢å¼ã§ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆ</button>
                <button onclick="clearLogs()">ãƒ­ã‚°ã‚’ã‚¯ãƒªã‚¢</button>
            </div>
            
            <div class="metric-box">
                <h3>ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰å±¥æ­´</h3>
                <div id="uploadHistory"></div>
            </div>
            
            <!-- Multi-Wallet Phase 1 Test -->
            <div class="metric-box" style="margin-top: 30px; background: rgba(73, 234, 203, 0.1); border: 2px solid #49EACB;">
                <h3>ğŸ§ª Multi-Wallet Phase 1 Test</h3>
                <p style="color: #999; font-size: 14px; margin-bottom: 15px;">
                    å®Ÿé¨“çš„æ©Ÿèƒ½: ãƒãƒ«ãƒã‚¦ã‚©ãƒ¬ãƒƒãƒˆã«ã‚ˆã‚‹ä¸¦åˆ—ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰é«˜é€ŸåŒ–ã®ãƒ†ã‚¹ãƒˆ
                </p>
                
                <div style="margin: 15px 0;">
                    <button onclick="runPhase1Test()" style="
                        padding: 10px 20px;
                        background: #49EACB;
                        color: #16213e;
                        border: none;
                        border-radius: 5px;
                        cursor: pointer;
                        font-size: 16px;
                        font-weight: bold;
                    ">
                        Run Phase 1 Test
                    </button>
                    
                    <button onclick="viewTestResults()" style="
                        padding: 10px 20px;
                        background: #16213e;
                        color: #49EACB;
                        border: 2px solid #49EACB;
                        border-radius: 5px;
                        cursor: pointer;
                        font-size: 16px;
                        margin-left: 10px;
                    ">
                        View Saved Wallets
                    </button>
                    
                    <button onclick="clearPhase1Data()" style="
                        padding: 10px 20px;
                        background: #16213e;
                        color: #e94560;
                        border: 2px solid #e94560;
                        border-radius: 5px;
                        cursor: pointer;
                        font-size: 16px;
                        margin-left: 10px;
                    ">
                        Clear Test Data
                    </button>
                </div>
                
                <div id="phase1TestStatus" style="
                    margin-top: 15px;
                    padding: 10px;
                    background: rgba(15, 52, 96, 0.5);
                    border-radius: 5px;
                    font-family: monospace;
                    white-space: pre-wrap;
                    display: none;
                    font-size: 14px;
                    color: #49EACB;
                    border: 1px solid rgba(73, 234, 203, 0.3);
                "></div>
            </div>
        </div>
    </div>

    <!-- System Log -->
    <div class="container">
        <h3>ğŸ“ ã‚·ã‚¹ãƒ†ãƒ ãƒ­ã‚°</h3>
        <div class="log-container" id="systemLog"></div>
        <button class="copy-btn" onclick="copyLog()">ãƒ­ã‚°ã‚’ã‚³ãƒ”ãƒ¼</button>
    </div>

    <script type="module">
        // Debug logging - Safe version
        try {
            console.log('[DEBUG v4.6.3] Script started at:', new Date().toISOString());
            console.log('[DEBUG] User Agent:', navigator.userAgent);
        } catch (e) {
            // Ignore errors in debug logging
        }
        // Global state
        let kaspa = null;
        let rpcClient = null;
        let currentFile = null;
        let currentPassword = null;
        let processedChunks = [];
        let kaspaMetadata = null;
        let directoryMetadata = null; // ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªå°‚ç”¨å¤‰æ•°
        let wsMonitorActive = false;
        let monitoredTransactions = new Map();
        let uploadHistory = [];
        let systemLogs = [];
        let privateKey = null;
        let address = null;
        let progressManager = null;
        let wsConnection = null;
        let wsConnected = false;
        let wsReconnectInterval = null;
        let workspaceHandle = null; // File System Access API directory handle
        let progressFileMap = new Map(); // Map of filename -> {cid, fileHandle}
        let historyManager = null; // Upload history manager
        let wsMonitorTimeout = null; // WebSocket monitoring timeout
        let uploadingChunksCount = 0; // Number of chunks being uploaded
        let uploadingMetaTx = false; // Whether meta-tx is being uploaded
        let uploadingDirMeta = false; // Whether directory meta is being uploaded
        let isUploadingFile = false; // Overall file upload status (v3.6.3 fix)
        
        // Parallel download settings (v3.6.2)
        let parallelDownloadEnabled = false; // Default OFF for v3.5.0 compatibility
        
        // Load parallel download setting from localStorage
        function loadParallelSetting() {
            const saved = localStorage.getItem('kaspaParallelDownload');
            if (saved !== null) {
                parallelDownloadEnabled = saved === 'true';
                const toggle = document.getElementById('parallelDownloadToggle');
                if (toggle) {
                    toggle.checked = parallelDownloadEnabled;
                }
            }
        }
        
        // Upload History Manager Class
        class UploadHistoryManager {
            constructor() {
                this.dbName = 'kaspa-upload-history';
                this.fileName = 'kaspa-uploads.kenv';
                this.maxSize = 100 * 1024 * 1024; // 100MB
                this.archiveSize = 10 * 1024 * 1024; // 10MB chunks
                this.encryptionKey = null;
                this.loadedHistory = []; // In-memory history storage
                log('[UploadHistoryManager] ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’åˆæœŸåŒ–ã—ã¾ã—ãŸ', 'debug');
            }
            
            async initialize(privateKey) {
                log('[UploadHistoryManager] åˆæœŸåŒ–ã‚’é–‹å§‹ã—ã¾ã™', 'debug');
                try {
                    // Derive encryption key from private key
                    const keyData = new TextEncoder().encode(privateKey);
                    const hashBuffer = await crypto.subtle.digest('SHA-256', keyData);
                    this.encryptionKey = await crypto.subtle.importKey(
                        'raw',
                        hashBuffer,
                        { name: 'AES-GCM', length: 256 },
                        false,
                        ['encrypt', 'decrypt']
                    );
                    log('[UploadHistoryManager] æš—å·åŒ–ã‚­ãƒ¼ã‚’åˆæœŸåŒ–ã—ã¾ã—ãŸ', 'success');
                    
                    // Load existing history from workspace
                    if (window.workspaceHandle) {
                        log('[UploadHistoryManager] ãƒ¯ãƒ¼ã‚¯ã‚¹ãƒšãƒ¼ã‚¹ãƒãƒ³ãƒ‰ãƒ«ãŒå­˜åœ¨ã—ã¾ã™ã€‚å±¥æ­´ã®èª­ã¿è¾¼ã¿ã‚’é–‹å§‹ã—ã¾ã™', 'debug');
                        await this.loadFromFile();
                    } else {
                        log('[UploadHistoryManager] ãƒ¯ãƒ¼ã‚¯ã‚¹ãƒšãƒ¼ã‚¹ãƒãƒ³ãƒ‰ãƒ«ãŒå­˜åœ¨ã—ã¾ã›ã‚“', 'info');
                    }
                } catch (error) {
                    log(`[UploadHistoryManager] åˆæœŸåŒ–ã‚¨ãƒ©ãƒ¼: ${error.message}`, 'error');
                    throw error;
                }
            }
            
            async loadFromFile() {
                log(`[UploadHistoryManager] .kenvãƒ•ã‚¡ã‚¤ãƒ«ã€Œ${this.fileName}ã€ã®èª­ã¿è¾¼ã¿ã‚’é–‹å§‹ã—ã¾ã™`, 'debug');
                try {
                    const fileHandle = await window.workspaceHandle.getFileHandle(this.fileName);
                    log('[UploadHistoryManager] .kenvãƒ•ã‚¡ã‚¤ãƒ«ãŒè¦‹ã¤ã‹ã‚Šã¾ã—ãŸ', 'success');
                    
                    const file = await fileHandle.getFile();
                    const fileSize = file.size;
                    log(`[UploadHistoryManager] ãƒ•ã‚¡ã‚¤ãƒ«ã‚µã‚¤ã‚º: ${fileSize} bytes`, 'debug');
                    
                    const encryptedData = await file.text();
                    const data = JSON.parse(encryptedData);
                    log(`[UploadHistoryManager] ãƒ•ã‚¡ã‚¤ãƒ«ã®ãƒãƒ¼ã‚¸ãƒ§ãƒ³: ${data.version}ã€æš—å·åŒ–: ${data.encrypted}`, 'debug');
                    
                    if (data.encrypted) {
                        const decrypted = await this.decrypt(data.data);
                        const kenv = JSON.parse(decrypted);
                        log(`[UploadHistoryManager] å¾©å·åŒ–æˆåŠŸã€‚å±¥æ­´æ•°: ${kenv.uploads?.length || 0}ä»¶`, 'debug');
                        
                        // v4.2.8: Migrate to version 2.0 if needed
                        if (kenv.version === "1.0") {
                            log('[UploadHistoryManager] v1.0ã®ãƒ‡ãƒ¼ã‚¿ã‚’æ¤œå‡ºã€‚v2.0ã¸ã®ç§»è¡Œã‚’é–‹å§‹ã—ã¾ã™', 'info');
                            kenv = this.migrateV1ToV2(kenv);
                        }
                        
                        // v4.2.7: ãƒ‡ãƒ¼ã‚¿æ§‹é€ ã®ä¿®æ­£ - metaTxIdãŒã€ŒTxID:BlockIDã€å½¢å¼ã®å ´åˆã¯åˆ†é›¢
                        if (kenv.uploads) {
                            kenv.uploads = kenv.uploads.map(item => {
                                if (item.metaTxId && item.metaTxId.includes(':')) {
                                    const parts = item.metaTxId.split(':');
                                    item.metaTxId = parts[0];
                                    item.metaTxBlockId = parts[1];
                                    log(`[UploadHistoryManager] metaTxIdã‚’ä¿®æ­£ã—ã¾ã—ãŸ: ${item.fileName}`, 'debug');
                                }
                                return item;
                            });
                        }
                        
                        // Load into memory only (not localStorage)
                        this.loadedHistory = kenv.uploads || [];
                        this.updateHistoryUI();
                        log(`å±¥æ­´ã‚’èª­ã¿è¾¼ã¿ã¾ã—ãŸ: ${this.loadedHistory.length}ä»¶`, 'success');
                    } else {
                        log('[UploadHistoryManager] ãƒ•ã‚¡ã‚¤ãƒ«ãŒæš—å·åŒ–ã•ã‚Œã¦ã„ã¾ã›ã‚“', 'error');
                    }
                } catch (error) {
                    // File doesn't exist or error reading
                    if (error.name === 'NotFoundError') {
                        log(`[UploadHistoryManager] .kenvãƒ•ã‚¡ã‚¤ãƒ«ã€Œ${this.fileName}ã€ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“`, 'info');
                    } else {
                        log(`[UploadHistoryManager] ãƒ•ã‚¡ã‚¤ãƒ«èª­ã¿è¾¼ã¿ã‚¨ãƒ©ãƒ¼: ${error.name} - ${error.message}`, 'error');
                    }
                }
            }
            
            async saveToFile() {
                if (!window.workspaceHandle) {
                    log('[UploadHistoryManager] ãƒ¯ãƒ¼ã‚¯ã‚¹ãƒšãƒ¼ã‚¹ãƒãƒ³ãƒ‰ãƒ«ãŒãªã„ãŸã‚ä¿å­˜ã‚’ã‚¹ã‚­ãƒƒãƒ—ã—ã¾ã™', 'debug');
                    return;
                }
                
                log('[UploadHistoryManager] å±¥æ­´ã®ä¿å­˜ã‚’é–‹å§‹ã—ã¾ã™', 'debug');
                try {
                    const history = this.getHistory();
                    const stats = this.calculateStats();
                    log(`[UploadHistoryManager] ä¿å­˜ã™ã‚‹å±¥æ­´æ•°: ${history.length}ä»¶`, 'debug');
                    
                    const kenv = {
                        version: "2.0",
                        schemaVersion: 2,
                        wallet: address?.toString() || '',
                        created: new Date().toISOString(),
                        lastModified: new Date().toISOString(),
                        uploads: history,
                        stats: stats
                    };
                    
                    // Check size and archive if needed
                    const size = new Blob([JSON.stringify(kenv)]).size;
                    log(`[UploadHistoryManager] ãƒ•ã‚¡ã‚¤ãƒ«ã‚µã‚¤ã‚ºãƒã‚§ãƒƒã‚¯: ${size} bytes (æœ€å¤§: ${this.maxSize} bytes)`, 'debug');
                    if (size > this.maxSize) {
                        log('[UploadHistoryManager] ãƒ•ã‚¡ã‚¤ãƒ«ã‚µã‚¤ã‚ºãŒä¸Šé™ã‚’è¶…ãˆã¾ã—ãŸã€‚ã‚¢ãƒ¼ã‚«ã‚¤ãƒ–ã‚’é–‹å§‹ã—ã¾ã™', 'info');
                        await this.archiveOldEntries();
                    }
                    
                    // Encrypt and save
                    log('[UploadHistoryManager] ãƒ‡ãƒ¼ã‚¿ã®æš—å·åŒ–ã‚’é–‹å§‹ã—ã¾ã™', 'debug');
                    const encrypted = await this.encrypt(JSON.stringify(kenv));
                    const data = {
                        encrypted: true,
                        version: "1.0",
                        data: encrypted
                    };
                    
                    const fileHandle = await window.workspaceHandle.getFileHandle(this.fileName, { create: true });
                    if (fileHandle) {
                        log(`[UploadHistoryManager] .kenvãƒ•ã‚¡ã‚¤ãƒ«ã€Œ${this.fileName}ã€ã‚’ä½œæˆ/æ›´æ–°ã—ã¾ã™`, 'debug');
                    }
                    const writable = await fileHandle.createWritable();
                    await writable.write(JSON.stringify(data, null, 2));
                    await writable.close();
                    
                    log('.kenvãƒ•ã‚¡ã‚¤ãƒ«ã‚’ä¿å­˜ã—ã¾ã—ãŸ', 'success');
                } catch (error) {
                    log(`[UploadHistoryManager] å±¥æ­´ä¿å­˜ã‚¨ãƒ©ãƒ¼: ${error.name} - ${error.message}`, 'error');
                }
            }
            
            async encrypt(text) {
                log(`[UploadHistoryManager] æš—å·åŒ–ã‚’é–‹å§‹ã—ã¾ã™ (ãƒ‡ãƒ¼ã‚¿ã‚µã‚¤ã‚º: ${text.length} æ–‡å­—)`, 'debug');
                try {
                    const encoder = new TextEncoder();
                    const data = encoder.encode(text);
                    const iv = crypto.getRandomValues(new Uint8Array(12));
                    
                    const encrypted = await crypto.subtle.encrypt(
                        { name: 'AES-GCM', iv: iv },
                        this.encryptionKey,
                        data
                    );
                    
                    // Combine iv and encrypted data
                    const combined = new Uint8Array(iv.length + encrypted.byteLength);
                    combined.set(iv, 0);
                    combined.set(new Uint8Array(encrypted), iv.length);
                    
                    const result = btoa(String.fromCharCode(...combined));
                    log(`[UploadHistoryManager] æš—å·åŒ–å®Œäº† (çµæœã‚µã‚¤ã‚º: ${result.length} æ–‡å­—)`, 'debug');
                    return result;
                } catch (error) {
                    log(`[UploadHistoryManager] æš—å·åŒ–ã‚¨ãƒ©ãƒ¼: ${error.message}`, 'error');
                    throw error;
                }
            }
            
            async decrypt(base64) {
                log(`[UploadHistoryManager] å¾©å·åŒ–ã‚’é–‹å§‹ã—ã¾ã™ (ãƒ‡ãƒ¼ã‚¿ã‚µã‚¤ã‚º: ${base64.length} æ–‡å­—)`, 'debug');
                try {
                    const combined = Uint8Array.from(atob(base64), c => c.charCodeAt(0));
                    const iv = combined.slice(0, 12);
                    const encrypted = combined.slice(12);
                    
                    const decrypted = await crypto.subtle.decrypt(
                        { name: 'AES-GCM', iv: iv },
                        this.encryptionKey,
                        encrypted
                    );
                    
                    const result = new TextDecoder().decode(decrypted);
                    log(`[UploadHistoryManager] å¾©å·åŒ–å®Œäº† (çµæœã‚µã‚¤ã‚º: ${result.length} æ–‡å­—)`, 'debug');
                    return result;
                } catch (error) {
                    log(`[UploadHistoryManager] å¾©å·åŒ–ã‚¨ãƒ©ãƒ¼: ${error.message}`, 'error');
                    throw error;
                }
            }
            
            async addUpload(uploadData) {
                log(`[UploadHistoryManager] æ–°ã—ã„ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ã‚¨ãƒ³ãƒˆãƒªã‚’è¿½åŠ ã—ã¾ã™: ${uploadData.fileName}`, 'debug');
                try {
                    const history = this.getHistory();
                    const beforeCount = history.length;
                    history.unshift(uploadData); // Add to beginning
                    this.loadedHistory = history; // Update in-memory history
                    log(`[UploadHistoryManager] å±¥æ­´ã«è¿½åŠ ã—ã¾ã—ãŸ (${beforeCount} â†’ ${history.length}ä»¶)`, 'success');
                    
                    await this.saveToFile();
                    this.updateUI();
                } catch (error) {
                    log(`[UploadHistoryManager] ã‚¨ãƒ³ãƒˆãƒªè¿½åŠ ã‚¨ãƒ©ãƒ¼: ${error.message}`, 'error');
                }
            }
            
            getHistory() {
                // v4.3.0: LocalStorageã¯ä½¿ç”¨ã›ãšã€.kenvãƒ•ã‚¡ã‚¤ãƒ«ã®ã¿ã‚’å‚ç…§
                if (!this.loadedHistory) {
                    this.loadedHistory = [];
                    log('[UploadHistoryManager] å±¥æ­´æœªèª­ã¿è¾¼ã¿ã€‚ä½œæ¥­ãƒ•ã‚©ãƒ«ãƒ€ã‚’è¨­å®šã—ã¦.kenvãƒ•ã‚¡ã‚¤ãƒ«ã‚’èª­ã¿è¾¼ã‚“ã§ãã ã•ã„', 'debug');
                }
                log(`[UploadHistoryManager] å±¥æ­´ã‚’å–å¾—ã—ã¾ã—ãŸ: ${this.loadedHistory.length}ä»¶`, 'debug');
                return this.loadedHistory;
            }
            
            calculateStats() {
                const history = this.getHistory();
                const stats = {
                    totalUploads: history.length,
                    totalSize: history.reduce((sum, item) => sum + (item.fileSize || 0), 0),
                    totalCost: history.reduce((sum, item) => sum + (item.totalCost || 0), 0)
                };
                log(`[UploadHistoryManager] çµ±è¨ˆæƒ…å ±: ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰${stats.totalUploads}ä»¶ã€ç·ã‚µã‚¤ã‚º${stats.totalSize}bytesã€ç·ã‚³ã‚¹ãƒˆ${stats.totalCost}KAS`, 'debug');
                return stats;
            }
            
            updateUI() {
                log('[UploadHistoryManager] UIã‚’æ›´æ–°ã—ã¾ã™', 'debug');
                const stats = this.calculateStats();
                
                // Update stats
                const totalUploads = document.getElementById('totalUploads');
                const totalSize = document.getElementById('totalSize');
                const totalCost = document.getElementById('totalCost');
                
                if (totalUploads) totalUploads.textContent = stats.totalUploads;
                if (totalSize) totalSize.textContent = formatSize(stats.totalSize);
                if (totalCost) totalCost.textContent = stats.totalCost.toFixed(5);
                
                // Update history list
                const historyList = document.getElementById('historyList');
                if (!historyList) {
                    log('[UploadHistoryManager] historyListè¦ç´ ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“', 'debug');
                    return;
                }
                
                const history = this.getHistory();
                historyList.innerHTML = history.length === 0 ? 
                    '<p style="text-align: center; color: #666;">ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰å±¥æ­´ãŒã‚ã‚Šã¾ã›ã‚“</p>' :
                    history.map(item => this.createHistoryItem(item)).join('');
                log(`[UploadHistoryManager] å±¥æ­´ãƒªã‚¹ãƒˆã‚’æ›´æ–°ã—ã¾ã—ãŸ (${history.length}ä»¶)`, 'debug');
                
                // Attach event listeners to the newly created buttons
                this.attachEventListeners();
            }
            
            attachEventListeners() {
                // Remove any existing listeners first
                const existingButtons = document.querySelectorAll('.history-action-btn');
                existingButtons.forEach(btn => {
                    const newBtn = btn.cloneNode(true);
                    btn.parentNode.replaceChild(newBtn, btn);
                });
                
                // Add event listeners to all history action buttons
                document.querySelectorAll('.history-action-btn').forEach(button => {
                    button.addEventListener('click', async (e) => {
                        // Skip if button is disabled
                        if (e.target.disabled || e.target.classList.contains('disabled')) {
                            log('[UploadHistoryManager] ç„¡åŠ¹åŒ–ã•ã‚ŒãŸãƒœã‚¿ãƒ³ãŒã‚¯ãƒªãƒƒã‚¯ã•ã‚Œã¾ã—ãŸ', 'warning');
                            e.preventDefault();
                            e.stopPropagation();
                            return;
                        }
                        
                        const action = e.target.dataset.action;
                        const itemId = e.target.dataset.itemId;
                        
                        // Handle the action
                        switch(action) {
                            case 'generateKaspaWithPassword':
                                await this.generateKaspaWithPassword(itemId);
                                break;
                            case 'generateKaspaWithoutPassword':
                                await this.generateKaspaWithoutPassword(itemId);
                                break;
                            case 'copyMetaTxIdWithPassword':
                                await this.copyMetaTxIdWithPassword(itemId);
                                break;
                            case 'copyMetaTxIdWithoutPassword':
                                await this.copyMetaTxIdWithoutPassword(itemId);
                                break;
                            case 'copyPassword':
                                const password = e.target.dataset.password;
                                await window.copyToClipboard(password);
                                break;
                            default:
                                log(`[UploadHistoryManager] ä¸æ˜ãªã‚¢ã‚¯ã‚·ãƒ§ãƒ³: ${action}`, 'error');
                        }
                    });
                });
                
                log(`[UploadHistoryManager] ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼ã‚’è¨­å®šã—ã¾ã—ãŸ`, 'debug');
            }
            
            createHistoryItem(item) {
                // Use blockchain time if available, otherwise fall back to upload date
                const dateToUse = item.blockTime || item.uploadDate;
                const date = new Date(dateToUse).toLocaleString('ja-JP');
                
                // Check if this is a directory
                const isDirectory = item.type === 'directory';
                const displayName = isDirectory ? item.name : item.fileName;
                const displaySize = isDirectory 
                    ? `${item.fileCount} ãƒ•ã‚¡ã‚¤ãƒ« (${formatSize(item.totalSize)})`
                    : formatSize(item.fileSize);
                const icon = isDirectory ? 'ğŸ“‚' : 'ğŸ“„';
                
                log(`[DEBUG] å±¥æ­´ã‚¢ã‚¤ãƒ†ãƒ è¡¨ç¤º - ${isDirectory ? 'ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒª' : 'ãƒ•ã‚¡ã‚¤ãƒ«'}: ${displayName}, æ—¥æ™‚: ${date} (blockTime: ${item.blockTime ? 'ã‚ã‚Š' : 'ãªã—'})`, 'debug');
                
                const hasPassword = item.password && item.password !== 'ãªã—';
                // å¾Œæ–¹äº’æ›æ€§ã‚’ä¿ã¡ãªãŒã‚‰ã€æ–°æ—§ä¸¡æ–¹ã®ãƒ‡ãƒ¼ã‚¿å½¢å¼ã‚’ã‚µãƒãƒ¼ãƒˆ
            // TxIDãŒã‚ã‚Œã°ãƒœã‚¿ãƒ³ã‚’æœ‰åŠ¹åŒ–ï¼ˆBlockIDã¯ã‚ªãƒ—ã‚·ãƒ§ãƒ³ï¼‰
            const hasMetaTxId = item.metaTxId || (item.metaTxReference && item.metaTxReference.includes(':'));
                
                // Generate buttons based on available data
                const buttons = [];
                
                // .kaspa buttons
                if (hasPassword) {
                    buttons.push(`<button class="small-button history-action-btn" data-action="generateKaspaWithPassword" data-item-id="${item.id}" title="ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ä»˜ã.kaspaãƒ•ã‚¡ã‚¤ãƒ«">ğŸ”.kaspa</button>`);
                } else {
                    buttons.push(`<button class="small-button disabled" disabled title="ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ãŒä¿å­˜ã•ã‚Œã¦ã„ã¾ã›ã‚“" style="opacity: 0.5; cursor: not-allowed;">ğŸ”.kaspa</button>`);
                }
                buttons.push(`<button class="small-button history-action-btn" data-action="generateKaspaWithoutPassword" data-item-id="${item.id}" title="ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ãªã—.kaspaãƒ•ã‚¡ã‚¤ãƒ«">ğŸ”“.kaspa</button>`);
                
                // TxID buttons
                if (hasMetaTxId) {
                    if (hasPassword) {
                        buttons.push(`<button class="small-button history-action-btn" data-action="copyMetaTxIdWithPassword" data-item-id="${item.id}" title="TxID:BlockID:Passwordå½¢å¼ã§ã‚³ãƒ”ãƒ¼">ğŸ”TxID</button>`);
                    } else {
                        buttons.push(`<button class="small-button disabled" disabled title="ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ãŒä¿å­˜ã•ã‚Œã¦ã„ã¾ã›ã‚“" style="opacity: 0.5; cursor: not-allowed;">ğŸ”TxID</button>`);
                    }
                    buttons.push(`<button class="small-button history-action-btn" data-action="copyMetaTxIdWithoutPassword" data-item-id="${item.id}" title="TxID:BlockIDå½¢å¼ã§ã‚³ãƒ”ãƒ¼">ğŸ”“TxID</button>`);
                } else {
                    buttons.push(`<button class="small-button disabled" disabled title="ãƒ¡ã‚¿ãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³IDãŒå­˜åœ¨ã—ã¾ã›ã‚“" style="opacity: 0.5; cursor: not-allowed;">ğŸ”TxID</button>`);
                    buttons.push(`<button class="small-button disabled" disabled title="ãƒ¡ã‚¿ãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³IDãŒå­˜åœ¨ã—ã¾ã›ã‚“" style="opacity: 0.5; cursor: not-allowed;">ğŸ”“TxID</button>`);
                }
                
                // Password button
                if (hasPassword) {
                    buttons.push(`<button class="small-button history-action-btn" data-action="copyPassword" data-item-id="${item.id}" data-password="${item.password}" title="ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ã‚’ã‚³ãƒ”ãƒ¼">ğŸ”‘Pass</button>`);
                } else {
                    buttons.push(`<button class="small-button disabled" disabled title="ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ãŒä¿å­˜ã•ã‚Œã¦ã„ã¾ã›ã‚“" style="opacity: 0.5; cursor: not-allowed;">ğŸ”‘Pass</button>`);
                }
                
                return `
                    <div class="history-item">
                        <div class="history-item-header">
                            <div>
                                <strong>${icon} ${displayName}</strong>
                                <span style="color: #666; font-size: 12px; margin-left: 10px;">${displaySize}</span>
                            </div>
                            <div class="history-item-actions">
                                ${buttons.join('\n                                ')}
                            </div>
                        </div>
                        <div style="font-size: 12px; color: #999;">
                            <div>æ—¥æ™‚: ${date}</div>
                            <div>${isDirectory ? `ãƒ•ã‚¡ã‚¤ãƒ«æ•°: ${item.fileCount}` : `ãƒãƒ£ãƒ³ã‚¯: ${item.chunks}`} | ã‚³ã‚¹ãƒˆ: ${item.totalCost?.toFixed(5) || 0} KAS</div>
                            ${item.metaTxId ? `<div>MetaTxID: ${item.metaTxId.substring(0, 16)}...</div>` : ''}
                            ${isDirectory && item.failedCount > 0 ? `<div style="color: #e94560;">ã‚¨ãƒ©ãƒ¼: ${item.failedCount} ãƒ•ã‚¡ã‚¤ãƒ«</div>` : ''}
                        </div>
                    </div>
                `;
            }
            
            async generateKaspaWithPassword(uploadId) {
                log(`[UploadHistoryManager] ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ä»˜ã.kaspaãƒ•ã‚¡ã‚¤ãƒ«ã®ç”Ÿæˆã‚’é–‹å§‹ã—ã¾ã™ (ID: ${uploadId})`, 'debug');
                const history = this.getHistory();
                const item = history.find(h => h.id === uploadId);
                if (!item) {
                    log(`[UploadHistoryManager] æŒ‡å®šã•ã‚ŒãŸIDã®å±¥æ­´ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“: ${uploadId}`, 'error');
                    return;
                }
                
                if (!item.password) {
                    log('ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ãŒä¿å­˜ã•ã‚Œã¦ã„ã¾ã›ã‚“', 'warning');
                    alert('ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ãŒä¿å­˜ã•ã‚Œã¦ã„ã¾ã›ã‚“ã€‚éµãªã—.kaspaã‚’ã”åˆ©ç”¨ãã ã•ã„ã€‚');
                    return;
                }
                
                await this.generateKaspa(uploadId, true);
            }
            
            async generateKaspaWithoutPassword(uploadId) {
                log(`[UploadHistoryManager] ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ãªã—.kaspaãƒ•ã‚¡ã‚¤ãƒ«ã®ç”Ÿæˆã‚’é–‹å§‹ã—ã¾ã™ (ID: ${uploadId})`, 'debug');
                await this.generateKaspa(uploadId, false);
            }
            
            async copyMetaTxIdWithPassword(uploadId) {
                log(`[UploadHistoryManager] ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ä»˜ãTxIDã®ã‚³ãƒ”ãƒ¼ã‚’é–‹å§‹ã—ã¾ã™ (ID: ${uploadId})`, 'debug');
                const history = this.getHistory();
                const item = history.find(h => h.id === uploadId);
                if (!item) {
                    log(`[UploadHistoryManager] æŒ‡å®šã•ã‚ŒãŸIDã®å±¥æ­´ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“: ${uploadId}`, 'error');
                    return;
                }
                
                // æ–°æ—§ä¸¡æ–¹ã®ãƒ‡ãƒ¼ã‚¿å½¢å¼ã‚’ã‚µãƒãƒ¼ãƒˆ
                let txId, blockId;
                if (item.metaTxId) {
                    // æ–°å½¢å¼
                    // metaTxIdãŒèª¤ã£ã¦ã€ŒTxID:BlockIDã€å½¢å¼ã§ä¿å­˜ã•ã‚Œã¦ã„ã‚‹å ´åˆã®å¯¾å‡¦
                    if (item.metaTxId.includes(':')) {
                        const parts = item.metaTxId.split(':');
                        txId = parts[0];
                        blockId = parts[1];
                    } else {
                        txId = item.metaTxId;
                        blockId = item.metaTxBlockId || '';
                    }
                } else if (item.metaTxReference && item.metaTxReference.includes(':')) {
                    // æ—§å½¢å¼
                    const parts = item.metaTxReference.split(':');
                    txId = parts[0];
                    blockId = parts[1];
                } else if (item.firstChunkTxId) {
                    // ãƒ¡ã‚¿TxãŒãªã„å ´åˆã¯æœ€åˆã®ãƒãƒ£ãƒ³ã‚¯TxIDã‚’ä½¿ç”¨
                    txId = item.firstChunkTxId;
                    blockId = item.chunkBlockIds?.[0] || '';
                } else {
                    log('ãƒ¡ã‚¿ãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³IDãŒå­˜åœ¨ã—ã¾ã›ã‚“', 'warning');
                    alert('ãƒ¡ã‚¿ãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³IDãŒå­˜åœ¨ã—ã¾ã›ã‚“');
                    return;
                }
                
                if (!item.password) {
                    log('ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ãŒä¿å­˜ã•ã‚Œã¦ã„ã¾ã›ã‚“', 'warning');
                    alert('ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ãŒä¿å­˜ã•ã‚Œã¦ã„ã¾ã›ã‚“ã€‚éµãªã—TxIDã‚’ã”åˆ©ç”¨ãã ã•ã„ã€‚');
                    return;
                }
                
                const textToCopy = blockId ? `${txId}:${blockId}:${item.password}` : `${txId}::${item.password}`;
                await window.copyToClipboard(textToCopy);
                log('ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ä»˜ãTxIDã‚’ã‚³ãƒ”ãƒ¼ã—ã¾ã—ãŸï¼ˆãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ãŒå«ã¾ã‚Œã¦ã„ã¾ã™ï¼‰', 'warning');
            }
            
            async copyMetaTxIdWithoutPassword(uploadId) {
                log(`[UploadHistoryManager] ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ãªã—TxIDã®ã‚³ãƒ”ãƒ¼ã‚’é–‹å§‹ã—ã¾ã™ (ID: ${uploadId})`, 'debug');
                const history = this.getHistory();
                const item = history.find(h => h.id === uploadId);
                if (!item) {
                    log(`[UploadHistoryManager] æŒ‡å®šã•ã‚ŒãŸIDã®å±¥æ­´ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“: ${uploadId}`, 'error');
                    return;
                }
                
                // æ–°æ—§ä¸¡æ–¹ã®ãƒ‡ãƒ¼ã‚¿å½¢å¼ã‚’ã‚µãƒãƒ¼ãƒˆ
                let txId, blockId;
                if (item.metaTxId) {
                    // æ–°å½¢å¼
                    // metaTxIdãŒèª¤ã£ã¦ã€ŒTxID:BlockIDã€å½¢å¼ã§ä¿å­˜ã•ã‚Œã¦ã„ã‚‹å ´åˆã®å¯¾å‡¦
                    if (item.metaTxId.includes(':')) {
                        const parts = item.metaTxId.split(':');
                        txId = parts[0];
                        blockId = parts[1];
                    } else {
                        txId = item.metaTxId;
                        blockId = item.metaTxBlockId || '';
                    }
                } else if (item.metaTxReference && item.metaTxReference.includes(':')) {
                    // æ—§å½¢å¼
                    const parts = item.metaTxReference.split(':');
                    txId = parts[0];
                    blockId = parts[1];
                } else if (item.firstChunkTxId) {
                    // ãƒ¡ã‚¿TxãŒãªã„å ´åˆã¯æœ€åˆã®ãƒãƒ£ãƒ³ã‚¯TxIDã‚’ä½¿ç”¨
                    txId = item.firstChunkTxId;
                    blockId = item.chunkBlockIds?.[0] || '';
                } else {
                    log('ãƒ¡ã‚¿ãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³IDãŒå­˜åœ¨ã—ã¾ã›ã‚“', 'warning');
                    alert('ãƒ¡ã‚¿ãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³IDãŒå­˜åœ¨ã—ã¾ã›ã‚“');
                    return;
                }
                
                const textToCopy = blockId ? `${txId}:${blockId}` : txId;
                await window.copyToClipboard(textToCopy);
                log(blockId ? 'TxID:BlockIDå½¢å¼ã§ã‚³ãƒ”ãƒ¼ã—ã¾ã—ãŸ' : 'TxIDã‚’ã‚³ãƒ”ãƒ¼ã—ã¾ã—ãŸ', 'success');
            }
            
            async generateKaspa(uploadId, includePassword) {
                log(`[UploadHistoryManager] .kaspaãƒ•ã‚¡ã‚¤ãƒ«ã®ç”Ÿæˆã‚’é–‹å§‹ã—ã¾ã™ (ID: ${uploadId}, ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰å«ã‚€: ${includePassword})`, 'debug');
                const history = this.getHistory();
                const item = history.find(h => h.id === uploadId);
                if (!item) {
                    log(`[UploadHistoryManager] æŒ‡å®šã•ã‚ŒãŸIDã®å±¥æ­´ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“: ${uploadId}`, 'error');
                    return;
                }
                
                // Check if this is a directory
                const isDirectory = item.type === 'directory';
                const displayName = isDirectory ? item.name : item.fileName;
                
                log(`[UploadHistoryManager] å±¥æ­´é …ç›®ãŒè¦‹ã¤ã‹ã‚Šã¾ã—ãŸ: ${displayName} (ã‚¿ã‚¤ãƒ—: ${isDirectory ? 'ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒª' : 'ãƒ•ã‚¡ã‚¤ãƒ«'})`, 'debug');
                
                if (isDirectory) {
                    // Generate directory .kaspa file
                    const dirMetadata = item.metadata || await createDirectoryMetadata(item.name, item.entries, item.password);
                    
                    // Update auth section based on password inclusion
                    if (includePassword && item.password) {
                        dirMetadata.auth = {
                            passwordIncluded: true,
                            password: item.password,
                            warning: "ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ã¯å¹³æ–‡ã§ä¿å­˜ã•ã‚Œã¦ã„ã¾ã™ã€‚ä¿¡é ¼ã§ãã‚‹ç›¸æ‰‹ã¨ã®ã¿å…±æœ‰ã—ã¦ãã ã•ã„ã€‚"
                        };
                    } else {
                        dirMetadata.auth = {
                            passwordIncluded: false,
                            password: null,
                            warning: null
                        };
                    }
                    
                    // Update metadata section with blockchain info if available
                    if (item.metaTxId) {
                        dirMetadata.metadata.metaTxId = item.metaTxId;
                        dirMetadata.metadata.metaTxBlockId = item.metaTxBlockId;
                        dirMetadata.metadata.blockTime = item.blockTime;
                    }
                    
                    // Create and download .kaspa file
                    const cid = item.cid || generateRandomCID();
                    const filename = `${item.name}.${cid}.kaspa`;
                    const blob = new Blob([JSON.stringify(dirMetadata, null, 2)], { type: 'application/octet-stream' });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = filename;
                    a.click();
                    URL.revokeObjectURL(url);
                    
                    const typeStr = includePassword ? 'ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ä»˜ã' : 'ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ãªã—';
                    log(`${typeStr}ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒª.kaspaãƒ•ã‚¡ã‚¤ãƒ«ã‚’ç”Ÿæˆã—ã¾ã—ãŸ: ${filename}`, 'success');
                    return;
                }
                
                // ãƒ‡ãƒ¼ã‚¿æ§‹é€ ã®ä¿®æ­£: metaTxIdãŒã€ŒTxID:BlockIDã€å½¢å¼ã®å ´åˆã¯åˆ†é›¢
                let metaTxId = item.metaTxId;
                let metaTxBlockId = item.metaTxBlockId;
                if (metaTxId && metaTxId.includes(':')) {
                    const parts = metaTxId.split(':');
                    metaTxId = parts[0];
                    metaTxBlockId = parts[1];
                }
                
                // Create .kaspa metadata from history for files with unified structure
                const kaspaMetadata = {
                    type: 'kaspa-file',
                    version: "3.3",  // v4.7.50: Updated to Format v3.3
                    created: item.uploadDate,
                    network: item.network || 'testnet-10',
                    
                    // Encryption at top level
                    encryption: {
                        algorithm: "AES-256-GCM",
                        pbkdf2: {
                            salt: item.encryption?.salt || item.salt || "",
                            iterations: item.encryption?.iterations || 100000
                        }
                    },
                    
                    // File information
                    file: {
                        name: item.fileName,
                        size: item.fileSize,
                        mimeType: item.metadata?.file?.mimeType || 'application/octet-stream',
                        sha256: item.fileSha256 || item.metadata?.file?.sha256 || "",
                        encrypted: true,
                        compression: item.compression || {
                            algorithm: "none",
                            enabled: false,
                            originalSize: item.fileSize,
                            compressedSize: item.fileSize,
                            // v4.7.58: variableChunkãƒ•ãƒ©ã‚°ã‚’è¿½åŠ 
                            variableChunk: item.metadata?.file?.compression?.variableChunk || false
                        }
                    },
                    
                    // Chunk information
                    chunks: item.chunkTxIds || [],
                    chunkBlockIds: item.chunkBlockIds || [],
                    
                    // Recovery information
                    recovery: {
                        totalChunks: item.chunks,
                        chunkSize: item.chunkSize || 12288,
                        checksum: item.fileSha256 || "",
                        uploadCost: item.totalCost
                    },
                    
                    // Metadata
                    metadata: {
                        metaTxId: metaTxId,
                        metaTxBlockId: metaTxBlockId,
                        uploadDate: item.uploadDate,
                        blockTime: item.blockTime || item.uploadDate,
                        // v4.7.58: chunkBoundariesã¨payloadSplitãƒ•ãƒ©ã‚°ã‚’è¿½åŠ 
                        payloadSplit: item.metadata?.metadata?.payloadSplit || false,
                        chunkBoundaries: item.metadata?.metadata?.chunkBoundaries || undefined
                    }
                };
                
                // Include password if requested and available
                if (includePassword && item.password) {
                    kaspaMetadata.auth = {
                        passwordIncluded: true,
                        password: item.password,
                        warning: "ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ã¯å¹³æ–‡ã§ä¿å­˜ã•ã‚Œã¦ã„ã¾ã™ã€‚ä¿¡é ¼ã§ãã‚‹ç›¸æ‰‹ã¨ã®ã¿å…±æœ‰ã—ã¦ãã ã•ã„ã€‚"
                    };
                    log('ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ã‚’.kaspaãƒ•ã‚¡ã‚¤ãƒ«ã«å«ã‚ã¾ã™', 'info');
                } else {
                    log('ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ãªã—ã®.kaspaãƒ•ã‚¡ã‚¤ãƒ«ã‚’ç”Ÿæˆã—ã¾ã™', 'info');
                }
                
                // Create and download .kaspa file with CID
                const cid = item.cid || generateRandomCID();
                const filename = generateSafeFilename(item.fileName, cid);
                const blob = new Blob([JSON.stringify(kaspaMetadata, null, 2)], { type: 'application/octet-stream' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = filename;
                a.click();
                URL.revokeObjectURL(url);
                
                const typeStr = includePassword ? 'ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ä»˜ã' : 'ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ãªã—';
                log(`${typeStr}.kaspaãƒ•ã‚¡ã‚¤ãƒ«ã‚’ç”Ÿæˆã—ã¾ã—ãŸ: ${filename}`, 'success');
                log(`[DEBUG] .kaspaãƒ•ã‚¡ã‚¤ãƒ«ç”Ÿæˆå®Œäº† - ã‚µã‚¤ã‚º: ${blob.size} bytes`, 'debug');
            }
            
            async exportKenv() {
                log('[UploadHistoryManager] .kenvãƒ•ã‚¡ã‚¤ãƒ«ã®ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆã‚’é–‹å§‹ã—ã¾ã™', 'debug');
                try {
                    await this.saveToFile();
                    
                    // Also trigger download
                    const fileHandle = await window.workspaceHandle.getFileHandle(this.fileName);
                    const file = await fileHandle.getFile();
                    const content = await file.text();
                    log(`[UploadHistoryManager] ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆãƒ•ã‚¡ã‚¤ãƒ«ã‚µã‚¤ã‚º: ${content.length} æ–‡å­—`, 'debug');
                    
                    const blob = new Blob([content], { type: 'application/json' });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = this.fileName;
                    a.click();
                    URL.revokeObjectURL(url);
                    
                    log('.kenvãƒ•ã‚¡ã‚¤ãƒ«ã‚’ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆã—ã¾ã—ãŸ', 'success');
                } catch (error) {
                    log(`[UploadHistoryManager] ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆã‚¨ãƒ©ãƒ¼: ${error.name} - ${error.message}`, 'error');
                }
            }
            
            async importKenv() {
                log('[UploadHistoryManager] .kenvãƒ•ã‚¡ã‚¤ãƒ«ã®ã‚¤ãƒ³ãƒãƒ¼ãƒˆã‚’é–‹å§‹ã—ã¾ã™', 'debug');
                try {
                    const input = document.createElement('input');
                    input.type = 'file';
                    input.accept = '.kenv';
                    
                    input.onchange = async (e) => {
                        const file = e.target.files[0];
                        if (!file) {
                            log('[UploadHistoryManager] ãƒ•ã‚¡ã‚¤ãƒ«ãŒé¸æŠã•ã‚Œã¾ã›ã‚“ã§ã—ãŸ', 'info');
                            return;
                        }
                        
                        log(`[UploadHistoryManager] ã‚¤ãƒ³ãƒãƒ¼ãƒˆãƒ•ã‚¡ã‚¤ãƒ«: ${file.name} (${file.size} bytes)`, 'debug');
                        
                        try {
                            const content = await file.text();
                            const data = JSON.parse(content);
                            log(`[UploadHistoryManager] ãƒ•ã‚¡ã‚¤ãƒ«ãƒãƒ¼ã‚¸ãƒ§ãƒ³: ${data.version}ã€æš—å·åŒ–: ${data.encrypted}`, 'debug');
                            
                            if (data.encrypted && data.data) {
                                const decrypted = await this.decrypt(data.data);
                                const kenv = JSON.parse(decrypted);
                                log(`[UploadHistoryManager] ã‚¤ãƒ³ãƒãƒ¼ãƒˆãƒ‡ãƒ¼ã‚¿: ${kenv.uploads?.length || 0}ä»¶ã®å±¥æ­´`, 'debug');
                                
                                // Merge with existing history
                                const existingHistory = this.getHistory();
                                const beforeCount = existingHistory.length;
                                const newHistory = [...kenv.uploads, ...existingHistory];
                                
                                // Remove duplicates by id
                                const uniqueHistory = newHistory.filter((item, index, self) =>
                                    index === self.findIndex(h => h.id === item.id)
                                );
                                const duplicates = newHistory.length - uniqueHistory.length;
                                if (duplicates > 0) {
                                    log(`[UploadHistoryManager] ${duplicates}ä»¶ã®é‡è¤‡ã‚’é™¤å»ã—ã¾ã—ãŸ`, 'info');
                                }
                                
                                // Update in-memory history only
                                this.loadedHistory = uniqueHistory;
                                await this.saveToFile();
                                this.updateHistoryUI();
                                
                                const addedCount = uniqueHistory.length - beforeCount;
                                log(`${addedCount}ä»¶ã®å±¥æ­´ã‚’ã‚¤ãƒ³ãƒãƒ¼ãƒˆã—ã¾ã—ãŸ (ç·æ•°: ${uniqueHistory.length}ä»¶)`, 'success');
                            } else {
                                log('[UploadHistoryManager] ãƒ•ã‚¡ã‚¤ãƒ«ãŒæš—å·åŒ–ã•ã‚Œã¦ã„ãªã„ã‹ã€ãƒ‡ãƒ¼ã‚¿ãŒç„¡åŠ¹ã§ã™', 'error');
                            }
                        } catch (error) {
                            log(`[UploadHistoryManager] ã‚¤ãƒ³ãƒãƒ¼ãƒˆå‡¦ç†ã‚¨ãƒ©ãƒ¼: ${error.message}`, 'error');
                        }
                    };
                    
                    input.click();
                } catch (error) {
                    log(`[UploadHistoryManager] ã‚¤ãƒ³ãƒãƒ¼ãƒˆã‚¨ãƒ©ãƒ¼: ${error.message}`, 'error');
                }
            }
            
            async archiveOldEntries() {
                log('[UploadHistoryManager] ã‚¢ãƒ¼ã‚«ã‚¤ãƒ–å‡¦ç†ã‚’é–‹å§‹ã—ã¾ã™', 'debug');
                const history = this.getHistory();
                log(`[UploadHistoryManager] ç¾åœ¨ã®å±¥æ­´æ•°: ${history.length}ä»¶`, 'debug');
                
                if (history.length <= 100) {
                    log('[UploadHistoryManager] å±¥æ­´æ•°ãŒ100ä»¶ä»¥ä¸‹ã®ãŸã‚ã‚¢ãƒ¼ã‚«ã‚¤ãƒ–ã¯ä¸è¦ã§ã™', 'debug');
                    return;
                }
                
                // Keep recent 100 entries
                const recentHistory = history.slice(0, 100);
                const archiveHistory = history.slice(100);
                log(`[UploadHistoryManager] ã‚¢ãƒ¼ã‚«ã‚¤ãƒ–å¯¾è±¡: ${archiveHistory.length}ä»¶ã€ä¿æŒ: ${recentHistory.length}ä»¶`, 'info');
                
                // Save archive
                const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
                const archiveName = `kaspa-uploads-archive-${timestamp}.kenv`;
                log(`[UploadHistoryManager] ã‚¢ãƒ¼ã‚«ã‚¤ãƒ–ãƒ•ã‚¡ã‚¤ãƒ«å: ${archiveName}`, 'debug');
                
                try {
                    const archiveData = {
                        version: "1.0",
                        archived: true,
                        uploads: archiveHistory
                    };
                    
                    const encrypted = await this.encrypt(JSON.stringify(archiveData));
                    const data = {
                        encrypted: true,
                        version: "1.0",
                        data: encrypted
                    };
                    
                    const fileHandle = await window.workspaceHandle.getFileHandle(archiveName, { create: true });
                    const writable = await fileHandle.createWritable();
                    await writable.write(JSON.stringify(data, null, 2));
                    await writable.close();
                    log(`[UploadHistoryManager] ã‚¢ãƒ¼ã‚«ã‚¤ãƒ–ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ä½œæˆã—ã¾ã—ãŸ: ${archiveName}`, 'success');
                    
                    // Update in-memory history
                    this.loadedHistory = recentHistory;
                    log(`${archiveHistory.length}ä»¶ã®å¤ã„å±¥æ­´ã‚’ã‚¢ãƒ¼ã‚«ã‚¤ãƒ–ã—ã¾ã—ãŸ`, 'info');
                } catch (error) {
                    log(`[UploadHistoryManager] ã‚¢ãƒ¼ã‚«ã‚¤ãƒ–ã‚¨ãƒ©ãƒ¼: ${error.message}`, 'error');
                    throw error;
                }
            }
            
            updateHistoryUI() {
                log('[UploadHistoryManager] updateHistoryUI ãŒå‘¼ã³å‡ºã•ã‚Œã¾ã—ãŸ', 'debug');
                this.updateUI();
            }
            
            // Migrate v1.0 data to v2.0 format
            migrateV1ToV2(oldKenv) {
                log('[UploadHistoryManager] v1.0ã‹ã‚‰v2.0ã¸ã®ç§»è¡Œã‚’å®Ÿè¡Œã—ã¾ã™', 'info');
                return {
                    version: "2.0",
                    schemaVersion: 2,
                    wallet: oldKenv.wallet,
                    created: oldKenv.created,
                    lastModified: new Date().toISOString(),
                    uploads: oldKenv.uploads.map(item => {
                        // Ensure type field exists
                        if (!item.type) {
                            item.type = item.isDirectory ? 'directory' : 'file';
                        }
                        
                        // Migrate encryption info to new structure if not already present
                        if (!item.encryption && (item.salt || item.metadata?.encryption)) {
                            item.encryption = {
                                algorithm: "AES-256-GCM",
                                salt: item.salt || item.metadata?.encryption?.pbkdf2?.salt || "",
                                iterations: item.metadata?.encryption?.pbkdf2?.iterations || 100000
                            };
                        }
                        
                        return item;
                    }),
                    stats: oldKenv.stats
                };
            }
        }
        
        // DirectoryManager class for Phase 2: Merkle DAG implementation
        class DirectoryManager {
            constructor() {
                this.dbName = 'kaspaDirectories';
                this.dagDbName = 'kaspaDAG';  // DAG node storage
                this.directories = this.loadDirectories();
                this.dagNodes = this.loadDAGNodes();
                this.version = '2.0';
                log('[DirectoryManager] v2.0 Merkle DAGå¯¾å¿œç‰ˆã‚’åˆæœŸåŒ–ã—ã¾ã—ãŸ', 'debug');
            }
            
            loadDAGNodes() {
                try {
                    const stored = localStorage.getItem(this.dagDbName);
                    return stored ? JSON.parse(stored) : {};
                } catch (error) {
                    log('[DirectoryManager] DAGãƒãƒ¼ãƒ‰ã®èª­ã¿è¾¼ã¿ã‚¨ãƒ©ãƒ¼: ' + error.message, 'error');
                    return {};
                }
            }
            
            saveDAGNodes() {
                try {
                    localStorage.setItem(this.dagDbName, JSON.stringify(this.dagNodes));
                } catch (error) {
                    log('[DirectoryManager] DAGãƒãƒ¼ãƒ‰ã®ä¿å­˜ã‚¨ãƒ©ãƒ¼: ' + error.message, 'error');
                }
            }
            
            loadDirectories() {
                try {
                    const stored = localStorage.getItem(this.dbName);
                    return stored ? JSON.parse(stored) : [];
                } catch (error) {
                    log('[DirectoryManager] ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã®èª­ã¿è¾¼ã¿ã‚¨ãƒ©ãƒ¼: ' + error.message, 'error');
                    return [];
                }
            }
            
            saveDirectories() {
                try {
                    localStorage.setItem(this.dbName, JSON.stringify(this.directories));
                } catch (error) {
                    log('[DirectoryManager] ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã®ä¿å­˜ã‚¨ãƒ©ãƒ¼: ' + error.message, 'error');
                }
            }
            
            // Generate CID for any object (like IPFS)
            generateCID(data) {
                const str = JSON.stringify(data);
                const encoder = new TextEncoder();
                const bytes = encoder.encode(str);
                const hashArray = Array.from(crypto.getRandomValues(new Uint8Array(16)));
                // In real implementation, this would be SHA-256 hash
                return 'cid_' + hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
            }
            
            // Create a DAG node
            createDAGNode(type, data, links = []) {
                const node = {
                    type: type,
                    data: data,
                    links: links.map(link => ({
                        name: link.name,
                        cid: link.cid,
                        size: link.size || 0,
                        type: link.type || 'unknown'
                    })),
                    created: new Date().toISOString()
                };
                
                const cid = this.generateCID(node);
                node.cid = cid;
                
                // Calculate total size including linked nodes
                node.size = JSON.stringify(data).length + 
                    links.reduce((sum, link) => sum + (link.size || 0), 0);
                
                this.dagNodes[cid] = node;
                this.saveDAGNodes();
                
                return node;
            }
            
            // Get a DAG node by CID
            getDAGNode(cid) {
                return this.dagNodes[cid] || null;
            }
            
            // Traverse DAG and collect all nodes
            traverseDAG(cid, visited = new Set()) {
                if (visited.has(cid)) return [];
                visited.add(cid);
                
                const node = this.getDAGNode(cid);
                if (!node) return [];
                
                const nodes = [node];
                
                // Recursively traverse linked nodes
                for (const link of node.links) {
                    nodes.push(...this.traverseDAG(link.cid, visited));
                }
                
                return nodes;
            }
            
            // Get directory tree structure
            getDirectoryTree(parentCID = null, level = 0) {
                const dirs = this.directories.filter(d => d.parentCID === parentCID);
                const tree = [];
                
                for (const dir of dirs) {
                    tree.push({
                        ...dir,
                        level: level,
                        children: this.getDirectoryTree(dir.cid, level + 1)
                    });
                }
                
                return tree;
            }
            
            // Get all subdirectories of a directory
            getSubdirectories(dirCID) {
                const subdirs = [];
                const queue = [dirCID];
                
                while (queue.length > 0) {
                    const current = queue.shift();
                    const children = this.directories.filter(d => d.parentCID === current);
                    subdirs.push(...children);
                    queue.push(...children.map(c => c.cid));
                }
                
                return subdirs;
            }
            
            // Get path from root to directory
            getDirectoryPath(dirCID) {
                const path = [];
                let current = this.directories.find(d => d.cid === dirCID);
                
                while (current) {
                    path.unshift(current);
                    if (current.parentCID) {
                        current = this.directories.find(d => d.cid === current.parentCID);
                    } else {
                        break;
                    }
                }
                
                return path;
            }
            
            async createDirectory(name, fileIds, parentCID = null) {
                if (!name || !name.trim()) {
                    throw new Error('ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªåã‚’å…¥åŠ›ã—ã¦ãã ã•ã„');
                }
                
                if (fileIds.length === 0) {
                    throw new Error('å°‘ãªãã¨ã‚‚1ã¤ã®ãƒ•ã‚¡ã‚¤ãƒ«ã‚’é¸æŠã—ã¦ãã ã•ã„');
                }
                
                // Get file details from history
                const history = window.historyManager?.getHistory() || [];
                const files = fileIds.map(id => {
                    const item = history.find(h => h.id === id);
                    if (!item) return null;
                    
                    return {
                        id: item.id,
                        name: item.fileName,
                        cid: item.cid,
                        metaTxId: item.metaTxId,
                        metaTxBlockId: item.metaTxBlockId,
                        size: item.fileSize,
                        uploadTime: item.uploadTime
                    };
                }).filter(f => f !== null);
                
                if (files.length === 0 && fileIds.length > 0) {
                    throw new Error('é¸æŠã•ã‚ŒãŸãƒ•ã‚¡ã‚¤ãƒ«ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“');
                }
                
                // Create DAG nodes for each file
                const fileLinks = files.map(file => {
                    // Create a file DAG node
                    const fileNode = this.createDAGNode('file', {
                        name: file.name,
                        metaTxId: file.metaTxId,
                        metaTxBlockId: file.metaTxBlockId,
                        uploadTime: file.uploadTime
                    });
                    
                    return {
                        name: file.name,
                        cid: fileNode.cid,
                        size: file.size,
                        type: 'file'
                    };
                });
                
                // Create directory DAG node with links to files
                const dirNode = this.createDAGNode('directory', {
                    name: name.trim(),
                    created: new Date().toISOString(),
                    parentCID: parentCID
                }, fileLinks);
                
                const directory = {
                    id: 'dir_' + Date.now(),
                    type: 'kaspa-directory',
                    version: this.version,
                    name: name.trim(),
                    cid: dirNode.cid,  // DAG CID
                    parentCID: parentCID,
                    created: dirNode.created,
                    files: files,
                    totalSize: dirNode.size
                };
                
                // Create and upload directory metadata
                const dirMetadata = await this.uploadDirectoryMetadata(directory);
                directory.metaTxId = dirMetadata.metaTxId;
                directory.metaTxBlockId = dirMetadata.metaTxBlockId;
                
                this.directories.push(directory);
                this.saveDirectories();
                
                log(`ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã€Œ${name}ã€ã‚’ä½œæˆã—ã¾ã—ãŸï¼ˆ${files.length}ãƒ•ã‚¡ã‚¤ãƒ«, CID: ${dirNode.cid.substring(0, 8)}...ï¼‰`, 'success');
                return directory;
            }
            
            async uploadDirectoryMetadata(directory) {
                // Create directory metadata for blockchain storage
                const metadata = {
                    type: directory.type,
                    version: directory.version,
                    name: directory.name,
                    created: directory.created,
                    files: directory.files.map(f => ({
                        name: f.name,
                        cid: f.cid,
                        metaTxId: f.metaTxId,
                        metaTxBlockId: f.metaTxBlockId,
                        size: f.size
                    }))
                };
                
                const metadataJson = JSON.stringify(metadata);
                const encoder = new TextEncoder();
                const metadataBytes = encoder.encode(metadataJson);
                
                // Simulate upload (in real implementation, this would use createMetaTransaction)
                const simulatedTxId = 'dir_' + Array.from(crypto.getRandomValues(new Uint8Array(32)))
                    .map(b => b.toString(16).padStart(2, '0')).join('');
                const simulatedBlockId = 'blk_' + Array.from(crypto.getRandomValues(new Uint8Array(32)))
                    .map(b => b.toString(16).padStart(2, '0')).join('');
                
                log(`[DirectoryManager] ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿ã‚’ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ï¼ˆã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ï¼‰: ${simulatedTxId.substring(0, 16)}...`, 'info');
                
                return {
                    metaTxId: simulatedTxId,
                    metaTxBlockId: simulatedBlockId
                };
            }
            
            getDirectory(id) {
                return this.directories.find(d => d.id === id);
            }
            
            deleteDirectory(id) {
                const index = this.directories.findIndex(d => d.id === id);
                if (index !== -1) {
                    const dir = this.directories[index];
                    this.directories.splice(index, 1);
                    this.saveDirectories();
                    log(`ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã€Œ${dir.name}ã€ã‚’å‰Šé™¤ã—ã¾ã—ãŸ`, 'success');
                    return true;
                }
                return false;
            }
            
            async downloadDirectory(id) {
                const directory = this.getDirectory(id);
                if (!directory) {
                    throw new Error('ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“');
                }
                
                log(`ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã€Œ${directory.name}ã€ã®ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ã‚’é–‹å§‹ã—ã¾ã™ï¼ˆ${directory.files.length}ãƒ•ã‚¡ã‚¤ãƒ«ï¼‰`, 'info');
                
                // Create a folder in the browser's download
                const dirHandle = await this.createDownloadFolder(directory.name);
                
                // Collect all files including subdirectories
                const allFiles = [];
                const processDirectory = (dir, path = '') => {
                    if (dir.cid) {
                        const nodes = this.traverseDAG(dir.cid);
                        const fileNodes = nodes.filter(n => n.type === 'file');
                        fileNodes.forEach(fileNode => {
                            allFiles.push({
                                ...fileNode.data,
                                path: path
                            });
                        });
                        
                        // Process subdirectories
                        const subdirs = this.directories.filter(d => d.parentCID === dir.cid);
                        subdirs.forEach(subdir => {
                            processDirectory(subdir, path + subdir.name + '/');
                        });
                    } else {
                        // Fallback for v1.0 directories
                        dir.files.forEach(file => {
                            allFiles.push({
                                ...file,
                                path: path
                            });
                        });
                    }
                };
                
                processDirectory(directory);
                
                // Parallel download with concurrency limit
                const CONCURRENT_DOWNLOADS = 3;
                const downloadQueue = [...allFiles];
                const activeDownloads = [];
                
                while (downloadQueue.length > 0 || activeDownloads.length > 0) {
                    // Start new downloads up to the limit
                    while (activeDownloads.length < CONCURRENT_DOWNLOADS && downloadQueue.length > 0) {
                        const file = downloadQueue.shift();
                        const downloadPromise = (async () => {
                            log(`ğŸ“¥ ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ä¸­: ${file.path}${file.name}`, 'info');
                            
                            const kaspaData = {
                                type: 'kaspa-file',
                                version: '2.0',
                                file: {
                                    name: file.name,
                                    metaTxId: file.metaTxId,
                                    metaTxBlockId: file.metaTxBlockId
                                }
                            };
                            
                            // Create subdirectory if needed
                            let targetHandle = dirHandle;
                            if (dirHandle && file.path) {
                                const pathParts = file.path.split('/').filter(p => p);
                                for (const part of pathParts) {
                                    try {
                                        targetHandle = await targetHandle.getDirectoryHandle(part, { create: true });
                                    } catch (e) {
                                        log(`ã‚µãƒ–ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªä½œæˆã‚¨ãƒ©ãƒ¼: ${part}`, 'warning');
                                    }
                                }
                            }
                            
                            await this.downloadFile(kaspaData, targetHandle);
                            log(`âœ… å®Œäº†: ${file.path}${file.name}`, 'success');
                        })();
                        
                        activeDownloads.push(downloadPromise);
                    }
                    
                    // Wait for at least one download to complete
                    if (activeDownloads.length > 0) {
                        const completed = await Promise.race(activeDownloads);
                        activeDownloads.splice(activeDownloads.indexOf(completed), 1);
                    }
                }
                
                log(`ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã€Œ${directory.name}ã€ã®ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ãŒå®Œäº†ã—ã¾ã—ãŸ`, 'success');
            }
            
            async createDownloadFolder(folderName) {
                // Try to use File System Access API
                if ('showDirectoryPicker' in window) {
                    try {
                        const dirHandle = await window.showDirectoryPicker({
                            suggestedName: folderName,
                            mode: 'readwrite'
                        });
                        return dirHandle;
                    } catch (error) {
                        log('ãƒ•ã‚©ãƒ«ãƒ€é¸æŠãŒã‚­ãƒ£ãƒ³ã‚»ãƒ«ã•ã‚ŒãŸã‹ã€ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ', 'warning');
                    }
                }
                
                // Fallback: download files individually
                return null;
            }
            
            async downloadFile(kaspaData, dirHandle) {
                // Generate .kaspa file content
                const kaspaContent = JSON.stringify(kaspaData, null, 2);
                const blob = new Blob([kaspaContent], { type: 'application/octet-stream' });
                
                if (dirHandle) {
                    // Save to selected directory
                    try {
                        const fileName = `${kaspaData.file.name}.kaspa`;
                        const fileHandle = await dirHandle.getFileHandle(fileName, { create: true });
                        const writable = await fileHandle.createWritable();
                        await writable.write(blob);
                        await writable.close();
                        log(`${fileName}ã‚’ä¿å­˜ã—ã¾ã—ãŸ`, 'success');
                    } catch (error) {
                        log(`ãƒ•ã‚¡ã‚¤ãƒ«ä¿å­˜ã‚¨ãƒ©ãƒ¼: ${error.message}`, 'error');
                    }
                } else {
                    // Fallback: trigger browser download
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `${kaspaData.file.name}.kaspa`;
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                }
                
                // Small delay between downloads
                await new Promise(resolve => setTimeout(resolve, 500));
            }
            
            exportDirectory(id) {
                const directory = this.getDirectory(id);
                if (!directory) {
                    throw new Error('ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“');
                }
                
                // Include DAG nodes if available
                const dagData = {};
                if (directory.cid) {
                    const nodes = this.traverseDAG(directory.cid);
                    nodes.forEach(node => {
                        dagData[node.cid] = node;
                    });
                }
                
                const exportData = {
                    type: 'kaspa-directory-export',
                    version: '2.0',
                    exported: new Date().toISOString(),
                    directory: directory,
                    dag: dagData  // Include complete DAG structure
                };
                
                const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `${directory.name}.kaspa-dir`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                
                log(`ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã€Œ${directory.name}ã€ã‚’ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆã—ã¾ã—ãŸ`, 'success');
            }
            
            updateUI() {
                const directoryList = document.getElementById('directoryList');
                if (!directoryList) return;
                
                if (this.directories.length === 0) {
                    directoryList.innerHTML = '<p style="color: #999; text-align: center;">ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªãŒã‚ã‚Šã¾ã›ã‚“</p>';
                    return;
                }
                
                // Build directory tree
                const tree = this.getDirectoryTree();
                
                const renderTree = (dirs, indent = 0) => {
                    return dirs.map(dir => `
                    <div class="history-item" style="margin-bottom: 15px; margin-left: ${indent * 20}px;">
                        <div style="display: flex; justify-content: space-between; align-items: center;">
                            <div>
                                <strong>${indent > 0 ? 'â”” ' : ''}ğŸ“ ${dir.name}</strong>
                                <div style="font-size: 12px; color: #999; margin-top: 5px;">
                                    ${dir.files.length}ãƒ•ã‚¡ã‚¤ãƒ« | ${formatSize(dir.totalSize)} | 
                                    ä½œæˆ: ${new Date(dir.created).toLocaleString()}
                                    ${dir.cid ? `<br>CID: ${dir.cid.substring(0, 12)}...` : ''}
                                </div>
                            </div>
                            <div>
                                <button onclick="window.directoryManager.downloadDirectory('${dir.id}')" class="small-button" title="ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã‚’ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰">
                                    ğŸ“¥
                                </button>
                                <button onclick="window.directoryManager.exportDirectory('${dir.id}')" class="small-button" title="ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã‚’ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆ">
                                    ğŸ’¾
                                </button>
                                <button onclick="if(confirm('ã“ã®ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã‚’å‰Šé™¤ã—ã¾ã™ã‹ï¼Ÿ')) window.directoryManager.deleteDirectory('${dir.id}'); window.directoryManager.updateUI();" class="small-button" title="å‰Šé™¤" style="background: #c13651;">
                                    ğŸ—‘ï¸
                                </button>
                            </div>
                        </div>
                        <details style="margin-top: 10px;">
                            <summary style="cursor: pointer; color: #49EACB;">ãƒ•ã‚¡ã‚¤ãƒ«ä¸€è¦§ã‚’è¡¨ç¤º</summary>
                            <div style="margin-top: 10px; padding-left: 20px;">
                                ${dir.files.map(f => `
                                    <div style="margin-bottom: 5px;">
                                        ğŸ“„ ${f.name} (${formatSize(f.size)})
                                    </div>
                                `).join('')}
                            </div>
                        </details>
                        ${dir.children && dir.children.length > 0 ? renderTree(dir.children, indent + 1) : ''}
                    </div>
                    `).join('');
                };
                
                directoryList.innerHTML = renderTree(tree);
                
                // Update parent directory selector
                this.updateParentDirectorySelector();
            }
            
            updateParentDirectorySelector() {
                const selector = document.getElementById('parentDirectory');
                if (!selector) return;
                
                selector.innerHTML = '<option value="">ãƒ«ãƒ¼ãƒˆãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒª</option>';
                
                // Add all directories as options with indentation
                const addOptions = (dirs, indent = 0) => {
                    dirs.forEach(dir => {
                        const prefix = 'ã€€'.repeat(indent) + (indent > 0 ? 'â”” ' : '');
                        selector.innerHTML += `<option value="${dir.cid}">${prefix}${dir.name}</option>`;
                        if (dir.children && dir.children.length > 0) {
                            addOptions(dir.children, indent + 1);
                        }
                    });
                };
                
                const tree = this.getDirectoryTree();
                addOptions(tree);
            }
            
            updateFileSelector() {
                const fileList = document.getElementById('fileList');
                if (!fileList) return;
                
                const history = window.historyManager?.getHistory() || [];
                const existingDirs = this.directories;
                
                if (history.length === 0 && existingDirs.length === 0) {
                    fileList.innerHTML = '<p style="color: #999; text-align: center;">ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰æ¸ˆã¿ãƒ•ã‚¡ã‚¤ãƒ«ãŒã‚ã‚Šã¾ã›ã‚“</p>';
                    return;
                }
                
                let html = '';
                
                // Add files
                if (history.length > 0) {
                    html += '<h5>ğŸ“„ ãƒ•ã‚¡ã‚¤ãƒ«:</h5>';
                    html += history.map(item => `
                        <label style="display: block; margin-bottom: 10px; cursor: pointer;">
                            <input type="checkbox" value="file:${item.id}" name="directoryFiles" style="margin-right: 10px;">
                            ğŸ“„ ${item.fileName} (${formatSize(item.fileSize)})
                            <span style="font-size: 12px; color: #999; margin-left: 10px;">
                                ${new Date(item.uploadTime).toLocaleDateString()}
                            </span>
                        </label>
                    `).join('');
                }
                
                // Add directories
                if (existingDirs.length > 0) {
                    html += '<h5 style="margin-top: 15px;">ğŸ“ ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒª:</h5>';
                    const renderDirs = (dirs, indent = 0) => {
                        return dirs.map(dir => `
                            <label style="display: block; margin-bottom: 10px; cursor: pointer; margin-left: ${indent * 20}px;">
                                <input type="checkbox" value="dir:${dir.cid}" name="directoryFiles" style="margin-right: 10px;">
                                ${indent > 0 ? 'â”” ' : ''}ğŸ“ ${dir.name} (${dir.files.length}ãƒ•ã‚¡ã‚¤ãƒ«)
                            </label>
                            ${dir.children ? renderDirs(dir.children, indent + 1) : ''}
                        `).join('');
                    };
                    
                    const tree = this.getDirectoryTree();
                    html += renderDirs(tree);
                }
                
                fileList.innerHTML = html;
            }
        }
        
        // Utility functions
        function formatSize(bytes) {
            if (bytes === 0) return '0 B';
            const k = 1024;
            const sizes = ['B', 'KB', 'MB', 'GB', 'TB'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
        }
        
        window.copyToClipboard = async function(text) {
            const preview = text && text.length > 20 ? text.substring(0, 20) + '...' : text;
            log(`[DEBUG] copyToClipboard ãŒå‘¼ã³å‡ºã•ã‚Œã¾ã—ãŸ: ${preview}`, 'debug');
            try {
                await navigator.clipboard.writeText(text);
                log('ã‚¯ãƒªãƒƒãƒ—ãƒœãƒ¼ãƒ‰ã«ã‚³ãƒ”ãƒ¼ã—ã¾ã—ãŸ', 'success');
            } catch (err) {
                log(`ã‚³ãƒ”ãƒ¼ã‚¨ãƒ©ãƒ¼: ${err.message}`, 'error');
            }
        }
        
        // Progress Manager Class
        class ProgressManager {
            constructor(file, chunkSize, cid = null, type = 'upload') {
                this.file = file;
                this.chunkSize = chunkSize;
                this.cid = cid;
                this.type = type; // 'upload' or 'download'
                // Use .kprogress extension with CID
                const baseName = file.name || 'file';
                this.progressFileName = cid ? `${baseName}.${cid}.kprogress` : `${baseName}.kprogress`;
                this.progress = null;
                this.saveHandle = null;
                // v4.7.25: Remove auto-save interval settings (save every chunk)
                this.fileHandle = null; // For File System Access API
            }
            
            async initialize(existingProgress = null) {
                if (existingProgress) {
                    this.progress = existingProgress;
                    log(`æ—¢å­˜ã®é€²æ—ã‹ã‚‰å†é–‹: ${this.progress.metadata.completedChunks}/${this.progress.metadata.totalChunks} ãƒãƒ£ãƒ³ã‚¯å®Œäº†`, 'info');
                    
                    // v4.7.25: Remove save frequency optimization log
                    
                    return true;
                }
                
                // Generate file hash for verification
                const fileData = await this.file.slice(0, 1024 * 1024).arrayBuffer(); // First 1MB
                const hashBuffer = await crypto.subtle.digest('SHA-256', fileData);
                const hashArray = Array.from(new Uint8Array(hashBuffer));
                const fileHash = hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
                
                this.progress = {
                    version: "2.1",
                    type: this.type, // 'upload' or 'download'
                    cid: this.cid,
                    fileInfo: {
                        name: this.file.name,
                        size: this.file.size,
                        lastModified: this.file.lastModified,
                        sha256: fileHash.substring(0, 16), // First 16 chars of hash
                        mimeType: this.file.type || 'application/octet-stream'
                    },
                    encryption: {
                        algorithm: "AES-256-GCM",
                        salt: null, // Will be set during encryption
                        compressed: null
                    },
                    chunks: [],
                    metadata: {
                        totalChunks: Math.ceil(this.file.size / this.chunkSize),
                        completedChunks: 0,
                        chunkSize: this.chunkSize,
                        totalCost: 0,
                        startedAt: Date.now(),
                        lastUpdateAt: Date.now(),
                        estimatedCompletion: null
                    },
                    resume: {
                        nextChunkIndex: 0,
                        failedChunks: [],
                        retryCount: {}
                    }
                };
                
                return false;
            }
            
            async checkExistingProgress() {
                // This will be called when user selects a progress file
                // Returns the progress object if valid, null otherwise
                return null;
            }
            
            validateProgress(progress) {
                // Check if progress matches current file
                if (!progress || !progress.fileInfo) return false;
                if (progress.fileInfo.name !== this.file.name) return false;
                if (progress.fileInfo.size !== this.file.size) return false;
                // Optional: check lastModified if strict matching needed
                return true;
            }
            
            async markChunkComplete(index, txid, blockId, size) {
                const chunk = {
                    index: index,
                    txid: txid,
                    blockId: blockId,
                    size: size,
                    uploadedAt: Date.now(),
                    verified: true
                };
                
                // Update or add chunk
                const existingIndex = this.progress.chunks.findIndex(c => c.index === index);
                if (existingIndex >= 0) {
                    this.progress.chunks[existingIndex] = chunk;
                } else {
                    this.progress.chunks.push(chunk);
                }
                
                this.progress.metadata.completedChunks = this.progress.chunks.length;
                this.progress.metadata.lastUpdateAt = Date.now();
                this.progress.resume.nextChunkIndex = this.getNextChunkIndex();
                
                // Calculate estimated completion
                const elapsed = Date.now() - this.progress.metadata.startedAt;
                const rate = this.progress.metadata.completedChunks / elapsed;
                const remaining = this.progress.metadata.totalChunks - this.progress.metadata.completedChunks;
                this.progress.metadata.estimatedCompletion = Date.now() + (remaining / rate);
                
                // v4.7.25: Save progress after every chunk
                await this.saveProgress();
            }
            
            markChunkFailed(index) {
                if (!this.progress.resume.failedChunks.includes(index)) {
                    this.progress.resume.failedChunks.push(index);
                }
                this.progress.resume.retryCount[index] = (this.progress.resume.retryCount[index] || 0) + 1;
            }
            
            getNextChunkIndex() {
                // First, try failed chunks
                if (this.progress.resume.failedChunks.length > 0) {
                    return this.progress.resume.failedChunks.shift();
                }
                
                // Then find next incomplete chunk
                for (let i = 0; i < this.progress.metadata.totalChunks; i++) {
                    if (!this.progress.chunks.some(c => c.index === i)) {
                        return i;
                    }
                }
                
                return -1; // All done
            }
            
            async saveProgress() {
                try {
                    const progressData = JSON.stringify(this.progress, null, 2);
                    
                    // Save to localStorage as backup
                    try {
                        localStorage.setItem('kaspa-upload-progress', progressData);
                        const metadata = {
                            fileName: this.progress.fileInfo.name,
                            fileSize: this.progress.fileInfo.size,
                            totalChunks: this.progress.metadata.totalChunks,
                            completedChunks: this.progress.metadata.completedChunks,
                            lastUpdate: Date.now()
                        };
                        localStorage.setItem('kaspa-upload-metadata', JSON.stringify(metadata));
                        // v4.7.25: Remove save notifications
                    } catch (err) {
                        // v4.7.25: Remove error log for localStorage
                        console.error(`localStorageä¿å­˜ã‚¨ãƒ©ãƒ¼: ${err.message}`);
                    }
                    
                    // Save to file if workspace is available
                    if (window.workspaceHandle) {
                        try {
                            const fileHandle = await window.workspaceHandle.getFileHandle(
                                this.progressFileName,
                                { create: true }
                            );
                            const writable = await fileHandle.createWritable();
                            await writable.write(progressData);
                            await writable.close();
                            
                            // v4.7.25: Remove save notifications and status update
                        } catch (err) {
                            // v4.7.25: Remove error log for file save
                        console.error(`ãƒ•ã‚¡ã‚¤ãƒ«ä¿å­˜ã‚¨ãƒ©ãƒ¼: ${err.message}`);
                        }
                    } else {
                        // No workspace - localStorage only, no automatic downloads
                    }
                } catch (error) {
                    // v4.7.25: Remove error log for progress save
                    console.error(`é€²æ—ä¿å­˜ã‚¨ãƒ©ãƒ¼: ${error.message}`);
                }
            }
            
            // v4.7.25: Remove updateSaveStatus function (no notifications)
            updateSaveStatus() {
                // No-op
            }
            
            async exportProgress() {
                // Manual export function for user
                const progressData = JSON.stringify(this.progress, null, 2);
                const blob = new Blob([progressData], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = this.progressFileName;
                
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                
                log(`é€²æ—ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆã—ã¾ã—ãŸ`, 'success');
            }
            
            async exportAsKaspa(kaspaMetadata) {
                // Convert progress to .kaspa format when upload completes
                const kaspaFile = {
                    ...kaspaMetadata,
                    resume: {
                        supported: true,
                        progressFile: this.progressFileName,
                        chunks: this.progress.chunks
                    }
                };
                
                return kaspaFile;
            }
            
            getStats() {
                const completed = this.progress.metadata.completedChunks;
                const total = this.progress.metadata.totalChunks;
                const progressPercent = (completed / total * 100);
                
                console.log(`ProgressManager Stats: ${completed}/${total} å®Œäº† (${progressPercent.toFixed(1)}%)`);
                
                return {
                    completedChunks: completed,
                    totalChunks: total,
                    percentage: progressPercent,
                    remaining: total - completed,
                    estimatedTime: this.progress.metadata.estimatedCompletion ? 
                        new Date(this.progress.metadata.estimatedCompletion).toLocaleTimeString() : 'N/A'
                };
            }
            
            isChunkCompleted(index) {
                return this.progress.chunks.some(c => c.index === index);
            }
        }
        
        // Parallel Downloader Class (v3.6.2)
        class ParallelDownloader {
            constructor(rpcClient, concurrency = 8) {
                this.rpcClient = rpcClient;
                this.concurrency = concurrency;
                this.queue = [];
                this.active = 0;
                this.results = new Map();
                this.errors = new Map();
                this.startTime = null;
                this.completedCount = 0;
                this.totalBytes = 0;
                this.queueLock = false;
                this.maxRetries = 3;
            }
            
            async downloadChunks(txIds, blockIds, key, kaspaMetadata, progressCallback) {
                this.startTime = Date.now();
                this.queue = txIds.map((txId, index) => ({ 
                    txId, 
                    blockId: blockIds[index],
                    index, 
                    retries: 0 
                }));
                this.results = new Map();
                this.errors = new Map();
                this.completedCount = 0;
                this.totalBytes = 0;
                this.totalChunks = txIds.length;
                
                log(`ä¸¦åˆ—ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰é–‹å§‹: ${txIds.length}ãƒãƒ£ãƒ³ã‚¯, ${this.concurrency}ä¸¦åˆ—`, 'info');
                
                try {
                    const workers = [];
                    for (let i = 0; i < this.concurrency; i++) {
                        workers.push(this.worker(key, kaspaMetadata, progressCallback));
                    }
                    
                    await Promise.all(workers);
                    
                    if (this.errors.size > 0) {
                        const errorRate = (this.errors.size / txIds.length) * 100;
                        if (errorRate > 10) {
                            const errorMsg = Array.from(this.errors.entries())
                                .map(([idx, err]) => `ãƒãƒ£ãƒ³ã‚¯${idx}: ${err}`)
                                .join(', ');
                            throw new Error(`ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ã‚¨ãƒ©ãƒ¼ç‡ãŒé«˜ã™ãã¾ã™ (${errorRate.toFixed(1)}%): ${errorMsg}`);
                        }
                    }
                    
                    const sortedChunks = [];
                    for (let i = 0; i < txIds.length; i++) {
                        if (!this.results.has(i)) {
                            if (this.errors.has(i)) {
                                throw new Error(`ãƒãƒ£ãƒ³ã‚¯${i}ã®ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ã«å¤±æ•—: ${this.errors.get(i)}`);
                            } else {
                                throw new Error(`ãƒãƒ£ãƒ³ã‚¯${i}ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“`);
                            }
                        }
                        sortedChunks.push(this.results.get(i));
                    }
                    
                    const elapsed = (Date.now() - this.startTime) / 1000;
                    const throughput = (this.totalBytes / 1024 / 1024) / elapsed;
                    log(`ä¸¦åˆ—ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰å®Œäº†: ${elapsed.toFixed(1)}ç§’, ${throughput.toFixed(1)} MB/ç§’`, 'success');
                    
                    return sortedChunks;
                } catch (error) {
                    log(`ä¸¦åˆ—ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ã‚¨ãƒ©ãƒ¼: ${error.message}`, 'error');
                    throw error;
                }
            }
            
            async worker(key, kaspaMetadata, progressCallback) {
                while (true) {
                    let work = null;
                    
                    while (this.queueLock) {
                        await new Promise(resolve => setTimeout(resolve, 10));
                    }
                    
                    this.queueLock = true;
                    try {
                        if (this.queue.length > 0) {
                            work = this.queue.shift();
                            this.active++;
                        }
                    } finally {
                        this.queueLock = false;
                    }
                    
                    if (!work && this.active === 0) {
                        break;
                    }
                    
                    if (!work) {
                        await new Promise(resolve => setTimeout(resolve, 50));
                        continue;
                    }
                    
                    try {
                        const { txId, blockId, index } = work;
                        
                        let response = null;
                        let lastError = null;
                        
                        for (let retry = 0; retry <= this.maxRetries; retry++) {
                            try {
                                response = await this.rpcClient.getBlock({
                                    hash: blockId,
                                    includeTransactions: true
                                });
                                break;
                            } catch (error) {
                                lastError = error;
                                if (retry < this.maxRetries) {
                                    log(`ãƒãƒ£ãƒ³ã‚¯${index}ã®å–å¾—ã«å¤±æ•— (ãƒªãƒˆãƒ©ã‚¤ ${retry + 1}/${this.maxRetries}): ${error.message}`, 'warning');
                                    await new Promise(resolve => setTimeout(resolve, 1000 * (retry + 1)));
                                }
                            }
                        }
                        
                        if (!response) {
                            throw lastError || new Error('ãƒ–ãƒ­ãƒƒã‚¯å–å¾—ã«å¤±æ•—');
                        }
                        
                        const block = response?.block?.block || response?.block;
                        if (!block) {
                            throw new Error(`ãƒ–ãƒ­ãƒƒã‚¯ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“: ${blockId}`);
                        }
                        
                        let payload = null;
                        for (const tx of block.transactions || []) {
                            const txHash = tx.verboseData?.transactionId || tx.id || tx.transactionId;
                            if (txHash === txId) {
                                if (tx.payload && tx.payload !== '') {
                                    payload = safeHexDecode(tx.payload, 'chunk payload');
                                    break;
                                }
                            }
                        }
                        
                        if (!payload) {
                            throw new Error(`ãƒšã‚¤ãƒ­ãƒ¼ãƒ‰ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“`);
                        }
                        
                        const decrypted = await decryptChunk(payload, key, index);
                        log(`[DEBUG Download] ãƒãƒ£ãƒ³ã‚¯${index} å¾©å·åŒ–: ${payload.length} â†’ ${decrypted.length} ãƒã‚¤ãƒˆ`, 'debug');
                        
                        const original = kaspaMetadata.file?.compression?.enabled ? 
                            lzDecompress(decrypted) : decrypted;
                        log(`[DEBUG Download] ãƒãƒ£ãƒ³ã‚¯${index} è§£å‡: ${decrypted.length} â†’ ${original.length} ãƒã‚¤ãƒˆ (åœ§ç¸®${kaspaMetadata.file?.compression?.enabled ? 'æœ‰åŠ¹' : 'ç„¡åŠ¹'})`, 'debug');
                        
                        this.results.set(index, original);
                        this.completedCount++;
                        this.totalBytes += original.length;
                        
                        const elapsed = (Date.now() - this.startTime) / 1000;
                        const speed = this.completedCount / elapsed;
                        const throughput = (this.totalBytes / 1024 / 1024) / elapsed;
                        
                        if (progressCallback) {
                            progressCallback({
                                completed: this.completedCount,
                                total: this.totalChunks,
                                speed: speed,
                                throughput: throughput
                            });
                        }
                        
                    } catch (error) {
                        work.retries++;
                        if (work.retries <= this.maxRetries) {
                            while (this.queueLock) {
                                await new Promise(resolve => setTimeout(resolve, 10));
                            }
                            this.queueLock = true;
                            try {
                                this.queue.push(work);
                            } finally {
                                this.queueLock = false;
                            }
                            log(`ãƒãƒ£ãƒ³ã‚¯${work.index}ã‚’å†è©¦è¡Œã‚­ãƒ¥ãƒ¼ã«è¿½åŠ  (${work.retries}/${this.maxRetries})`, 'warning');
                        } else {
                            log(`ãƒ¯ãƒ¼ã‚«ãƒ¼ã‚¨ãƒ©ãƒ¼ (ãƒãƒ£ãƒ³ã‚¯${work.index}): ${error.message}`, 'error');
                            this.errors.set(work.index, error.message);
                        }
                    } finally {
                        this.active--;
                    }
                }
            }
            
            // v4.7.45: Add downloadPayloads method for DownloadManager
            async downloadPayloads(txIds, blockIds, progressCallback) {
                this.startTime = Date.now();
                this.queue = txIds.map((txId, index) => ({ 
                    txId, 
                    blockId: blockIds[index],
                    index, 
                    retries: 0 
                }));
                this.results = new Map();
                this.errors = new Map();
                this.completedCount = 0;
                this.totalBytes = 0;
                this.totalChunks = txIds.length;
                
                log(`[ParallelDownloader] ãƒšã‚¤ãƒ­ãƒ¼ãƒ‰ä¸¦åˆ—ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰é–‹å§‹: ${txIds.length}å€‹`, 'info');
                
                try {
                    const workers = [];
                    for (let i = 0; i < this.concurrency; i++) {
                        workers.push(this.payloadWorker(progressCallback));
                    }
                    
                    await Promise.all(workers);
                    
                    if (this.errors.size > 0) {
                        const errorMsg = Array.from(this.errors.entries())
                            .map(([idx, err]) => `ãƒšã‚¤ãƒ­ãƒ¼ãƒ‰${idx}: ${err}`)
                            .join(', ');
                        throw new Error(`ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ã‚¨ãƒ©ãƒ¼: ${errorMsg}`);
                    }
                    
                    const sortedPayloads = [];
                    for (let i = 0; i < txIds.length; i++) {
                        if (!this.results.has(i)) {
                            throw new Error(`ãƒšã‚¤ãƒ­ãƒ¼ãƒ‰${i}ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“`);
                        }
                        sortedPayloads.push(this.results.get(i));
                    }
                    
                    return sortedPayloads;
                } catch (error) {
                    log(`[ParallelDownloader] ã‚¨ãƒ©ãƒ¼: ${error.message}`, 'error');
                    throw error;
                }
            }
            
            async payloadWorker(progressCallback) {
                while (true) {
                    let work = null;
                    
                    while (this.queueLock) {
                        await new Promise(resolve => setTimeout(resolve, 10));
                    }
                    
                    this.queueLock = true;
                    try {
                        if (this.queue.length > 0) {
                            work = this.queue.shift();
                            this.active++;
                        }
                    } finally {
                        this.queueLock = false;
                    }
                    
                    if (!work && this.active === 0) {
                        break;
                    }
                    
                    if (!work) {
                        await new Promise(resolve => setTimeout(resolve, 50));
                        continue;
                    }
                    
                    try {
                        const { txId, blockId, index } = work;
                        
                        const response = await this.rpcClient.getBlock({
                            hash: blockId,
                            includeTransactions: true
                        });
                        
                        const block = response?.block?.block || response?.block;
                        if (!block) {
                            throw new Error(`ãƒ–ãƒ­ãƒƒã‚¯ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“: ${blockId}`);
                        }
                        
                        let payload = null;
                        for (const tx of block.transactions || []) {
                            const txHash = tx.verboseData?.transactionId || tx.id || tx.transactionId;
                            if (txHash === txId) {
                                if (tx.payload && tx.payload !== '') {
                                    payload = safeHexDecode(tx.payload, 'payload');
                                    break;
                                }
                            }
                        }
                        
                        if (!payload) {
                            throw new Error(`ãƒšã‚¤ãƒ­ãƒ¼ãƒ‰ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“`);
                        }
                        
                        this.results.set(index, payload);
                        this.completedCount++;
                        this.totalBytes += payload.length;
                        
                        const elapsed = (Date.now() - this.startTime) / 1000;
                        const speed = this.completedCount / elapsed;
                        const throughput = (this.totalBytes / 1024 / 1024) / elapsed;
                        
                        if (progressCallback) {
                            progressCallback({
                                completed: this.completedCount,
                                total: this.totalChunks,
                                speed: speed,
                                throughput: throughput
                            });
                        }
                        
                    } catch (error) {
                        log(`[ParallelDownloader] ãƒšã‚¤ãƒ­ãƒ¼ãƒ‰${work.index}ã‚¨ãƒ©ãƒ¼: ${error.message}`, 'error');
                        this.errors.set(work.index, error.message);
                    } finally {
                        this.active--;
                    }
                }
            }
        }
        
        // Get version from title
        function getAppVersion() {
            const title = document.title;
            const match = title.match(/v(\d+\.\d+\.\d+)/);
            return match ? match[1] : '4.3.0';
        }
        
        // Configuration
        const config = {
            network: 'testnet-10',
            retryCount: 3,
            timeout: 30000,
            testPrivateKey: 'b7e151628aed2a6abf7158809cf4f3c762e7160f38b4da56a784d9045190cfef',
            // Super metadata configuration (experimental)
            superMeta: {
                enabled: true,
                chunksPerMeta: 2,  // å®Ÿé¨“çš„: 2ãƒãƒ£ãƒ³ã‚¯ã”ã¨ã«ãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿ç”Ÿæˆ
                metasPerSuper: 2   // å®Ÿé¨“çš„: 2ãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿ã”ã¨ã«ã‚¹ãƒ¼ãƒ‘ãƒ¼ãƒ¡ã‚¿ç”Ÿæˆ
            }
        };

        // Safe hex decode function
        function safeHexDecode(hexString, context = '') {
            try {
                if (!hexString || typeof hexString !== 'string') {
                    throw new Error('Invalid hex string: null or not a string');
                }
                
                // Remove any whitespace
                hexString = hexString.trim();
                
                if (hexString.length === 0) {
                    throw new Error('Invalid hex string: empty');
                }
                
                if (hexString.length % 2 !== 0) {
                    throw new Error(`Invalid hex string: odd length (${hexString.length})`);
                }
                
                if (!/^[0-9a-fA-F]+$/.test(hexString)) {
                    throw new Error('Invalid hex string: contains non-hex characters');
                }
                
                const matches = hexString.match(/.{1,2}/g);
                if (!matches) {
                    throw new Error('Failed to parse hex string');
                }
                
                return new Uint8Array(matches.map(byte => parseInt(byte, 16)));
            } catch (e) {
                const errorMsg = context ? `Hex decode error in ${context}: ${e.message}` : `Hex decode error: ${e.message}`;
                log(errorMsg, 'error');
                throw new Error(errorMsg);
            }
        }
        
        // Logging system
        function log(message, type = 'info') {
            const timestamp = new Date();
            const logEntry = {
                timestamp: timestamp.toISOString(),
                time: timestamp.toLocaleTimeString(),
                type: type,
                message: message
            };
            
            systemLogs.push(logEntry);
            
            const logContainer = document.getElementById('systemLog');
            const entry = document.createElement('div');
            entry.className = 'log-entry';
            entry.innerHTML = `<span class="log-time">[${logEntry.time}]</span> <span class="log-${type}">${message}</span>`;
            logContainer.appendChild(entry);
            logContainer.scrollTop = logContainer.scrollHeight;
        }


        // Network status
        function updateNetworkStatus(status, text) {
            const indicator = document.querySelector('.status-indicator');
            const statusText = document.getElementById('statusText');
            
            indicator.className = 'status-indicator';
            switch(status) {
                case 'online':
                    indicator.classList.add('status-online');
                    break;
                case 'offline':
                    indicator.classList.add('status-offline');
                    break;
                case 'connecting':
                    indicator.classList.add('status-connecting');
                    break;
            }
            statusText.textContent = text;
        }

        // Generate random CID (8 characters)
        function generateRandomCID() {
            const chars = 'abcdefghijklmnopqrstuvwxyz0123456789';
            let result = '';
            for (let i = 0; i < 8; i++) {
                result += chars.charAt(Math.floor(Math.random() * chars.length));
            }
            return result;
        }

        // Generate safe filename with CID
        function generateSafeFilename(originalName, cid) {
            const ext = '.kaspa';
            const maxLength = 240; // å®‰å…¨ãƒãƒ¼ã‚¸ãƒ³
            
            // 1. é€šå¸¸ãƒ‘ã‚¿ãƒ¼ãƒ³
            let filename = `${originalName}.${cid}${ext}`;
            
            // 2. é•·ã™ãã‚‹å ´åˆã¯å…ƒãƒ•ã‚¡ã‚¤ãƒ«åã‚’çŸ­ç¸®
            if (filename.length > maxLength) {
                const availableLength = maxLength - cid.length - ext.length - 2;
                const truncated = originalName.substring(0, availableLength);
                filename = `${truncated}..${cid}${ext}`;
            }
            
            // 3. ãã‚Œã§ã‚‚é•·ã„å ´åˆã¯CIDã®ã¿
            if (filename.length > maxLength) {
                filename = `file.${cid}${ext}`;
            }
            
            return filename;
        }

        // Simple toast notification
        function showToast(message, type = 'info') {
            // For now, just log it. Can be enhanced with visual toast later
            log(message, type);
        }
        
        // Fetch with timeout and retry
        async function fetchWithTimeout(url, options = {}, timeout = 10000, retries = 3) {
            for (let attempt = 1; attempt <= retries; attempt++) {
                try {
                    const controller = new AbortController();
                    const timeoutId = setTimeout(() => controller.abort(), timeout);
                    
                    const response = await fetch(url, {
                        ...options,
                        signal: controller.signal
                    });
                    
                    clearTimeout(timeoutId);
                    return response;
                    
                } catch (error) {
                    if (error.name === 'AbortError') {
                        log(`ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆ (${timeout}ms): ${url}`, 'warning');
                    } else {
                        log(`ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ã‚¨ãƒ©ãƒ¼: ${error.message}`, 'warning');
                    }
                    
                    if (attempt < retries) {
                        const waitTime = attempt * 1000; // 1s, 2s, 3s
                        log(`${waitTime/1000}ç§’å¾Œã«ãƒªãƒˆãƒ©ã‚¤ (${attempt}/${retries})...`, 'info');
                        await new Promise(resolve => setTimeout(resolve, waitTime));
                    } else {
                        throw error;
                    }
                }
            }
        }

        // Tab switching
        window.switchTab = function(tab) {
            document.querySelectorAll('.tab-btn').forEach(btn => btn.classList.remove('active'));
            document.querySelectorAll('.tab-content').forEach(content => content.classList.remove('active'));
            
            const tabIndex = ['upload', 'download', 'directory', 'history', 'settings'].indexOf(tab);
            document.querySelectorAll('.tab-btn')[tabIndex].classList.add('active');
            document.getElementById(`${tab}-tab`).classList.add('active');
            
            // Update history tab when switching to it
            if (tab === 'history' && window.historyManager) {
                window.historyManager.updateHistoryUI();
            }
            
            // Update directory tab when switching to it
            if (tab === 'directory' && window.directoryManager) {
                window.directoryManager.updateFileSelector();
                window.directoryManager.updateUI();
            }
        };
        
        // Create directory function
        window.createDirectory = async function() {
            try {
                const nameInput = document.getElementById('directoryName');
                const name = nameInput.value.trim();
                
                if (!name) {
                    alert('ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªåã‚’å…¥åŠ›ã—ã¦ãã ã•ã„');
                    return;
                }
                
                const parentSelector = document.getElementById('parentDirectory');
                const parentCID = parentSelector.value || null;
                
                const checkboxes = document.querySelectorAll('input[name="directoryFiles"]:checked');
                const selections = Array.from(checkboxes).map(cb => cb.value);
                
                if (selections.length === 0) {
                    alert('å°‘ãªãã¨ã‚‚1ã¤ã®ãƒ•ã‚¡ã‚¤ãƒ«ã¾ãŸã¯ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã‚’é¸æŠã—ã¦ãã ã•ã„');
                    return;
                }
                
                // Separate files and directories
                const fileIds = selections
                    .filter(s => s.startsWith('file:'))
                    .map(s => s.substring(5));
                
                const dirCIDs = selections
                    .filter(s => s.startsWith('dir:'))
                    .map(s => s.substring(4));
                
                // Process subdirectories
                if (dirCIDs.length > 0) {
                    // Move directories under the new parent
                    dirCIDs.forEach(dirCID => {
                        const dir = window.directoryManager.directories.find(d => d.cid === dirCID);
                        if (dir) {
                            dir.parentCID = parentCID;
                        }
                    });
                    window.directoryManager.saveDirectories();
                }
                
                await window.directoryManager.createDirectory(name, fileIds, parentCID);
                
                // Clear form
                nameInput.value = '';
                checkboxes.forEach(cb => cb.checked = false);
                
                // Update UI
                window.directoryManager.updateUI();
                
            } catch (error) {
                log(`ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªä½œæˆã‚¨ãƒ©ãƒ¼: ${error.message}`, 'error');
                alert(`ã‚¨ãƒ©ãƒ¼: ${error.message}`);
            }
        };

        // Filter out trash and system files
        function shouldSkipFile(fileName, filePath = '') {
            // === iOS/iPadOS patterns ===
            if (fileName.startsWith('._')) return true;
            
            const iosHiddenDirs = [
                '.Trashes', '.TemporaryItems', '.fseventsd',
                '.Spotlight-V100', '.DocumentRevisions-V100'
            ];
            if (iosHiddenDirs.includes(fileName)) return true;
            
            // Safari temporary download files
            if (fileName.endsWith('.download') && fileName.length > 9) return true;
            
            // Recently Deleted folders
            if (filePath.includes('Recently Deleted') || 
                filePath.includes('æœ€è¿‘å‰Šé™¤ã—ãŸé …ç›®')) return true;
            
            // === Android patterns ===
            if (fileName.startsWith('.trashed-')) return true;
            if (fileName.startsWith('.trash')) return true;
            if (fileName === '.FilesByGoogleTrash') return true;
            if (fileName === '.thumbnails') return true;
            
            // === Windows patterns ===
            if (/^\$RECYCLE\.BIN$/i.test(fileName)) return true;
            if (/^RECYCLER$/i.test(fileName)) return true;
            if (/^\$[IR][A-Z0-9]{6,7}\./i.test(fileName)) return true;
            
            // === macOS patterns ===
            if (fileName === '.Trash') return true;
            if (fileName === '.DS_Store') return true;
            if (fileName === '.AppleDouble') return true;
            if (fileName === '.LSOverride') return true;
            if (fileName === '__MACOSX') return true;
            
            // === Linux patterns ===
            if (fileName.endsWith('.trashinfo')) return true;
            if (/^\.Trash-\d+$/.test(fileName)) return true;
            if (filePath.includes('.local/share/Trash')) return true;
            
            // === Common system files ===
            const systemFiles = [
                'Thumbs.db', 'desktop.ini', 'System Volume Information',
                'hiberfil.sys', 'pagefile.sys', '.gitignore', '.gitkeep'
            ];
            if (systemFiles.includes(fileName)) return true;
            
            // === Temporary files ===
            if (fileName.startsWith('~$')) return true;
            if (fileName.endsWith('.tmp')) return true;
            if (fileName.endsWith('.temp')) return true;
            if (fileName.endsWith('.cache')) return true;
            if (fileName === 'Cache.db') return true;
            
            return false;
        }

        // Setup workspace directory for File System Access API
        async function setupWorkspace() {
            try {
                const dirHandle = await window.showDirectoryPicker({
                    mode: 'readwrite',
                    startIn: 'downloads'
                });
                
                window.workspaceHandle = dirHandle;
                log(`ä½œæ¥­ãƒ•ã‚©ãƒ«ãƒ€ã‚’è¨­å®š: ${dirHandle.name}`, 'success');
                
                // Scan for .kprogress files
                progressFileMap.clear();
                let progressCount = 0;
                let skippedCount = 0;
                
                try {
                    for await (const entry of dirHandle.values()) {
                        if (entry.kind === 'file' && entry.name.endsWith('.kprogress')) {
                            // Skip trash/system files
                            if (shouldSkipFile(entry.name)) {
                                skippedCount++;
                                log(`ã‚¹ã‚­ãƒƒãƒ—: ${entry.name}`, 'debug');
                                continue;
                            }
                            
                            // Extract base filename and CID from filename
                            const match = entry.name.match(/^(.+?)\.([a-z0-9]{8})\.kprogress$/);
                            if (match) {
                                const baseFilename = match[1];
                                const cid = match[2];
                                progressFileMap.set(baseFilename, {
                                    cid: cid,
                                    fileHandle: entry,
                                    progressFilename: entry.name
                                });
                                progressCount++;
                                log(`é€²æ—ãƒ•ã‚¡ã‚¤ãƒ«æ¤œå‡º: ${entry.name}`, 'info');
                            }
                        }
                    }
                    
                    if (progressCount > 0) {
                        log(`${progressCount}å€‹ã®é€²æ—ãƒ•ã‚¡ã‚¤ãƒ«ã‚’æ¤œå‡ºã—ã¾ã—ãŸ`, 'success');
                        showToast(`ãƒ¬ã‚¸ãƒ¥ãƒ¼ãƒ å¯èƒ½: ${progressCount}å€‹ã®ãƒ•ã‚¡ã‚¤ãƒ«`, 'info');
                    }
                    
                    if (skippedCount > 0) {
                        log(`${skippedCount}å€‹ã®ã‚´ãƒŸç®±/ã‚·ã‚¹ãƒ†ãƒ ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ã‚¹ã‚­ãƒƒãƒ—ã—ã¾ã—ãŸ`, 'debug');
                    }
                } catch (err) {
                    log('é€²æ—ãƒ•ã‚¡ã‚¤ãƒ«ã‚¹ã‚­ãƒ£ãƒ³ã‚¨ãƒ©ãƒ¼: ' + err.message, 'warning');
                }
                
                // Check for existing progress file (legacy support)
                try {
                    const fileHandle = await dirHandle.getFileHandle('kaspa-upload-progress.json');
                    const file = await fileHandle.getFile();
                    const content = await file.text();
                    const progress = JSON.parse(content);
                    
                    if (progress && progress.version === '2.0' && 
                        progress.metadata.completedChunks < progress.metadata.totalChunks) {
                        
                        const useExisting = confirm(
                            'ä½œæ¥­ãƒ•ã‚©ãƒ«ãƒ€ã«æœªå®Œäº†ã®ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ãŒè¦‹ã¤ã‹ã‚Šã¾ã—ãŸã€‚\n\n' +
                            `ãƒ•ã‚¡ã‚¤ãƒ«: ${progress.fileInfo.name}\n` +
                            `é€²æ—: ${progress.metadata.completedChunks}/${progress.metadata.totalChunks} ãƒãƒ£ãƒ³ã‚¯\n\n` +
                            'ã“ã‚Œã‚’ç¶šè¡Œã—ã¾ã™ã‹ï¼Ÿ'
                        );
                        
                        if (useExisting) {
                            handleProgressLoad(progress);
                        }
                    }
                } catch (err) {
                    // No existing progress file
                }
                
                // Load history if historyManager is initialized
                if (window.historyManager && window.historyManager.encryptionKey) {
                    await window.historyManager.loadFromFile();
                }
                
                // Update UI to show workspace status
                showWorkspaceStatus();
                return true;
                
            } catch (err) {
                if (err.name !== 'AbortError') {
                    log(`ä½œæ¥­ãƒ•ã‚©ãƒ«ãƒ€è¨­å®šã‚¨ãƒ©ãƒ¼: ${err.message}`, 'error');
                }
                return false;
            }
        }
        
        function showWorkspaceStatus() {
            const statusDiv = document.getElementById('workspaceStatus');
            if (!statusDiv) {
                const div = document.createElement('div');
                div.id = 'workspaceStatus';
                div.style.cssText = 'background: #16213e; border: 1px solid #e94560; padding: 10px; margin: 10px 0; border-radius: 5px;';
                const container = document.querySelector('.container');
                if (container) {
                    container.insertBefore(div, container.firstChild);
                }
            }
            
            const status = document.getElementById('workspaceStatus');
            if (status) {
                if (window.workspaceHandle) {
                    status.innerHTML = `
                        <p style="margin: 0; color: #49EACB;">
                            âœ“ ä½œæ¥­ãƒ•ã‚©ãƒ«ãƒ€: ${window.workspaceHandle.name}
                            <button onclick="setupWorkspace()" style="margin-left: 10px; padding: 5px 10px; font-size: 12px;">å¤‰æ›´</button>
                        </p>
                    `;
                } else {
                    status.innerHTML = `
                        <p style="margin: 0; color: #ffcc66;">
                            ä½œæ¥­ãƒ•ã‚©ãƒ«ãƒ€: æœªè¨­å®š (ãƒ–ãƒ©ã‚¦ã‚¶å†…ä¿å­˜ã®ã¿)
                            <button onclick="setupWorkspace()" style="margin-left: 10px; padding: 5px 10px; font-size: 12px;">è¨­å®š</button>
                        </p>
                    `;
                }
            }
        }
        
        function loadProgressFromLocalStorage() {
            try {
                const data = localStorage.getItem('kaspa-upload-progress');
                if (data) {
                    return JSON.parse(data);
                }
            } catch (err) {
                // Ignore errors
            }
            return null;
        }
        
        // Progress file handling
        window.loadProgressFile = async function() {
            // Check workspace first
            if (window.workspaceHandle) {
                try {
                    const fileHandle = await window.workspaceHandle.getFileHandle('kaspa-upload-progress.json');
                    const file = await fileHandle.getFile();
                    const content = await file.text();
                    const progress = JSON.parse(content);
                    
                    if (progress && progress.version === '2.0') {
                        handleProgressLoad(progress);
                        return;
                    }
                } catch (err) {
                    // File doesn't exist in workspace
                }
            }
            
            // Try localStorage
            const progress = loadProgressFromLocalStorage();
            if (progress) {
                const metadata = localStorage.getItem('kaspa-upload-metadata');
                let metaInfo = {};
                try {
                    metaInfo = JSON.parse(metadata) || {};
                } catch (err) {}
                
                const useLocal = confirm(
                    'ä¿å­˜ã•ã‚ŒãŸé€²æ—ãŒè¦‹ã¤ã‹ã‚Šã¾ã—ãŸã€‚\n\n' +
                    `ãƒ•ã‚¡ã‚¤ãƒ«: ${metaInfo.fileName || 'ä¸æ˜'}\n` +
                    `é€²æ—: ${metaInfo.completedChunks || '?'}/${metaInfo.totalChunks || '?'} ãƒãƒ£ãƒ³ã‚¯\n` +
                    `æœ€çµ‚æ›´æ–°: ${metaInfo.lastUpdate ? new Date(metaInfo.lastUpdate).toLocaleString() : 'ä¸æ˜'}\n\n` +
                    'ã“ã‚Œã‚’ä½¿ç”¨ã—ã¾ã™ã‹ï¼Ÿ\n\n' +
                    'ã€Œã‚­ãƒ£ãƒ³ã‚»ãƒ«ã€ã‚’é¸æŠã™ã‚‹ã¨ãƒ•ã‚¡ã‚¤ãƒ«ã‹ã‚‰èª­ã¿è¾¼ã¿ã¾ã™ã€‚'
                );
                
                if (useLocal) {
                    handleProgressLoad(progress);
                    return;
                }
            }
            
            // Load from file as last resort
            document.getElementById('progressFileInput').click();
        };

        window.handleProgressFileSelect = async function(event) {
            const file = event.target.files[0];
            if (!file || !file.name.endsWith('.kprogress')) {
                log('æœ‰åŠ¹ãªé€²æ—ãƒ•ã‚¡ã‚¤ãƒ«ï¼ˆ.kprogressï¼‰ã‚’é¸æŠã—ã¦ãã ã•ã„', 'error');
                return;
            }
            
            try {
                const content = await file.text();
                const progress = JSON.parse(content);
                
                // Extract CID from filename if available
                const match = file.name.match(/\.([a-z0-9]{8})\.kprogress$/);
                if (match && match[1]) {
                    window.currentFileCID = match[1];
                    log(`é€²æ—ãƒ•ã‚¡ã‚¤ãƒ«ã‹ã‚‰CIDã‚’å–å¾—: ${match[1]}`, 'info');
                }
                
                handleProgressLoad(progress);
            } catch (error) {
                log(`é€²æ—ãƒ•ã‚¡ã‚¤ãƒ«èª­ã¿è¾¼ã¿ã‚¨ãƒ©ãƒ¼: ${error.message}`, 'error');
            }
        };
        
        // Handle loaded progress
        function handleProgressLoad(progress) {
            try {
                
                // Validate progress format
                if (!progress.version || !progress.fileInfo || !progress.chunks) {
                    throw new Error('ç„¡åŠ¹ãªé€²æ—ãƒ•ã‚¡ã‚¤ãƒ«å½¢å¼');
                }
                
                // Show resume info
                document.getElementById('resumeInfo').style.display = 'block';
                document.getElementById('resumeDetails').innerHTML = `
                    <p><strong>ãƒ•ã‚¡ã‚¤ãƒ«:</strong> ${progress.fileInfo.name}</p>
                    <p><strong>ã‚µã‚¤ã‚º:</strong> ${(progress.fileInfo.size / 1024 / 1024).toFixed(2)} MB</p>
                    <p><strong>é€²æ—:</strong> ${progress.metadata.completedChunks}/${progress.metadata.totalChunks} ãƒãƒ£ãƒ³ã‚¯ (${(progress.metadata.completedChunks / progress.metadata.totalChunks * 100).toFixed(1)}%)</p>
                    <p><strong>æœ€çµ‚æ›´æ–°:</strong> ${new Date(progress.metadata.lastUpdateAt).toLocaleString()}</p>
                    <p class="warning">âš ï¸ åŒã˜ãƒ•ã‚¡ã‚¤ãƒ«ã‚’é¸æŠã—ã¦ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ã‚’ç¶šè¡Œã—ã¦ãã ã•ã„</p>
                `;
                
                // Store progress for later use
                window.pendingProgress = progress;
                log('é€²æ—ã‚’èª­ã¿è¾¼ã¿ã¾ã—ãŸã€‚åŒã˜ãƒ•ã‚¡ã‚¤ãƒ«ã‚’é¸æŠã—ã¦ãã ã•ã„ã€‚', 'info');
                
                // Show export button if no workspace
                if (!window.workspaceHandle) {
                    const resumeDiv = document.getElementById('resumeInfo');
                    if (resumeDiv && !document.getElementById('exportProgressBtn')) {
                        const exportBtn = document.createElement('button');
                        exportBtn.id = 'exportProgressBtn';
                        exportBtn.textContent = 'é€²æ—ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆ';
                        exportBtn.style.marginTop = '10px';
                        exportBtn.onclick = () => {
                            if (window.pendingProgress) {
                                const progressData = JSON.stringify(window.pendingProgress, null, 2);
                                const blob = new Blob([progressData], { type: 'application/json' });
                                const url = URL.createObjectURL(blob);
                                const a = document.createElement('a');
                                a.href = url;
                                a.download = 'kaspa-upload-progress.json';
                                a.click();
                                URL.revokeObjectURL(url);
                                log('é€²æ—ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆã—ã¾ã—ãŸ', 'success');
                            }
                        };
                        resumeDiv.appendChild(exportBtn);
                    }
                }
                
            } catch (error) {
                log(`é€²æ—èª­ã¿è¾¼ã¿ã‚¨ãƒ©ãƒ¼: ${error.message}`, 'error');
            }
        }

        window.cancelResume = function() {
            window.pendingProgress = null;
            document.getElementById('resumeInfo').style.display = 'none';
            log('ãƒ¬ã‚¸ãƒ¥ãƒ¼ãƒ ã‚’ã‚­ãƒ£ãƒ³ã‚»ãƒ«ã—ã¾ã—ãŸ', 'info');
        };

        // Minimal Download Manager Class
        class DownloadManager {
            constructor() {
                this.isDownloading = false;
                this.metadata = null; // v4.7.14: Store metadata internally
            }
            
            // Simple method to check if ready
            isReady() {
                return !this.isDownloading;
            }
            
            // v4.7.14: Clear stored metadata
            clearMetadata() {
                this.metadata = null;
                log('[DownloadManager] ãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿ã‚’ã‚¯ãƒªã‚¢ã—ã¾ã—ãŸ', 'debug');
            }
            
            // Fetch metadata from blockchain
            async fetchMetadata(metaTxId, blockId, password) {
                try {
                    let payload = null;
                    
                    // If we have BlockID, use RPC directly
                    if (blockId && rpcClient) {
                        log(`[DownloadManager] BlockIDçµŒç”±ã§ãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿å–å¾—: ${blockId.substring(0, 16)}...`, 'info');
                        
                        const blockResponse = await rpcClient.getBlock({
                            hash: blockId,
                            includeTransactions: true
                        });
                        
                        const block = blockResponse?.block?.block || blockResponse?.block;
                        if (!block) {
                            throw new Error(`ãƒ–ãƒ­ãƒƒã‚¯ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“: ${blockId}`);
                        }
                        
                        // Find the meta transaction in the block
                        for (const tx of block.transactions || []) {
                            const txId = tx.verboseData?.transactionId || tx.id || tx.transactionId;
                            if (txId === metaTxId) {
                                if (tx.payload && tx.payload !== '') {
                                    payload = safeHexDecode(tx.payload, 'meta-tx payload');
                                    log(`[DownloadManager] ãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿å–å¾—æˆåŠŸ: ${payload.length} bytes`, 'success');
                                    break;
                                }
                            }
                        }
                    }
                    
                    // Fallback to Explorer API
                    if (!payload) {
                        log(`[DownloadManager] Explorer APIçµŒç”±ã§ãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿å–å¾—`, 'info');
                        const apiUrl = `https://api-tn10.kaspa.org/transactions/${metaTxId}`;
                        const response = await fetchWithTimeout(apiUrl, {}, 10000, 2);
                        
                        if (!response.ok) {
                            throw new Error(`ãƒ¡ã‚¿ãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³ã®å–å¾—ã«å¤±æ•—: ${response.status}`);
                        }
                        
                        const data = await response.json();
                        if (data.payload) {
                            payload = safeHexDecode(data.payload, 'meta-tx payload from API');
                        }
                    }
                    
                    if (!payload) {
                        throw new Error('ãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿ã®ãƒšã‚¤ãƒ­ãƒ¼ãƒ‰ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“');
                    }
                    
                    // Decrypt metadata
                    if (payload.length > 16) {
                        const salt = payload.slice(0, 16);
                        const encryptedData = payload.slice(16);
                        const key = await deriveKey(password, salt);
                        
                        const decrypted = await decryptChunk(encryptedData, key, -1);
                        const metaDataString = new TextDecoder().decode(decrypted);
                        const metadata = JSON.parse(metaDataString);
                        
                        log(`[DownloadManager] ãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿å¾©å·æˆåŠŸ: v${metadata.version}`, 'success');
                        // v4.7.14: Store metadata internally
                        this.metadata = metadata;
                        return metadata;
                    } else {
                        throw new Error('ãƒšã‚¤ãƒ­ãƒ¼ãƒ‰ãŒçŸ­ã™ãã¾ã™');
                    }
                    
                } catch (error) {
                    log(`[DownloadManager] ãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿å–å¾—ã‚¨ãƒ©ãƒ¼: ${error.message}`, 'error');
                    throw error;
                }
            }
            
            // Download raw payload without decryption (for new approach)
            async downloadPayload(txId, blockId, index) {
                try {
                    log(`[DownloadManager] ãƒšã‚¤ãƒ­ãƒ¼ãƒ‰ ${index + 1} ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰é–‹å§‹: ${txId.substring(0, 16)}...`, 'info');
                    
                    // Get block data
                    const blockResponse = await rpcClient.getBlock({
                        hash: blockId,
                        includeTransactions: true
                    });
                    
                    const block = blockResponse?.block?.block || blockResponse?.block;
                    if (!block) {
                        throw new Error(`ãƒ–ãƒ­ãƒƒã‚¯ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“: ${blockId}`);
                    }
                    
                    // Find transaction
                    let payload = null;
                    for (const tx of block.transactions || []) {
                        const txHash = tx.verboseData?.transactionId || tx.id || tx.transactionId;
                        if (txHash === txId) {
                            if (tx.payload && tx.payload !== '') {
                                payload = safeHexDecode(tx.payload, 'payload');
                                log(`[DownloadManager] ãƒšã‚¤ãƒ­ãƒ¼ãƒ‰å–å¾—: ${payload.length} bytes`, 'success');
                                break;
                            }
                        }
                    }
                    
                    if (!payload) {
                        throw new Error(`ãƒšã‚¤ãƒ­ãƒ¼ãƒ‰ ${index + 1} ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“`);
                    }
                    
                    return payload;
                    
                } catch (error) {
                    log(`[DownloadManager] ãƒšã‚¤ãƒ­ãƒ¼ãƒ‰ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ã‚¨ãƒ©ãƒ¼: ${error.message}`, 'error');
                    throw error;
                }
            }
            
            // Download single chunk from blockchain
            async downloadChunk(txId, blockId, key, index, metadata) {
                try {
                    log(`[DownloadManager] ãƒãƒ£ãƒ³ã‚¯ ${index + 1} ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰é–‹å§‹: ${txId.substring(0, 16)}...`, 'info');
                    
                    // Get block data
                    const blockResponse = await rpcClient.getBlock({
                        hash: blockId,
                        includeTransactions: true
                    });
                    
                    const block = blockResponse?.block?.block || blockResponse?.block;
                    if (!block) {
                        throw new Error(`ãƒ–ãƒ­ãƒƒã‚¯ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“: ${blockId}`);
                    }
                    
                    // Find transaction
                    let payload = null;
                    for (const tx of block.transactions || []) {
                        const txHash = tx.verboseData?.transactionId || tx.id || tx.transactionId;
                        if (txHash === txId) {
                            if (tx.payload && tx.payload !== '') {
                                payload = safeHexDecode(tx.payload, 'chunk payload');
                                log(`[DownloadManager] ãƒãƒ£ãƒ³ã‚¯ãƒšã‚¤ãƒ­ãƒ¼ãƒ‰å–å¾—: ${payload.length} bytes`, 'success');
                                break;
                            }
                        }
                    }
                    
                    if (!payload) {
                        throw new Error(`ãƒãƒ£ãƒ³ã‚¯ ${index + 1} ã®ãƒšã‚¤ãƒ­ãƒ¼ãƒ‰ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“`);
                    }
                    
                    // v4.7.41: Enhanced debugging for variable chunk compression
                    if (metadata.file?.compression?.enabled && metadata.metadata?.chunkBoundaries) {
                        log(`[DownloadManager] å¯å¤‰ãƒãƒ£ãƒ³ã‚¯åœ§ç¸®ãƒ•ã‚¡ã‚¤ãƒ«æ¤œå‡º - æš—å·åŒ–ãƒ‡ãƒ¼ã‚¿ã‚’ãã®ã¾ã¾è¿”ã™`, 'info');
                        log(`[DownloadManager] ãƒãƒ£ãƒ³ã‚¯ ${index}: payload size=${payload.length} bytes`, 'debug');
                        log(`[DownloadManager] Encrypted data preview: ${Array.from(payload.slice(0, 16)).map(b => b.toString(16).padStart(2, '0')).join(' ')}...`, 'debug');
                        if (metadata.metadata.chunkBoundaries[index]) {
                            log(`[DownloadManager] Boundary info: ${JSON.stringify(metadata.metadata.chunkBoundaries[index])}`, 'debug');
                        }
                        return payload; // Return encrypted data as-is for later processing
                    }
                    
                    // Standard processing for non-variable chunk files
                    const decrypted = await decryptChunk(payload, key, index);
                    const decompressed = metadata.file?.compression?.enabled ? 
                        lzDecompress(decrypted) : decrypted;
                    
                    log(`[DownloadManager] ãƒãƒ£ãƒ³ã‚¯ ${index + 1} å‡¦ç†å®Œäº†: ${decompressed.length} bytes`, 'success');
                    return decompressed;
                    
                } catch (error) {
                    log(`[DownloadManager] ãƒãƒ£ãƒ³ã‚¯ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ã‚¨ãƒ©ãƒ¼: ${error.message}`, 'error');
                    throw error;
                }
            }
            
            // Execute download with all chunks
            async executeDownload(metadata, password, options = {}) {
                try {
                    this.isDownloading = true;
                    const { onProgress, onComplete, folderStructure } = options;
                    
                    log(`[DownloadManager] ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰é–‹å§‹: ${metadata.file?.name || 'unknown'}`, 'info');
                    log(`[DownloadManager DEBUG] chunks[0]: ${metadata.chunks[0]?.substring(0, 16)}...`, 'debug');
                    log(`[DownloadManager DEBUG] chunksé…åˆ—é•·: ${metadata.chunks?.length}`, 'debug');
                    log(`[DownloadManager DEBUG] chunkStructure.type: ${metadata.chunkStructure?.type}`, 'debug');
                    
                    // Derive encryption key
                    const salt = fromBase64(metadata.encryption.pbkdf2.salt);
                    const iterations = metadata.encryption.pbkdf2.iterations || 
                        (metadata.version === "3.0" ? 10000 : 100000);
                    const key = await deriveKey(password, salt, iterations);
                    
                    // Check if using new payload split approach
                    let combined;
                    
                    if (metadata.metadata?.payloadSplit) {
                        // New approach: download payloads and reconstruct
                        log('[DownloadManager] æ–°æ–¹å¼: ãƒšã‚¤ãƒ­ãƒ¼ãƒ‰åˆ†å‰²ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ã‚’ä½¿ç”¨', 'info');
                        
                        const payloads = [];
                        const totalPayloads = metadata.chunks.length;
                        
                        // v4.7.45: Check if parallel download should be used
                        const useParallel = window.parallelDownloadEnabled && totalPayloads >= 2;
                        
                        if (useParallel) {
                            // Parallel download for payload split
                            log(`[DownloadManager] ä¸¦åˆ—ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ãƒ¢ãƒ¼ãƒ‰ã‚’ä½¿ç”¨ (${totalPayloads}ãƒšã‚¤ãƒ­ãƒ¼ãƒ‰)`, 'info');
                            
                            const downloader = new ParallelDownloader(rpcClient, 8);
                            const parallelPayloads = await downloader.downloadPayloads(
                                metadata.chunks,
                                metadata.chunkBlockIds,
                                (progress) => {
                                    if (onProgress) {
                                        onProgress({
                                            current: progress.completed,
                                            total: progress.total,
                                            percent: ((progress.completed / progress.total) * 100).toFixed(0),
                                            speed: progress.speed,
                                            throughput: progress.throughput
                                        });
                                    }
                                }
                            );
                            payloads.push(...parallelPayloads);
                        } else {
                            // Sequential download
                            for (let i = 0; i < totalPayloads; i++) {
                                const txId = metadata.chunks[i];
                                const blockId = metadata.chunkBlockIds[i];
                                
                                // Progress callback
                                if (onProgress) {
                                    onProgress({
                                        current: i + 1,
                                        total: totalPayloads,
                                        percent: ((i + 1) / totalPayloads * 100).toFixed(0)
                                    });
                                }
                                
                                // Download raw payload (no decryption yet)
                                const payload = await this.downloadPayload(txId, blockId, i);
                                payloads.push(payload);
                            }
                        }
                        
                        // Combine all payloads
                        const totalPayloadSize = payloads.reduce((sum, p) => sum + p.length, 0);
                        const encryptedData = new Uint8Array(totalPayloadSize);
                        let payloadOffset = 0;
                        
                        for (const payload of payloads) {
                            encryptedData.set(payload, payloadOffset);
                            payloadOffset += payload.length;
                        }
                        
                        log(`[DownloadManager] å…¨ãƒšã‚¤ãƒ­ãƒ¼ãƒ‰çµåˆå®Œäº†: ${totalPayloadSize} bytes`, 'info');
                        
                        // Decrypt entire data stream using chunk boundaries
                        const decryptedChunks = [];
                        
                        if (metadata.metadata?.chunkBoundaries) {
                            // Use chunk boundary information for precise decryption
                            log('[DownloadManager] ãƒãƒ£ãƒ³ã‚¯ãƒã‚¦ãƒ³ãƒ€ãƒªæƒ…å ±ã‚’ä½¿ç”¨ã—ã¦å¾©å·åŒ–', 'info');
                            const boundaries = metadata.metadata.chunkBoundaries;
                            
                            for (const boundary of boundaries) {
                                const start = boundary.offset;
                                const end = start + boundary.size;
                                
                                if (start < encryptedData.length) {
                                    const encryptedChunk = encryptedData.slice(start, Math.min(end, encryptedData.length));
                                    try {
                                        const decryptedChunk = await decryptChunk(encryptedChunk, key, boundary.index);
                                        decryptedChunks.push(decryptedChunk);
                                    } catch (e) {
                                        log(`[DownloadManager] ãƒãƒ£ãƒ³ã‚¯ ${boundary.index} ã®å¾©å·åŒ–ã‚¨ãƒ©ãƒ¼: ${e.message}`, 'error');
                                        throw new Error(`ãƒãƒ£ãƒ³ã‚¯ ${boundary.index} ã®å¾©å·åŒ–ã«å¤±æ•—ã—ã¾ã—ãŸ`);
                                    }
                                }
                            }
                        } else {
                            // Fallback: try to find chunk boundaries by trial and error
                            log('[DownloadManager] ãƒãƒ£ãƒ³ã‚¯ãƒã‚¦ãƒ³ãƒ€ãƒªæƒ…å ±ãªã— - è©¦è¡ŒéŒ¯èª¤ã§å¾©å·åŒ–', 'warning');
                            let encryptOffset = 0;
                            let chunkIndex = 0;
                            const PROCESS_CHUNK_SIZE = 128 * 1024;
                            
                            while (encryptOffset < encryptedData.length) {
                                let foundChunk = false;
                                
                                // Try standard chunk size first
                                const standardSize = PROCESS_CHUNK_SIZE + 16;
                                if (encryptOffset + standardSize <= encryptedData.length) {
                                    try {
                                        const encryptedChunk = encryptedData.slice(encryptOffset, encryptOffset + standardSize);
                                        const decryptedChunk = await decryptChunk(encryptedChunk, key, chunkIndex);
                                        decryptedChunks.push(decryptedChunk);
                                        encryptOffset += standardSize;
                                        chunkIndex++;
                                        foundChunk = true;
                                    } catch (e) {
                                        // Standard size failed
                                    }
                                }
                                
                                // If standard size failed, try remaining data as final chunk
                                if (!foundChunk && encryptOffset < encryptedData.length) {
                                    const remainingData = encryptedData.slice(encryptOffset);
                                    try {
                                        const decryptedChunk = await decryptChunk(remainingData, key, chunkIndex);
                                        decryptedChunks.push(decryptedChunk);
                                        break;
                                    } catch (e) {
                                        log(`[DownloadManager] å¾©å·åŒ–ã‚¨ãƒ©ãƒ¼ at offset ${encryptOffset}: ${e.message}`, 'error');
                                        throw new Error('ãƒ‡ãƒ¼ã‚¿ã®å¾©å·åŒ–ã«å¤±æ•—ã—ã¾ã—ãŸ');
                                    }
                                }
                            }
                        }
                        
                        // Combine decrypted chunks
                        const totalDecryptedSize = decryptedChunks.reduce((sum, chunk) => sum + chunk.length, 0);
                        const decrypted = new Uint8Array(totalDecryptedSize);
                        let offset = 0;
                        for (const chunk of decryptedChunks) {
                            decrypted.set(chunk, offset);
                            offset += chunk.length;
                        }
                        
                        // Decompress if needed
                        combined = metadata.file?.compression?.enabled ? 
                            lzDecompress(decrypted) : decrypted;
                        
                        // Verify final size
                        if (combined.length !== metadata.file.size) {
                            log(`[DownloadManager] ã‚µã‚¤ã‚ºä¸ä¸€è‡´è­¦å‘Š: æœŸå¾…å€¤ ${metadata.file.size}, å®Ÿéš› ${combined.length}`, 'warning');
                        }
                        
                    } else {
                        // Old approach: download and decrypt chunks individually
                        log('[DownloadManager] å¾“æ¥æ–¹å¼: ãƒãƒ£ãƒ³ã‚¯å˜ä½ã®ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ã‚’ä½¿ç”¨', 'info');
                        
                        // v4.7.41: Enhanced debugging for variable chunk compression
                        if (metadata.file?.compression?.enabled && metadata.metadata?.chunkBoundaries) {
                            log('[DownloadManager] å¯å¤‰ãƒãƒ£ãƒ³ã‚¯åœ§ç¸®ãƒ•ã‚¡ã‚¤ãƒ«ã®ã‚·ãƒ¼ã‚±ãƒ³ã‚·ãƒ£ãƒ«ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰', 'info');
                            log(`[DownloadManager] Total boundaries: ${metadata.metadata.chunkBoundaries.length}`, 'debug');
                            log(`[DownloadManager] Total chunks: ${metadata.chunks.length}`, 'debug');
                            
                            // Download all encrypted chunks
                            const encryptedChunks = [];
                            const totalChunks = metadata.chunks.length;
                            
                            for (let i = 0; i < totalChunks; i++) {
                                const txId = metadata.chunks[i];
                                const blockId = metadata.chunkBlockIds[i];
                                
                                // Progress callback
                                if (onProgress) {
                                    onProgress({
                                        current: i + 1,
                                        total: totalChunks,
                                        percent: ((i + 1) / totalChunks * 100).toFixed(0)
                                    });
                                }
                                
                                log(`[DownloadManager] Downloading chunk ${i}: ${txId.substring(0, 16)}...`, 'debug');
                                const encryptedChunk = await this.downloadChunk(txId, blockId, key, i, metadata);
                                encryptedChunks.push(encryptedChunk);
                            }
                            
                            // Combine encrypted chunks
                            const totalEncryptedSize = encryptedChunks.reduce((sum, chunk) => sum + chunk.length, 0);
                            const encryptedData = new Uint8Array(totalEncryptedSize);
                            let encryptOffset = 0;
                            
                            for (const chunk of encryptedChunks) {
                                encryptedData.set(chunk, encryptOffset);
                                encryptOffset += chunk.length;
                            }
                            
                            log(`[DownloadManager] å…¨æš—å·åŒ–ãƒ‡ãƒ¼ã‚¿çµåˆå®Œäº†: ${totalEncryptedSize} bytes`, 'info');
                            
                            // Decrypt using chunk boundaries
                            const decryptedChunks = [];
                            const boundaries = metadata.metadata.chunkBoundaries;
                            
                            log(`[DownloadManager] Starting decryption with boundaries...`, 'info');
                            for (const boundary of boundaries) {
                                const start = boundary.offset;
                                const end = start + boundary.size;
                                
                                if (start < encryptedData.length) {
                                    const encryptedChunk = encryptedData.slice(start, Math.min(end, encryptedData.length));
                                    try {
                                        log(`[DownloadManager] ãƒãƒ£ãƒ³ã‚¯ ${boundary.index} å¾©å·åŒ–: offset=${start}, size=${encryptedChunk.length}`, 'info');
                                        log(`[DownloadManager] Encrypted chunk preview: ${Array.from(encryptedChunk.slice(0, 16)).map(b => b.toString(16).padStart(2, '0')).join(' ')}...`, 'debug');
                                        const decryptedChunk = await decryptChunk(encryptedChunk, key, boundary.index);
                                        log(`[DownloadManager] ãƒãƒ£ãƒ³ã‚¯ ${boundary.index} å¾©å·åŒ–æˆåŠŸ: ${decryptedChunk.length} bytes`, 'success');
                                        decryptedChunks.push(decryptedChunk);
                                    } catch (e) {
                                        log(`[DownloadManager] ãƒãƒ£ãƒ³ã‚¯ ${boundary.index} ã®å¾©å·åŒ–ã‚¨ãƒ©ãƒ¼: ${e.message}`, 'error');
                                        throw new Error(`ãƒãƒ£ãƒ³ã‚¯ ${boundary.index} ã®å¾©å·åŒ–ã«å¤±æ•—ã—ã¾ã—ãŸ`);
                                    }
                                }
                            }
                            
                            // Combine and decompress
                            const totalDecryptedSize = decryptedChunks.reduce((sum, chunk) => sum + chunk.length, 0);
                            const decrypted = new Uint8Array(totalDecryptedSize);
                            let decryptOffset = 0;
                            for (const chunk of decryptedChunks) {
                                decrypted.set(chunk, decryptOffset);
                                decryptOffset += chunk.length;
                            }
                            
                            log(`[DownloadManager] Decompressing ${decrypted.length} bytes...`, 'info');
                            combined = lzDecompress(decrypted);
                            log(`[DownloadManager] Decompressed to ${combined.length} bytes`, 'success');
                            
                        } else {
                            // Standard non-variable chunk processing
                            const chunks = [];
                            const totalChunks = metadata.chunks.length;
                            
                            for (let i = 0; i < totalChunks; i++) {
                                const txId = metadata.chunks[i];
                                const blockId = metadata.chunkBlockIds[i];
                                
                                // Progress callback
                                if (onProgress) {
                                    onProgress({
                                        current: i + 1,
                                        total: totalChunks,
                                        percent: ((i + 1) / totalChunks * 100).toFixed(0)
                                    });
                                }
                                
                                const chunk = await this.downloadChunk(txId, blockId, key, i, metadata);
                                chunks.push(chunk);
                            }
                            
                            // Combine chunks
                            const totalSize = chunks.reduce((sum, chunk) => sum + chunk.length, 0);
                            combined = new Uint8Array(totalSize);
                            let offset = 0;
                            
                            for (const chunk of chunks) {
                                combined.set(chunk, offset);
                                offset += chunk.length;
                            }
                        }
                    }
                    
                    log(`[DownloadManager] ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰å®Œäº†: ${combined.length} bytes`, 'success');
                    
                    // Create blob and download
                    const blob = new Blob([combined], { 
                        type: metadata.file?.mimeType || 'application/octet-stream' 
                    });
                    
                    // v4.7.8: Handle folder structure if specified
                    if (folderStructure && folderStructure.enabled && 'showDirectoryPicker' in window) {
                        try {
                            log('[DownloadManager] ãƒ•ã‚©ãƒ«ãƒ€æ§‹é€ ã‚’ä½¿ç”¨ã—ãŸãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ã‚’é–‹å§‹', 'info');
                            
                            let targetHandle;
                            
                            // v4.7.9: Use provided targetHandle or show picker
                            if (folderStructure.targetHandle) {
                                targetHandle = folderStructure.targetHandle;
                                log('[DownloadManager] æä¾›ã•ã‚ŒãŸtargetHandleã‚’ä½¿ç”¨', 'info');
                            } else {
                                // Show directory picker
                                const dirHandle = await window.showDirectoryPicker({
                                    suggestedName: folderStructure.basePath || 'download',
                                    mode: 'readwrite'
                                });
                                targetHandle = dirHandle;
                            }
                            
                            // Create or navigate to base directory
                            if (folderStructure.basePath && !folderStructure.targetHandle) {
                                try {
                                    targetHandle = await targetHandle.getDirectoryHandle(folderStructure.basePath, { create: true });
                                    log(`[DownloadManager] ãƒ™ãƒ¼ã‚¹ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒª: ${folderStructure.basePath}`, 'info');
                                } catch (e) {
                                    log(`[DownloadManager] ãƒ™ãƒ¼ã‚¹ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªä½œæˆã‚¨ãƒ©ãƒ¼: ${e.message}`, 'error');
                                }
                            }
                            
                            // Create subdirectories based on file path
                            if (folderStructure.filePath) {
                                const pathParts = folderStructure.filePath.split('/');
                                // Remove the filename from path
                                pathParts.pop();
                                
                                for (const part of pathParts) {
                                    if (part) {
                                        try {
                                            targetHandle = await targetHandle.getDirectoryHandle(part, { create: true });
                                            log(`[DownloadManager] ã‚µãƒ–ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªä½œæˆ: ${part}`, 'info');
                                        } catch (e) {
                                            log(`[DownloadManager] ã‚µãƒ–ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªä½œæˆã‚¨ãƒ©ãƒ¼: ${part} - ${e.message}`, 'error');
                                        }
                                    }
                                }
                            }
                            
                            // Save file
                            try {
                                const fileName = metadata.file?.name || 'download';
                                const fileHandle = await targetHandle.getFileHandle(fileName, { create: true });
                                const writable = await fileHandle.createWritable();
                                await writable.write(blob);
                                await writable.close();
                                log(`[DownloadManager] ãƒ•ã‚¡ã‚¤ãƒ«ä¿å­˜å®Œäº†: ${folderStructure.filePath || fileName}`, 'success');
                                
                                // Call onComplete if provided
                                if (onComplete) {
                                    onComplete(blob, fileName);
                                }
                                
                                // Skip default download since we saved to folder
                                this.isDownloading = false;
                                return blob;
                            } catch (e) {
                                log(`[DownloadManager] ãƒ•ã‚¡ã‚¤ãƒ«ä¿å­˜ã‚¨ãƒ©ãƒ¼: ${e.message}`, 'error');
                                throw e;
                            }
                            
                        } catch (error) {
                            if (error.name === 'AbortError') {
                                log('[DownloadManager] ãƒ•ã‚©ãƒ«ãƒ€é¸æŠãŒã‚­ãƒ£ãƒ³ã‚»ãƒ«ã•ã‚Œã¾ã—ãŸ', 'warning');
                            } else {
                                log(`[DownloadManager] File System Access APIã‚¨ãƒ©ãƒ¼: ${error.message}`, 'error');
                            }
                            // Fall through to default download
                        }
                    }
                    
                    // Default behavior or fallback
                    if (onComplete) {
                        onComplete(blob, metadata.file?.name);
                    } else {
                        // Default download behavior
                        const url = URL.createObjectURL(blob);
                        const a = document.createElement('a');
                        a.href = url;
                        a.download = metadata.file?.name || 'download';
                        a.click();
                        URL.revokeObjectURL(url);
                    }
                    
                    this.isDownloading = false;
                    return blob;
                    
                } catch (error) {
                    this.isDownloading = false;
                    log(`[DownloadManager] ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ã‚¨ãƒ©ãƒ¼: ${error.message}`, 'error');
                    throw error;
                }
            }
        }

        // System initialization
        window.initializeSystem = async function() {
            try {
                log('ã‚·ã‚¹ãƒ†ãƒ åˆæœŸåŒ–ã‚’é–‹å§‹...');
                updateNetworkStatus('connecting', 'åˆæœŸåŒ–ä¸­...');
                
                // Import WASM SDK
                kaspa = await import('./kaspa-core.js');
                log('kaspa-core.jsã‚’ã‚¤ãƒ³ãƒãƒ¼ãƒˆã—ã¾ã—ãŸ');
                
                // Initialize WASM binary
                await kaspa.default('./kaspa-core_bg.wasm');
                log('WASMãƒã‚¤ãƒŠãƒªã‚’åˆæœŸåŒ–ã—ã¾ã—ãŸ');
                
                // Verify functions
                const requiredFunctions = ['RpcClient', 'Resolver', 'createTransactions', 
                    'PrivateKey', 'addressFromScriptPublicKey', 'Address'];
                for (const func of requiredFunctions) {
                    if (typeof kaspa[func] !== 'function') {
                        throw new Error(`å¿…è¦ãªé–¢æ•°ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“: ${func}`);
                    }
                }
                log('ã™ã¹ã¦ã®å¿…è¦ãªé–¢æ•°ã‚’ç¢ºèªã—ã¾ã—ãŸ', 'success');
                
                // Initialize wallet
                privateKey = new kaspa.PrivateKey(config.testPrivateKey);
                const publicKey = privateKey.toPublicKey();
                address = publicKey.toAddress(config.network);
                
                log(`ã‚¦ã‚©ãƒ¬ãƒƒãƒˆã‚¢ãƒ‰ãƒ¬ã‚¹: ${address.toString()}`, 'success');
                
                // Create RPC client
                rpcClient = new kaspa.RpcClient({
                    resolver: new kaspa.Resolver(),
                    networkId: config.network
                });
                
                log('RPCæ¥ç¶šã‚’è©¦è¡Œä¸­...');
                await rpcClient.connect();
                
                // Test connection
                const info = await rpcClient.getServerInfo();
                log(`æ¥ç¶šæˆåŠŸ! ã‚µãƒ¼ãƒãƒ¼: ${info.serverVersion}`, 'success');
                
                // Get balance
                const { entries } = await rpcClient.getUtxosByAddresses([address.toString()]);
                const balance = entries.reduce((sum, utxo) => sum + Number(utxo.amount), 0) / 1e8;
                log(`æ®‹é«˜: ${balance} KAS`, 'info');
                
                // Update UI
                window.kaspa = kaspa;
                document.getElementById('initStatus').style.display = 'block';
                document.getElementById('initStatus').innerHTML = `
                    <p class="success">âœ… ã‚·ã‚¹ãƒ†ãƒ åˆæœŸåŒ–å®Œäº†</p>
                    <p>ã‚¢ãƒ‰ãƒ¬ã‚¹: ${address.toString()}</p>
                    <p>æ®‹é«˜: ${balance} KAS</p>
                `;
                document.getElementById('testBtn').disabled = false;
                document.getElementById('uploadBtn').disabled = false;
                
                // Initialize history manager
                if (window.historyManager) {
                    await window.historyManager.initialize(config.testPrivateKey);
                    window.historyManager.updateHistoryUI();
                }
                
                updateNetworkStatus('online', 'ã‚ªãƒ³ãƒ©ã‚¤ãƒ³');
                
            } catch (error) {
                log(`åˆæœŸåŒ–ã‚¨ãƒ©ãƒ¼: ${error.message}`, 'error');
                updateNetworkStatus('offline', 'ã‚¨ãƒ©ãƒ¼');
            }
        };
        
        // Initialize or reinitialize RPC client
        async function initializeRpcClient() {
            try {
                log('RPCã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã‚’åˆæœŸåŒ–ä¸­...');
                
                // Close existing connection if any
                if (rpcClient) {
                    try {
                        await rpcClient.disconnect();
                    } catch (err) {
                        // Ignore disconnect errors
                    }
                }
                
                // Create new RPC client
                rpcClient = new kaspa.RpcClient({
                    resolver: new kaspa.Resolver(),
                    networkId: config.network
                });
                
                await rpcClient.connect();
                
                // Test connection
                const info = await rpcClient.getServerInfo();
                log(`RPCå†æ¥ç¶šæˆåŠŸ! ã‚µãƒ¼ãƒãƒ¼: ${info.serverVersion}`, 'success');
                
                updateNetworkStatus('online', 'ã‚ªãƒ³ãƒ©ã‚¤ãƒ³');
                return true;
                
            } catch (error) {
                log(`RPCåˆæœŸåŒ–ã‚¨ãƒ©ãƒ¼: ${error.message}`, 'error');
                updateNetworkStatus('offline', 'ã‚¨ãƒ©ãƒ¼');
                return false;
            }
        }

        // Connection test
        window.testConnection = async function() {
            try {
                log('æ¥ç¶šãƒ†ã‚¹ãƒˆã‚’å®Ÿè¡Œä¸­...');
                const startTime = Date.now();
                
                // Test RPC
                const info = await rpcClient.getServerInfo();
                const rpcTime = Date.now() - startTime;
                log(`RPCå¿œç­”æ™‚é–“: ${rpcTime}ms`, 'success');
                
                // Test Explorer API
                const apiStart = Date.now();
                const response = await fetchWithTimeout('https://api-tn10.kaspa.org/info/health', {}, 5000, 1); // 5s timeout, 1 retry for health check
                const apiTime = Date.now() - apiStart;
                log(`Explorer APIå¿œç­”æ™‚é–“: ${apiTime}ms`, 'success');
                
                alert(`æ¥ç¶šãƒ†ã‚¹ãƒˆæˆåŠŸ!\nRPC: ${rpcTime}ms\nAPI: ${apiTime}ms`);
                
            } catch (error) {
                log(`æ¥ç¶šãƒ†ã‚¹ãƒˆã‚¨ãƒ©ãƒ¼: ${error.message}`, 'error');
            }
        };

        // File handling
        window.handleFileSelect = async function(event) {
            // Clear directory mode
            window.isDirectoryMode = false;
            const uploadDirOption = document.getElementById('uploadDirMetadataOption');
            if (uploadDirOption) {
                uploadDirOption.style.display = 'none';
            }
            const file = event.target.files[0];
            if (!file) return;
            
            currentFile = file;
            log(`ãƒ•ã‚¡ã‚¤ãƒ«é¸æŠ: ${file.name} (${(file.size/1024).toFixed(1)}KB)`);
            
            // Auto-detect progress file from workspace
            if (!window.pendingProgress && progressFileMap.has(file.name)) {
                const progressInfo = progressFileMap.get(file.name);
                log(`é€²æ—ãƒ•ã‚¡ã‚¤ãƒ«ã‚’è‡ªå‹•æ¤œå‡º: ${progressInfo.progressFilename}`, 'info');
                
                try {
                    // Load the progress file
                    const progressFile = await progressInfo.fileHandle.getFile();
                    const content = await progressFile.text();
                    const progress = JSON.parse(content);
                    
                    // Verify CID matches (calculate from first chunk)
                    const chunkSize = parseInt(document.getElementById('chunkSize').value) * 1024;
                    const actualChunkSize = calculateSafePayloadSize(chunkSize);
                    const firstChunkEnd = Math.min(actualChunkSize, file.size);
                    const firstChunkBlob = file.slice(0, firstChunkEnd);
                    const firstChunkArrayBuffer = await firstChunkBlob.arrayBuffer();
                    const firstChunkData = new Uint8Array(firstChunkArrayBuffer);
                    const firstChunkHash = await sha256(firstChunkData);
                    const calculatedCID = firstChunkHash.substring(0, 8);
                    
                    if (calculatedCID === progressInfo.cid) {
                        log(`CIDæ¤œè¨¼æˆåŠŸ: ${calculatedCID}`, 'success');
                        window.pendingProgress = progress;
                        window.currentFileCID = progressInfo.cid;
                        
                        // Show auto-resume notification
                        // å®Œäº†ãƒã‚§ãƒƒã‚¯
                        if (progress.metadata.completedChunks >= progress.metadata.totalChunks) {
                            log(`å®Œäº†æ¸ˆã¿ãƒ•ã‚¡ã‚¤ãƒ«ã‚’æ¤œå‡º: ${file.name}`, 'info');
                            // TODO: å±¥æ­´ã«ç§»å‹•ã—ã¦.kprogresså‰Šé™¤
                            return;
                        }
                        
                        const resumeConfirm = confirm(
                            `é€²æ—ãƒ•ã‚¡ã‚¤ãƒ«ã‚’è‡ªå‹•æ¤œå‡ºã—ã¾ã—ãŸï¼\n\n` +
                            `ãƒ•ã‚¡ã‚¤ãƒ«: ${file.name}\n` +
                            `é€²æ—: ${progress.metadata.completedChunks}/${progress.metadata.totalChunks} ãƒãƒ£ãƒ³ã‚¯\n` +
                            `CID: ${progressInfo.cid}\n\n` +
                            `ãƒ¬ã‚¸ãƒ¥ãƒ¼ãƒ ã—ã¾ã™ã‹ï¼Ÿ`
                        );
                        
                        if (!resumeConfirm) {
                            window.pendingProgress = null;
                            log('è‡ªå‹•ãƒ¬ã‚¸ãƒ¥ãƒ¼ãƒ ã‚’ã‚­ãƒ£ãƒ³ã‚»ãƒ«ã—ã¾ã—ãŸ', 'info');
                        }
                    } else {
                        log(`CIDä¸ä¸€è‡´: æœŸå¾…=${progressInfo.cid}, å®Ÿéš›=${calculatedCID}`, 'warning');
                        log('ç•°ãªã‚‹ãƒ•ã‚¡ã‚¤ãƒ«ã®å¯èƒ½æ€§ãŒã‚ã‚Šã¾ã™', 'warning');
                    }
                } catch (error) {
                    log(`é€²æ—ãƒ•ã‚¡ã‚¤ãƒ«è‡ªå‹•èª­ã¿è¾¼ã¿ã‚¨ãƒ©ãƒ¼: ${error.message}`, 'error');
                }
            }
            
            // Check if we have pending progress for this file
            if (window.pendingProgress) {
                const chunkSize = parseInt(document.getElementById('chunkSize').value) * 1024;
                // Use CID from progress if available
                const cid = window.currentFileCID || window.pendingProgress.cid || null;
                progressManager = new ProgressManager(file, chunkSize, cid, 'upload');
                
                if (progressManager.validateProgress(window.pendingProgress)) {
                    // Initialize with existing progress
                    await progressManager.initialize(window.pendingProgress);
                    
                    // Update UI to show resume status
                    const stats = progressManager.getStats();
                    const label = document.querySelector('.file-input-label');
                    label.innerHTML = `
                        <strong>${file.name}</strong><br>
                        ${(file.size/1024/1024).toFixed(2)}MB<br>
                        <span class="success">ãƒ¬ã‚¸ãƒ¥ãƒ¼ãƒ : ${stats.percentage}% å®Œäº†</span>
                    `;
                    
                    log(`ãƒ¬ã‚¸ãƒ¥ãƒ¼ãƒ æº–å‚™å®Œäº†: ${stats.completed}/${stats.total} ãƒãƒ£ãƒ³ã‚¯å®Œäº†`, 'success');
                    
                    // Clear pending progress
                    window.pendingProgress = null;
                    document.getElementById('resumeInfo').style.display = 'none';
                } else {
                    log('é€²æ—ãƒ•ã‚¡ã‚¤ãƒ«ãŒé¸æŠã•ã‚ŒãŸãƒ•ã‚¡ã‚¤ãƒ«ã¨ä¸€è‡´ã—ã¾ã›ã‚“', 'error');
                    progressManager = null;
                }
            } else {
                // Update UI for new upload
                const label = document.querySelector('.file-input-label');
                label.innerHTML = `
                    <strong>${file.name}</strong><br>
                    ${(file.size/1024/1024).toFixed(2)}MB
                `;
                
                // Show normal file upload UI
                const uploadDirOption2 = document.getElementById('uploadDirMetadataOption');
                if (uploadDirOption2) {
                    uploadDirOption2.style.display = 'none';
                }
            }
        };
        
        // Directory handling
        window.handleDirectorySelect = async function(event) {
            const files = Array.from(event.target.files);
            if (files.length === 0) return;
            
            // Set directory mode
            window.isDirectoryMode = true;
            window.selectedDirectory = {
                files: files,
                name: files[0].webkitRelativePath.split('/')[0] || 'directory'
            };
            
            // Calculate directory stats
            const totalSize = files.reduce((sum, file) => sum + file.size, 0);
            const fileCount = files.filter(f => f.type || f.size > 0).length;
            const dirCount = new Set(files.map(f => f.webkitRelativePath.split('/').slice(0, -1).join('/'))).size;
            
            log(`ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªé¸æŠ: ${window.selectedDirectory.name}`);
            log(`ãƒ•ã‚¡ã‚¤ãƒ«æ•°: ${fileCount}, ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªæ•°: ${dirCount}, åˆè¨ˆã‚µã‚¤ã‚º: ${(totalSize/1024/1024).toFixed(2)}MB`);
            
            // Update UI
            const label = document.querySelectorAll('.file-input-label')[1]; // Directory label
            label.innerHTML = `
                <strong>ğŸ“‚ ${window.selectedDirectory.name}</strong><br>
                ãƒ•ã‚¡ã‚¤ãƒ«: ${fileCount} | ã‚µã‚¤ã‚º: ${(totalSize/1024/1024).toFixed(2)}MB
            `;
            
            // Show directory upload options
            const uploadDirOption3 = document.getElementById('uploadDirMetadataOption');
            if (uploadDirOption3) {
                uploadDirOption3.style.display = 'block';
            }
            
            // Enable upload button after directory selection
            document.getElementById('uploadBtn').disabled = false;
            console.log('âœ… ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ãƒœã‚¿ãƒ³ã‚’æœ‰åŠ¹åŒ–ã—ã¾ã—ãŸ (ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªãƒ¢ãƒ¼ãƒ‰)');
            
            // Create directory tree preview
            const treeHtml = createDirectoryTreeHTML(files);
            if (document.getElementById('directoryTree')) {
                document.getElementById('directoryTree').innerHTML = treeHtml;
            }
        };
        
        // Create directory tree HTML for preview
        function createDirectoryTreeHTML(files) {
            const tree = {};
            
            // Build tree structure
            files.forEach(file => {
                const parts = file.webkitRelativePath.split('/');
                let current = tree;
                
                parts.forEach((part, index) => {
                    if (index === parts.length - 1) {
                        // File
                        current[part] = {
                            type: 'file',
                            size: file.size
                        };
                    } else {
                        // Directory
                        if (!current[part]) {
                            current[part] = {
                                type: 'directory',
                                children: {}
                            };
                        }
                        current = current[part].children;
                    }
                });
            });
            
            // Convert to HTML
            function renderTree(node, level = 0) {
                let html = '';
                const indent = '  '.repeat(level);
                
                Object.entries(node).forEach(([name, item]) => {
                    if (item.type === 'directory') {
                        html += `${indent}ğŸ“ ${name}/\n`;
                        html += renderTree(item.children, level + 1);
                    } else {
                        html += `${indent}ğŸ“„ ${name} (${(item.size/1024).toFixed(1)}KB)\n`;
                    }
                });
                
                return html;
            }
            
            return renderTree(tree);
        };
        
        // Process and upload directory
        window.processAndUploadDirectory = async function() {
            if (!window.selectedDirectory) {
                log('ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªãŒé¸æŠã•ã‚Œã¦ã„ã¾ã›ã‚“', 'error');
                return;
            }
            
            const password = document.getElementById('uploadPassword').value;
            if (password.length < 8) {
                log('ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ã¯8æ–‡å­—ä»¥ä¸Šå¿…è¦ã§ã™', 'error');
                return;
            }
            
            if (!rpcClient) {
                log('å…ˆã«ã‚·ã‚¹ãƒ†ãƒ ã‚’åˆæœŸåŒ–ã—ã¦ãã ã•ã„', 'error');
                return;
            }
            
            document.getElementById('uploadBtn').disabled = true;
            document.getElementById('uploadProgress').style.display = 'block';
            
            try {
                const files = window.selectedDirectory.files;
                const dirName = window.selectedDirectory.name;
                
                log(`ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰é–‹å§‹: ${dirName}`);
                log(`ç·ãƒ•ã‚¡ã‚¤ãƒ«æ•°: ${files.length}`);
                
                // Upload all files
                const uploadedFiles = [];
                const failedFiles = [];
                let totalCost = 0;
                
                for (let i = 0; i < files.length; i++) {
                    const file = files[i];
                    const relativePath = file.webkitRelativePath;
                    
                    // Skip empty files and directories
                    if (file.size === 0) {
                        log(`ã‚¹ã‚­ãƒƒãƒ— (ç©ºãƒ•ã‚¡ã‚¤ãƒ«): ${relativePath}`, 'warning');
                        continue;
                    }
                    
                    log(`\nãƒ•ã‚¡ã‚¤ãƒ« ${i + 1}/${files.length}: ${relativePath}`);
                    
                    try {
                        // Upload individual file
                        currentFile = file;
                        currentPassword = password;
                        processedChunks = [];
                        
                        // Generate file CID
                        const useRandomCid = document.getElementById('useRandomCid').checked;
                        const chunkSize = parseInt(document.getElementById('chunkSize').value) * 1024;
                        let fileCID = '';
                        
                        if (useRandomCid) {
                            fileCID = generateRandomCID();
                        } else {
                            const actualChunkSize = calculateSafePayloadSize(chunkSize);
                            const firstChunkEnd = Math.min(actualChunkSize, file.size);
                            const firstChunkBlob = file.slice(0, firstChunkEnd);
                            const firstChunkArrayBuffer = await firstChunkBlob.arrayBuffer();
                            const firstChunkData = new Uint8Array(firstChunkArrayBuffer);
                            const firstChunkHash = await sha256(firstChunkData);
                            fileCID = firstChunkHash.substring(0, 8);
                        }
                        
                        // Create progress manager for this file
                        const fileProgressManager = new ProgressManager(file, chunkSize, fileCID, 'upload');
                        await fileProgressManager.initialize();
                        
                        // Upload file chunks (reuse existing upload logic)
                        const fileResult = await uploadFileChunks(file, password, fileProgressManager);
                        
                        if (fileResult.success) {
                            uploadedFiles.push({
                                name: relativePath.split('/').pop(),
                                path: relativePath,
                                type: 'file',
                                metaTxId: fileResult.metaTxId || fileResult.chunks[0].txid,
                                blockId: fileResult.metaTxBlockId || fileResult.chunks[0].blockId,
                                size: file.size,
                                chunks: fileResult.chunks.length,
                                cost: fileResult.cost
                            });
                            totalCost += fileResult.cost;
                            log(`âœ… ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰å®Œäº†: ${relativePath}`, 'success');
                        } else {
                            throw new Error(fileResult.error || 'ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰å¤±æ•—');
                        }
                        
                    } catch (error) {
                        log(`âŒ ã‚¨ãƒ©ãƒ¼: ${relativePath} - ${error.message}`, 'error');
                        failedFiles.push({
                            path: relativePath,
                            error: error.message
                        });
                    }
                    
                    // Update progress
                    const progressPercent = Math.round(((i + 1) / files.length) * 100);
                    document.getElementById('uploadProgressBar').style.width = progressPercent + '%';
                    document.getElementById('uploadProgressBar').textContent = `${progressPercent}% - ${i + 1}/${files.length} ãƒ•ã‚¡ã‚¤ãƒ«`;
                }
                
                // Create directory metadata
                const dirMetadata = await createDirectoryMetadata(dirName, uploadedFiles, password);
                
                // Optionally upload directory metadata to blockchain
                let dirMetaTxId = null;
                let dirMetaBlockId = null;
                
                if (document.getElementById('uploadDirMetadata').checked) {
                    log('\nãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿ã‚’ãƒ–ãƒ­ãƒƒã‚¯ãƒã‚§ãƒ¼ãƒ³ã«ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ä¸­...');
                    const metaResult = await uploadDirectoryMetadata(dirMetadata, password);
                    if (metaResult.success) {
                        dirMetaTxId = metaResult.txid;
                        dirMetaBlockId = metaResult.blockId;
                        totalCost += metaResult.cost;
                        log(`âœ… ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰å®Œäº†: ${dirMetaTxId}`, 'success');
                    }
                }
                
                // Add to history
                const uploadData = {
                    id: `dir_${Date.now()}`,
                    type: 'directory',
                    name: dirName,
                    uploadDate: new Date().toISOString(),
                    fileCount: uploadedFiles.length,
                    failedCount: failedFiles.length,
                    totalSize: uploadedFiles.reduce((sum, f) => sum + f.size, 0),
                    totalCost: totalCost,
                    metaTxId: dirMetaTxId,
                    metaTxBlockId: dirMetaBlockId,
                    password: password,
                    metadata: dirMetadata,
                    entries: uploadedFiles,
                    failedFiles: failedFiles,
                    network: config.network
                };
                
                await window.historyManager.addUpload(uploadData);
                
                // Show completion summary
                log(`\nğŸ‰ ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰å®Œäº†!`, 'success');
                log(`æˆåŠŸ: ${uploadedFiles.length} ãƒ•ã‚¡ã‚¤ãƒ«`);
                if (failedFiles.length > 0) {
                    log(`å¤±æ•—: ${failedFiles.length} ãƒ•ã‚¡ã‚¤ãƒ«`, 'error');
                }
                log(`ç·ã‚³ã‚¹ãƒˆ: ${totalCost.toFixed(8)} KAS`);
                
                // Update history UI
                window.historyManager.updateHistoryUI();
                
            } catch (error) {
                log(`ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ã‚¨ãƒ©ãƒ¼: ${error.message}`, 'error');
            } finally {
                document.getElementById('uploadBtn').disabled = false;
                document.getElementById('uploadProgress').style.display = 'none';
            }
        };
        
        // Create directory metadata in .kaspa format
        async function createDirectoryMetadata(dirName, uploadedFiles, password) {
            // Calculate merkle root of entries
            const entriesData = JSON.stringify(uploadedFiles.map(f => ({
                name: f.name,
                metaTxId: f.metaTxId,
                blockId: f.blockId,
                size: f.size
            })));
            const merkleRoot = await sha256(new TextEncoder().encode(entriesData));
            
            // Generate salt from directory name + merkleRoot (deterministic and beautiful)
            const saltData = new TextEncoder().encode(dirName + merkleRoot);
            const saltHash = await sha256(saltData);
            const salt = new Uint8Array(saltHash.match(/.{2}/g).map(byte => parseInt(byte, 16))).slice(0, 16);
            
            const metadata = {
                type: 'kaspa-directory',
                version: '3.1.1',
                created: new Date().toISOString(),
                network: config.network,
                
                // Encryption at top level (consistent with files)
                encryption: {
                    algorithm: 'AES-256-GCM',
                    pbkdf2: {
                        salt: toBase64(salt),
                        iterations: 100000
                    }
                },
                
                // Directory-specific information
                directory: {
                    name: dirName,
                    totalSize: uploadedFiles.reduce((sum, f) => sum + f.size, 0),
                    fileCount: uploadedFiles.length,
                    directoryCount: new Set(uploadedFiles.map(f => f.path.split('/').slice(0, -1).join('/'))).size,
                    merkleRoot: merkleRoot
                },
                
                entries: uploadedFiles,
                
                // Recovery information (required for v3.1.1)
                recovery: {
                    totalFiles: uploadedFiles.length,
                    totalSize: uploadedFiles.reduce((sum, f) => sum + f.size, 0),
                    uploadCost: 0, // Will be calculated after upload
                    uploadDuration: null // Will be set after upload
                },
                
                metadata: {
                    metaTxId: null, // Will be set if uploaded
                    metaTxBlockId: null,
                    uploadDate: new Date().toISOString(),
                    blockTime: null,
                },
                
                auth: {
                    passwordIncluded: false,
                    password: null,
                    warning: null
                }
            };
            
            return metadata;
        }
        
        // Upload directory metadata to blockchain
        async function uploadDirectoryMetadata(metadata, password) {
            try {
                // Serialize metadata
                const metadataJson = JSON.stringify(metadata);
                const metadataBytes = new TextEncoder().encode(metadataJson);
                
                // Size check (20KB safety margin)
                const sizeKB = metadataBytes.length / 1024;
                if (metadataBytes.length > 20 * 1024) {
                    log(`âš ï¸ ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿ãŒå¤§ãã™ãã¾ã™ï¼ˆ${sizeKB.toFixed(1)}KBï¼‰`, 'warning');
                    log('ğŸ’¡ ãƒ’ãƒ³ãƒˆ: ãƒ•ã‚¡ã‚¤ãƒ«æ•°ã‚’æ¸›ã‚‰ã™ã‹ã€ã‚µãƒ–ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã«åˆ†å‰²ã—ã¦ãã ã•ã„', 'info');
                    log('ğŸ“ å°†æ¥ã®ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã§ãƒãƒ£ãƒ³ã‚¯åŒ–ã‚’ã‚µãƒãƒ¼ãƒˆäºˆå®šã§ã™', 'info');
                    
                    // Calculate approximate file limit
                    const approxFilesLimit = Math.floor((20 * 1024) / 150); // ~150 bytes per entry
                    log(`ğŸ“Š ç¾åœ¨ã®åˆ¶é™: ç´„${approxFilesLimit}ãƒ•ã‚¡ã‚¤ãƒ«ã¾ã§`, 'info');
                    
                    throw new Error(`ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿ãŒ20KBã‚’è¶…ãˆã¦ã„ã¾ã™ï¼ˆ${sizeKB.toFixed(1)}KBï¼‰`);
                }
                
                log(`ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿ã‚µã‚¤ã‚º: ${sizeKB.toFixed(2)}KB`, 'info');
                
                // TODO: Future v4.7.0 - Implement directory chunking for large metadata
                // if (metadataBytes.length > 20 * 1024) {
                //     return await uploadChunkedDirectoryMetadata(metadata, password);
                // }
                
                // Derive encryption key
                const salt = fromBase64(metadata.encryption.pbkdf2.salt);
                const key = await deriveKey(password, salt);
                
                // Encrypt metadata
                const encryptedData = await encryptChunk(metadataBytes, key, -1); // Use -1 for directory metadata
                
                // Prepend salt to encrypted data (critical for decryption)
                const payloadWithSalt = new Uint8Array(salt.length + encryptedData.length);
                payloadWithSalt.set(salt);
                payloadWithSalt.set(encryptedData, salt.length);
                
                // Compress if beneficial
                let finalData = payloadWithSalt;
                const compressed = lzCompress(payloadWithSalt);
                if (compressed.length < payloadWithSalt.length) {
                    finalData = compressed;
                    metadata.compression.algorithm = 'lz';
                    metadata.compression.originalSize = payloadWithSalt.length;
                    metadata.compression.compressedSize = compressed.length;
                }
                
                // Create transaction
                const payload = toBase64(finalData);
                const transaction = await createTransaction(payload);
                
                // Send transaction
                const txid = await sendTransaction(transaction);
                
                // Add to monitoring list
                uploadingDirMeta = true;
                monitoredTransactions.set(txid, {
                    type: 'directory-meta',
                    timestamp: Date.now(),
                    blockId: null
                });
                log(`[DEBUG] WebSocketç›£è¦–ãƒªã‚¹ãƒˆã«è¿½åŠ : TxID: ${txid.substring(0, 16)}... (ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿)`, 'debug');
                
                // Wait for confirmation
                const blockId = await waitForConfirmation(txid);
                
                // Remove from monitoring list
                monitoredTransactions.delete(txid);
                uploadingDirMeta = false;
                log(`[DEBUG] WebSocketç›£è¦–ãƒªã‚¹ãƒˆã‹ã‚‰å‰Šé™¤: TxID: ${txid.substring(0, 16)}... (BlockIDå–å¾—æ¸ˆã¿)`, 'debug');
                checkMonitoringStop();
                
                return {
                    success: true,
                    txid: txid,
                    blockId: blockId,
                    cost: 0.00021 // Base transaction cost
                };
                
            } catch (error) {
                log(`ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ã‚¨ãƒ©ãƒ¼: ${error.message}`, 'error');
                // Clean up on error
                uploadingDirMeta = false;
                checkMonitoringStop();
                return {
                    success: false,
                    error: error.message
                };
            }
        }
        
        // Reuse existing file upload logic for directory files
        async function uploadFileChunks(file, password, progressManager) {
            // This function extracts the core upload logic from processAndUpload
            // Returns: { success, chunks, metaTxId, metaTxBlockId, cost, error }
            try {
                const chunks = [];
                const totalChunks = progressManager.progress.metadata.totalChunks;
                const chunkSize = progressManager.chunkSize;
                
                // Get file hash
                let fileHash;
                if (file.size < 10 * 1024 * 1024) {
                    const data = new Uint8Array(await file.arrayBuffer());
                    fileHash = await sha256(data);
                } else {
                    const firstChunk = await file.slice(0, 1024 * 1024).arrayBuffer();
                    const lastChunk = await file.slice(-1024 * 1024).arrayBuffer();
                    const combined = new Uint8Array(firstChunk.byteLength + lastChunk.byteLength);
                    combined.set(new Uint8Array(firstChunk), 0);
                    combined.set(new Uint8Array(lastChunk), firstChunk.byteLength);
                    fileHash = await sha256(combined);
                }
                
                // Derive encryption key
                const salt = new Uint8Array(fileHash.match(/.{2}/g).map(byte => parseInt(byte, 16))).slice(0, 16);
                const key = await deriveKey(password, salt);
                
                // Upload chunks
                let totalCost = 0;
                for (let i = 0; i < totalChunks; i++) {
                    if (progressManager.isChunkCompleted(i)) {
                        // Find the chunk with matching index
                        const existingChunk = progressManager.progress.chunks.find(c => c.index === i);
                        if (existingChunk) {
                            chunks.push(existingChunk);
                            continue;
                        }
                    }
                    
                    const start = i * chunkSize;
                    const end = Math.min(start + chunkSize, file.size);
                    const chunkBlob = file.slice(start, end);
                    const chunkData = new Uint8Array(await chunkBlob.arrayBuffer());
                    
                    // Compress if needed
                    let processedData = chunkData;
                    if (shouldCompress(file.name)) {
                        processedData = lzCompress(chunkData);
                    }
                    
                    // Encrypt
                    const encryptedData = await encryptChunk(processedData, key, i);
                    
                    // Create and send transaction
                    const payload = toBase64(encryptedData);
                    const transaction = await createTransaction(payload);
                    const txid = await sendTransaction(transaction);
                    const blockId = await waitForConfirmation(txid);
                    
                    const chunkInfo = {
                        index: i,
                        txid: txid,
                        blockId: blockId,
                        size: chunkData.length,
                        compressedSize: processedData.length
                    };
                    
                    chunks.push(chunkInfo);
                    await progressManager.markChunkComplete(i, txid, blockId, chunkData.length);
                    totalCost += 0.00021;
                }
                
                // Check if meta-tx is needed
                let metaTxId = null;
                let metaTxBlockId = null;
                
                if (document.getElementById('useMetaTx').checked && chunks.length > 1) {
                    // Create and upload meta-tx
                    const metaTxData = {
                        version: '2.1',
                        type: 'meta-tx',
                        created: Date.now(),
                        fileName: file.name,
                        fileSize: file.size,
                        fileSha256: fileHash,
                        chunks: chunks.map(c => ({ t: c.txid, b: c.blockId }))
                    };
                    
                    const metaTxJson = JSON.stringify(metaTxData);
                    const metaTxBytes = new TextEncoder().encode(metaTxJson);
                    const encryptedMetaTx = await encryptChunk(metaTxBytes, key, -1);
                    
                    const metaTxPayload = toBase64(encryptedMetaTx);
                    const metaTxTransaction = await createTransaction(metaTxPayload);
                    metaTxId = await sendTransaction(metaTxTransaction);
                    metaTxBlockId = await waitForConfirmation(metaTxId);
                    totalCost += 0.00021;
                }
                
                return {
                    success: true,
                    chunks: chunks,
                    metaTxId: metaTxId,
                    metaTxBlockId: metaTxBlockId,
                    cost: totalCost
                };
                
            } catch (error) {
                return {
                    success: false,
                    error: error.message
                };
            }
        };
        
        // Transaction helper functions for directory upload
        async function createTransaction(payloadBase64) {
            // Get UTXOs
            const { entries } = await rpcClient.getUtxosByAddresses([address.toString()]);
            if (!entries || entries.length === 0) {
                throw new Error('åˆ©ç”¨å¯èƒ½ãªUTXOãŒã‚ã‚Šã¾ã›ã‚“');
            }
            
            // Format UTXOs
            const formattedUtxos = entries.map(utxo => ({
                address: address.toString(),
                outpoint: {
                    transactionId: utxo.outpoint.transactionId,
                    index: utxo.outpoint.index
                },
                scriptPublicKey: utxo.scriptPublicKey,
                amount: BigInt(utxo.amount),
                isCoinbase: utxo.isCoinbase || false,
                blockDaaScore: BigInt(utxo.blockDaaScore)
            }));
            
            // Decode payload to bytes
            const payloadBytes = fromBase64(payloadBase64);
            
            // Create transaction
            const result = await kaspa.createTransactions({
                entries: formattedUtxos,
                outputs: [{
                    address: address.toString(),
                    amount: 100000000n // 1 KAS
                }],
                changeAddress: address.toString(),
                priorityFee: 10000n,
                networkId: config.network,
                payload: payloadBytes
            });
            
            if (!result.transactions || result.transactions.length === 0) {
                throw new Error('ãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³ã®ä½œæˆã«å¤±æ•—ã—ã¾ã—ãŸ');
            }
            
            return result.transactions[0];
        }
        
        async function sendTransaction(transaction) {
            // Sign transaction
            await transaction.sign([privateKey]);
            
            // Submit transaction with error handling
            try {
                const txid = await transaction.submit(rpcClient);
                
                if (!txid) {
                    throw new Error('ãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³ã®é€ä¿¡ã«å¤±æ•—ã—ã¾ã—ãŸ');
                }
                
                return txid;
            } catch (error) {
                // Handle connection errors
                if (error.message && error.message.includes('not connected')) {
                    log('WebSocketæ¥ç¶šãŒåˆ‡æ–­ã•ã‚Œã¾ã—ãŸã€‚å†æ¥ç¶šã‚’è©¦ã¿ã¾ã™...', 'warning');
                    
                    // Reconnect
                    await rpcClient.connect();
                    log('RPCå†æ¥ç¶šæˆåŠŸ', 'success');
                    
                    // Restart monitoring
                    if (wsMonitorActive) {
                        await startMonitoring();
                    }
                    
                    // Retry transaction submission
                    const txid = await transaction.submit(rpcClient);
                    
                    if (!txid) {
                        throw new Error('ãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³ã®é€ä¿¡ã«å¤±æ•—ã—ã¾ã—ãŸï¼ˆå†è©¦è¡Œå¾Œï¼‰');
                    }
                    
                    return txid;
                }
                
                // Re-throw other errors
                throw error;
            }
        }
        
        async function waitForConfirmation(txid) {
            log(`[DEBUG] waitForConfirmationé–‹å§‹ - TxID: ${txid.substring(0, 16)}...`, 'debug');
            
            // Try WebSocket monitoring first
            if (rpcClient && wsMonitorActive) {
                log(`[DEBUG] WebSocketç›£è¦–ã‚’ä½¿ç”¨ã—ã¦BlockIDã‚’å¾…æ©Ÿ`, 'debug');
                return new Promise((resolve) => {
                    const timeout = setTimeout(() => {
                        log(`[DEBUG] WebSocketã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆ (60ç§’) - Explorer APIã«ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯`, 'warning');
                        // Fallback to Explorer API
                        fetchBlockIdFromExplorer(txid).then(resolve);
                    }, 60000); // 60 second timeout
                    
                    // Store callback for WebSocket response
                    if (!window.pendingBlockIds) {
                        window.pendingBlockIds = new Map();
                    }
                    window.pendingBlockIds.set(txid, (blockId) => {
                        log(`[DEBUG] WebSocketã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯å®Ÿè¡Œ - BlockID: ${blockId.substring(0, 16)}...`, 'success');
                        clearTimeout(timeout);
                        resolve(blockId);
                    });
                    log(`[DEBUG] pendingBlockIdsã«ã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯ç™»éŒ²å®Œäº†`, 'debug');
                });
            }
            
            log(`[DEBUG] WebSocketæœªä½¿ç”¨ - ç›´æ¥Explorer APIã‚’ä½¿ç”¨`, 'debug');
            // Fallback to Explorer API
            return await fetchBlockIdFromExplorer(txid);
        }
        
        async function fetchBlockIdFromExplorer(txid) {
            const maxRetries = 10;
            for (let i = 0; i < maxRetries; i++) {
                try {
                    const response = await fetchWithTimeout(
                        `https://api-tn10.kaspa.org/transactions/${txid}`,
                        {},
                        10000,
                        2
                    );
                    
                    if (response.ok) {
                        const data = await response.json();
                        if (data.block_id) {
                            return data.block_id;
                        }
                    }
                } catch (error) {
                    // Continue retrying
                }
                
                // Wait before retry
                await new Promise(resolve => setTimeout(resolve, 5000));
            }
            
            throw new Error(`BlockIDã®å–å¾—ã«å¤±æ•—: ${txid}`);
        }

        // Compression logic
        const COMPRESS_SKIP = new Set(['jpg','jpeg','png','gif','webp','mp4','avi','mov','mp3','wav','zip','rar','pdf']);
        
        function shouldCompress(filename) {
            const ext = filename.split('.').pop()?.toLowerCase() || '';
            return !COMPRESS_SKIP.has(ext);
        }

        // LZ compression
        function lzCompress(data) {
            const result = [];
            let i = 0;
            while (i < data.length) {
                let bestLen = 0, bestOff = 0;
                const start = Math.max(0, i - 255);
                for (let j = start; j < i; j++) {
                    let len = 0;
                    while (i + len < data.length && data[j + len] === data[i + len] && len < 255) len++;
                    if (len > bestLen) {
                        bestLen = len;
                        bestOff = i - j;
                    }
                }
                if (bestLen > 3) {
                    result.push(255, bestOff, bestLen);
                    i += bestLen;
                } else {
                    result.push(data[i]);
                    i++;
                }
            }
            return new Uint8Array(result);
        }

        function lzDecompress(data) {
            const result = [];
            let i = 0;
            while (i < data.length) {
                if (data[i] === 255 && i + 2 < data.length) {
                    const off = data[i + 1];
                    const len = data[i + 2];
                    const start = result.length - off;
                    for (let j = 0; j < len; j++) {
                        result.push(result[start + j]);
                    }
                    i += 3;
                } else {
                    result.push(data[i]);
                    i++;
                }
            }
            return new Uint8Array(result);
        }

        // Encryption
        async function deriveKey(password, salt, iterations = 100000) {
            const encoder = new TextEncoder();
            const keyMaterial = await crypto.subtle.importKey(
                'raw',
                encoder.encode(password),
                'PBKDF2',
                false,
                ['deriveKey']
            );
            
            return crypto.subtle.deriveKey(
                {
                    name: 'PBKDF2',
                    salt: salt,
                    iterations: iterations,
                    hash: 'SHA-256'
                },
                keyMaterial,
                { name: 'AES-GCM', length: 256 },
                false,
                ['encrypt', 'decrypt']
            );
        }

        async function encryptChunk(data, key, chunkIndex) {
            const iv = new Uint8Array(12);
            
            // Special handling for meta-tx (chunkIndex = -1)
            if (chunkIndex === -1) {
                // Use a special pattern for meta-tx
                iv[0] = 0xFF;
                iv[1] = 0xFF;
                for (let i = 2; i < 12; i++) {
                    iv[i] = 0xFF - i;
                }
            } else {
                iv[0] = (chunkIndex >> 8) & 0xFF;
                iv[1] = chunkIndex & 0xFF;
                for (let i = 2; i < 12; i++) {
                    iv[i] = i * 17;
                }
            }
            
            const encrypted = await crypto.subtle.encrypt(
                { name: 'AES-GCM', iv: iv },
                key,
                data
            );
            
            return new Uint8Array(encrypted);
        }

        async function decryptChunk(data, key, chunkIndex) {
            try {
                const iv = new Uint8Array(12);
                
                // Special handling for meta-tx (chunkIndex = -1)
                if (chunkIndex === -1) {
                    // Use a special pattern for meta-tx
                    iv[0] = 0xFF;
                    iv[1] = 0xFF;
                    for (let i = 2; i < 12; i++) {
                        iv[i] = 0xFF - i;
                    }
                } else {
                    iv[0] = (chunkIndex >> 8) & 0xFF;
                    iv[1] = chunkIndex & 0xFF;
                    for (let i = 2; i < 12; i++) {
                        iv[i] = i * 17;
                    }
                }
                
                log(`Decrypting chunk ${chunkIndex}: data length=${data.length}, IV=${Array.from(iv).map(b => b.toString(16).padStart(2, '0')).join(' ')}`, 'debug');
                
                const decrypted = await crypto.subtle.decrypt(
                    { name: 'AES-GCM', iv: iv },
                    key,
                    data
                );
                
                return new Uint8Array(decrypted);
            } catch (error) {
                log(`å¾©å·åŒ–ã‚¨ãƒ©ãƒ¼ (ãƒãƒ£ãƒ³ã‚¯ ${chunkIndex}): ${error.message || error}`, 'error');
                log(`ãƒ‡ãƒ¼ã‚¿ã‚µã‚¤ã‚º: ${data.length} bytes`, 'error');
                console.error('å¾©å·åŒ–ã‚¨ãƒ©ãƒ¼ã®è©³ç´°:', error);
                throw error;
            }
        }

        // Base64
        function toBase64(data) {
            return btoa(String.fromCharCode(...data));
        }

        function fromBase64(str) {
            return new Uint8Array(atob(str).split('').map(c => c.charCodeAt(0)));
        }

        // SHA256
        async function sha256(data) {
            const hash = await crypto.subtle.digest('SHA-256', data);
            return Array.from(new Uint8Array(hash))
                .map(b => b.toString(16).padStart(2, '0'))
                .join('');
        }

        // Calculate safe payload size based on storage mass limit
        function calculateSafePayloadSize(rawChunkSize) {
            // v4.7.30: å‹•çš„ãƒãƒ£ãƒ³ã‚¯ã‚µã‚¤ã‚ºæœ€é©åŒ–ï¼ˆç¬¬2æ®µéšï¼‰
            const KASPA_MAX_PAYLOAD = 24000; // Kaspaãƒšã‚¤ãƒ­ãƒ¼ãƒ‰ä¸Šé™
            const AES_GCM_OVERHEAD = 16;     // AES-256-GCMèªè¨¼ã‚¿ã‚°
            const SAFETY_MARGIN = 1000;      // å®‰å…¨ãƒãƒ¼ã‚¸ãƒ³ï¼ˆç´„1KBï¼‰
            
            // æœ€å¤§å®‰å…¨ãƒšã‚¤ãƒ­ãƒ¼ãƒ‰ = 24000 - 16 - 1000 = 22984ãƒã‚¤ãƒˆ â‰ˆ 22.4KB
            const MAX_SAFE_CHUNK_SIZE = KASPA_MAX_PAYLOAD - AES_GCM_OVERHEAD - SAFETY_MARGIN;
            
            // v4.7.30: ç¬¬2æ®µéš - 22KBå›ºå®šå€¤ã§ã®æ¤œè¨¼ï¼ˆå¤‰æ›´ãªã—ï¼‰
            if (rawChunkSize >= 22528) { // 22KB = 22 * 1024
                return 22528; // 22KBã«åˆ¶é™
            }
            
            return rawChunkSize; // ãã‚Œä»¥ä¸‹ã¯ãã®ã¾ã¾
        }
        
        // v4.7.30: ãƒ•ã‚¡ã‚¤ãƒ«ã‚¿ã‚¤ãƒ—åˆ¥ã®åœ§ç¸®ç‡äºˆæ¸¬
        function estimateCompressionRatio(fileName, mimeType) {
            // ãƒ•ã‚¡ã‚¤ãƒ«æ‹¡å¼µå­ã¨MIMEã‚¿ã‚¤ãƒ—ã‹ã‚‰åœ§ç¸®ç‡ã‚’äºˆæ¸¬
            const ext = fileName.toLowerCase().split('.').pop();
            
            // æ—¢ã«åœ§ç¸®ã•ã‚Œã¦ã„ã‚‹ãƒ•ã‚¡ã‚¤ãƒ«ï¼ˆåœ§ç¸®åŠ¹æœãªã—: 100%ï¼‰
            const compressedFormats = ['jpg', 'jpeg', 'png', 'gif', 'webp', 'mp3', 'mp4', 'avi', 'mov', 'zip', 'rar', '7z', 'gz', 'bz2'];
            if (compressedFormats.includes(ext)) {
                return 1.0; // åœ§ç¸®åŠ¹æœãªã—
            }
            
            // ãƒ†ã‚­ã‚¹ãƒˆãƒ™ãƒ¼ã‚¹ãƒ•ã‚¡ã‚¤ãƒ«ï¼ˆé«˜åœ§ç¸®ç‡: 30-50%ï¼‰
            const textFormats = ['txt', 'log', 'csv', 'json', 'xml', 'html', 'css', 'js', 'md', 'yml', 'yaml'];
            if (textFormats.includes(ext)) {
                return 0.4; // 60%åœ§ç¸®
            }
            
            // ã‚½ãƒ¼ã‚¹ã‚³ãƒ¼ãƒ‰ï¼ˆä¸­åœ§ç¸®ç‡: 40-60%ï¼‰
            const codeFormats = ['py', 'java', 'c', 'cpp', 'h', 'cs', 'php', 'rb', 'go', 'rs', 'swift'];
            if (codeFormats.includes(ext)) {
                return 0.5; // 50%åœ§ç¸®
            }
            
            // ãƒã‚¤ãƒŠãƒªãƒ•ã‚¡ã‚¤ãƒ«ï¼ˆä½åœ§ç¸®ç‡: 80-90%ï¼‰
            const binaryFormats = ['exe', 'dll', 'so', 'bin', 'dat'];
            if (binaryFormats.includes(ext)) {
                return 0.85; // 15%åœ§ç¸®
            }
            
            // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆï¼ˆä¸­ç¨‹åº¦ã®åœ§ç¸®ã‚’æƒ³å®šï¼‰
            return 0.7; // 30%åœ§ç¸®
        }
        
        // v4.7.30: å‹•çš„ãƒãƒ£ãƒ³ã‚¯ã‚µã‚¤ã‚ºè¨ˆç®—ï¼ˆåœ§ç¸®ç‡è€ƒæ…®ï¼‰
        function calculateOptimalChunkSize(baseChunkSize, fileName, mimeType, useCompression) {
            if (!useCompression) {
                // åœ§ç¸®ãªã—ã®å ´åˆã¯é€šå¸¸ã®è¨ˆç®—
                return calculateSafePayloadSize(baseChunkSize);
            }
            
            // åœ§ç¸®ç‡ã‚’äºˆæ¸¬
            const compressionRatio = estimateCompressionRatio(fileName, mimeType);
            
            // æš—å·åŒ–å¾Œã®ãƒšã‚¤ãƒ­ãƒ¼ãƒ‰ä¸Šé™ï¼ˆ22984ãƒã‚¤ãƒˆï¼‰ã‹ã‚‰é€†ç®—
            const MAX_ENCRYPTED_SIZE = 22984; // 24000 - 16 - 1000
            const MAX_COMPRESSED_SIZE = MAX_ENCRYPTED_SIZE - 16; // AES-GCM overhead
            
            // åœ§ç¸®å‰ã®æœ€å¤§ã‚µã‚¤ã‚ºã‚’è¨ˆç®—
            const maxOriginalSize = Math.floor(MAX_COMPRESSED_SIZE / compressionRatio);
            
            // è¦æ±‚ã•ã‚ŒãŸã‚µã‚¤ã‚ºã¨è¨ˆç®—ã•ã‚ŒãŸæœ€å¤§ã‚µã‚¤ã‚ºã®å°ã•ã„æ–¹ã‚’é¸æŠ
            const optimalSize = Math.min(baseChunkSize, maxOriginalSize);
            
            // ãƒ­ã‚°å‡ºåŠ›ï¼ˆ22KBä»¥ä¸Šã®å ´åˆã®ã¿ï¼‰
            if (baseChunkSize >= 22528) {
                log(`ğŸ“Š å‹•çš„ãƒãƒ£ãƒ³ã‚¯ã‚µã‚¤ã‚ºæœ€é©åŒ–:`);
                log(`  - ãƒ•ã‚¡ã‚¤ãƒ«ã‚¿ã‚¤ãƒ—: ${fileName} (${mimeType || 'unknown'})`);
                log(`  - äºˆæ¸¬åœ§ç¸®ç‡: ${(compressionRatio * 100).toFixed(1)}%`);
                log(`  - æœ€å¤§å¯èƒ½ã‚µã‚¤ã‚º: ${(maxOriginalSize / 1024).toFixed(1)}KB`);
                log(`  - æœ€é©åŒ–å¾Œã‚µã‚¤ã‚º: ${(optimalSize / 1024).toFixed(1)}KB`);
            }
            
            return calculateSafePayloadSize(optimalSize);
        }
        
        // New approach: Process file in streaming fashion and split after encryption
        async function processFileWithPayloadSplit(file, password, progressManager, useCompression) {
            // v4.7.56: é–¢æ•°é–‹å§‹ãƒ­ã‚°ã‚’è¿½åŠ 
            log('[processFileWithPayloadSplit] é–‹å§‹', 'info');
            
            try {
                const PROCESS_CHUNK_SIZE = 128 * 1024; // 128KB processing chunks
                const PAYLOAD_SIZE = 22 * 1024; // 22KB payloads
            
            // Generate proper salt using file hash
            let fileHash;
            if (file.size < 10 * 1024 * 1024) {
                const data = new Uint8Array(await file.arrayBuffer());
                fileHash = await sha256(data);
            } else {
                const firstChunk = await file.slice(0, 1024 * 1024).arrayBuffer();
                const lastChunk = await file.slice(-1024 * 1024).arrayBuffer();
                const combined = new Uint8Array(firstChunk.byteLength + lastChunk.byteLength);
                combined.set(new Uint8Array(firstChunk), 0);
                combined.set(new Uint8Array(lastChunk), firstChunk.byteLength);
                fileHash = await sha256(combined);
            }
            
            const saltBase = fileHash + file.name;
            const saltHash = await sha256(new TextEncoder().encode(saltBase));
            const salt = safeHexDecode(saltHash.substring(0, 32), 'salt generation');
            const key = await deriveKey(password, salt);
            
            // Update progress manager with encryption info
            progressManager.progress.encryption.salt = toBase64(salt);
            progressManager.progress.encryption.compressed = useCompression;
            progressManager.progress.metadata.payloadSplit = true; // New flag
            
            const payloads = [];
            const chunkBoundaries = []; // Track encrypted chunk boundaries
            let processedBytes = 0;
            let encryptedBuffer = new Uint8Array(0);
            let totalEncryptedBytes = 0;
            
            // Process file in chunks
            while (processedBytes < file.size) {
                const end = Math.min(processedBytes + PROCESS_CHUNK_SIZE, file.size);
                const blob = file.slice(processedBytes, end);
                const chunk = new Uint8Array(await blob.arrayBuffer());
                
                // Compress if needed
                const compressed = useCompression && shouldCompress(file.name) ? 
                    lzCompress(chunk) : chunk;
                
                // Encrypt (continuous stream)
                const chunkIndex = Math.floor(processedBytes / PROCESS_CHUNK_SIZE);
                const encrypted = await encryptChunk(compressed, key, chunkIndex);
                
                // Record chunk boundary
                chunkBoundaries.push({
                    index: chunkIndex,
                    offset: totalEncryptedBytes,
                    size: encrypted.length,
                    originalSize: chunk.length,
                    compressedSize: compressed.length
                });
                totalEncryptedBytes += encrypted.length;
                
                // Append to buffer
                const newBuffer = new Uint8Array(encryptedBuffer.length + encrypted.length);
                newBuffer.set(encryptedBuffer);
                newBuffer.set(encrypted, encryptedBuffer.length);
                encryptedBuffer = newBuffer;
                
                // Split into payloads if buffer is large enough
                while (encryptedBuffer.length >= PAYLOAD_SIZE) {
                    const payload = encryptedBuffer.slice(0, PAYLOAD_SIZE);
                    payloads.push(payload);
                    encryptedBuffer = encryptedBuffer.slice(PAYLOAD_SIZE);
                }
                
                processedBytes = end;
                log(`å‡¦ç†é€²æ—: ${(processedBytes / file.size * 100).toFixed(1)}%`);
            }
            
            // Add remaining data as final payload
            if (encryptedBuffer.length > 0) {
                payloads.push(encryptedBuffer);
            }
            
            log(`ãƒšã‚¤ãƒ­ãƒ¼ãƒ‰åˆ†å‰²å®Œäº†: ${payloads.length}å€‹ (å„${PAYLOAD_SIZE/1024}KBä»¥ä¸‹)`);
            
            // Update totalChunks to match payload count
            progressManager.progress.metadata.totalChunks = payloads.length;
            progressManager.progress.metadata.chunkBoundaries = chunkBoundaries; // Save boundaries
            await progressManager.saveProgress();
            
            // v4.7.56: é–¢æ•°å®Œäº†ãƒ­ã‚°ã‚’è¿½åŠ 
            log(`[processFileWithPayloadSplit] å®Œäº† - ${payloads.length}å€‹ã®ãƒšã‚¤ãƒ­ãƒ¼ãƒ‰ç”Ÿæˆ`, 'info');
            
            return { payloads, key, salt, chunkBoundaries };
            } catch (error) {
                // v4.7.57: ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°ã‚’è¿½åŠ 
                log(`[processFileWithPayloadSplit] ã‚¨ãƒ©ãƒ¼: ${error.message}`, 'error');
                log(`[processFileWithPayloadSplit] ã‚¹ã‚¿ãƒƒã‚¯: ${error.stack}`, 'error');
                throw error;
            }
        }
        
        // Check if transaction exists on blockchain
        async function verifyTransactionExists(txid, blockId = null) {
            try {
                // First try with blockId if available
                if (blockId) {
                    try {
                        const blockResponse = await rpcClient.getBlock({
                            hash: blockId,
                            includeTransactions: true
                        });
                        
                        const block = blockResponse?.block?.block || blockResponse?.block;
                        if (block && block.transactions) {
                            for (const tx of block.transactions) {
                                const txId = tx.verboseData?.transactionId || tx.id || tx.transactionId;
                                if (txId === txid) {
                                    log(`ãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³ç¢ºèª: ${txid.substring(0, 16)}...`, 'success');
                                    return true;
                                }
                            }
                        }
                    } catch (err) {
                        log(`ãƒ–ãƒ­ãƒƒã‚¯ç¢ºèªã‚¨ãƒ©ãƒ¼: ${err.message}`, 'warning');
                    }
                }
                
                // Fallback to Explorer API
                const apiUrl = `https://api-tn10.kaspa.org/transactions/${txid}`;
                const response = await fetchWithTimeout(apiUrl, {}, 10000, 2); // 10s timeout, 2 retries
                if (response.ok) {
                    log(`ãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³ç¢ºèª (API): ${txid.substring(0, 16)}...`, 'success');
                    return true;
                }
                
                return false;
            } catch (error) {
                log(`ãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³ç¢ºèªã‚¨ãƒ©ãƒ¼: ${error.message}`, 'error');
                return false;
            }
        }
        
        // Verify progress chunks still exist on blockchain
        async function verifyProgressChunks(progress) {
            if (!progress.chunks || progress.chunks.length === 0) {
                return true; // No chunks to verify
            }
            
            log(`æ—¢å­˜ãƒãƒ£ãƒ³ã‚¯ã®æ¤œè¨¼ã‚’é–‹å§‹: ${progress.chunks.length}å€‹`, 'info');
            const verifiedChunks = [];
            let failedCount = 0;
            
            // Check a sample of chunks (first, last, and some random ones)
            const indicesToCheck = [0, progress.chunks.length - 1];
            if (progress.chunks.length > 10) {
                // Add 3 random indices for larger files
                for (let i = 0; i < 3; i++) {
                    const randomIndex = Math.floor(Math.random() * progress.chunks.length);
                    if (!indicesToCheck.includes(randomIndex)) {
                        indicesToCheck.push(randomIndex);
                    }
                }
            } else {
                // Check all chunks for smaller files
                for (let i = 1; i < progress.chunks.length - 1; i++) {
                    indicesToCheck.push(i);
                }
            }
            
            for (const index of indicesToCheck.sort((a, b) => a - b)) {
                const chunk = progress.chunks[index];
                if (chunk && chunk.txid) {
                    const exists = await verifyTransactionExists(chunk.txid, chunk.blockId);
                    if (exists) {
                        verifiedChunks.push(index);
                    } else {
                        failedCount++;
                        log(`ãƒãƒ£ãƒ³ã‚¯ ${chunk.index + 1} ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“: ${chunk.txid.substring(0, 16)}...`, 'warning');
                    }
                }
            }
            
            if (failedCount > 0) {
                log(`è­¦å‘Š: ${failedCount}å€‹ã®ãƒãƒ£ãƒ³ã‚¯ãŒç¢ºèªã§ãã¾ã›ã‚“ã§ã—ãŸ`, 'warning');
                const continueUpload = confirm(
                    `ä¸€éƒ¨ã®ãƒãƒ£ãƒ³ã‚¯ãŒãƒ–ãƒ­ãƒƒã‚¯ãƒã‚§ãƒ¼ãƒ³ä¸Šã§ç¢ºèªã§ãã¾ã›ã‚“ã€‚\n` +
                    `ç¢ºèªæ¸ˆã¿: ${verifiedChunks.length}å€‹\n` +
                    `æœªç¢ºèª: ${failedCount}å€‹\n\n` +
                    `ç¶šè¡Œã—ã¾ã™ã‹ï¼Ÿï¼ˆæœªç¢ºèªãƒãƒ£ãƒ³ã‚¯ã¯å†ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ã•ã‚Œã¾ã™ï¼‰`
                );
                return continueUpload;
            }
            
            log(`ãƒãƒ£ãƒ³ã‚¯æ¤œè¨¼å®Œäº†: ã™ã¹ã¦ç¢ºèªæ¸ˆã¿`, 'success');
            return true;
        }
        
        // Process and upload file
        window.processAndUpload = async function() {
            // Check if directory mode
            if (window.isDirectoryMode) {
                await processAndUploadDirectory();
                return;
            }
            
            if (!currentFile) {
                log('ãƒ•ã‚¡ã‚¤ãƒ«ãŒé¸æŠã•ã‚Œã¦ã„ã¾ã›ã‚“', 'error');
                return;
            }
            
            const password = document.getElementById('uploadPassword').value;
            if (password.length < 8) {
                log('ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ã¯8æ–‡å­—ä»¥ä¸Šå¿…è¦ã§ã™', 'error');
                return;
            }
            
            if (!rpcClient) {
                log('å…ˆã«ã‚·ã‚¹ãƒ†ãƒ ã‚’åˆæœŸåŒ–ã—ã¦ãã ã•ã„', 'error');
                return;
            }
            
            currentPassword = password;
            processedChunks = [];
            
            document.getElementById('uploadBtn').disabled = true;
            const uploadProgressInit = document.getElementById('uploadProgress');
            if (uploadProgressInit) {
                uploadProgressInit.style.display = 'block';
                log('[DEBUG] uploadProgressè¦ç´ ã‚’è¡¨ç¤ºã—ã¾ã—ãŸ', 'debug');
            } else {
                log('[ERROR] uploadProgressè¦ç´ ãŒåˆæœŸåŒ–æ™‚ã«è¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ï¼', 'error');
            }
            
            try {
                // v3.6.3 fix: Set upload flag
                isUploadingFile = true;
                
                log(`å‡¦ç†é–‹å§‹: ${currentFile.name}`);
                log(`ãƒ•ã‚¡ã‚¤ãƒ«ã‚µã‚¤ã‚º: ${(currentFile.size / 1024 / 1024).toFixed(2)} MB`);
                
                // Generate CID early for progress manager
                let fileCID = '';
                const useRandomCid = document.getElementById('useRandomCid').checked;
                const chunkSize = parseInt(document.getElementById('chunkSize').value) * 1024;
                log(`ãƒãƒ£ãƒ³ã‚¯ã‚µã‚¤ã‚ºè¨­å®š: ${chunkSize / 1024} KB`);
                
                if (useRandomCid) {
                    fileCID = generateRandomCID();
                    log(`ãƒ©ãƒ³ãƒ€ãƒ CIDç”Ÿæˆ: ${fileCID}`, 'info');
                } else {
                    // Read first chunk to calculate CID
                    const actualChunkSize = calculateSafePayloadSize(chunkSize);
                    const firstChunkEnd = Math.min(actualChunkSize, currentFile.size);
                    const firstChunkBlob = currentFile.slice(0, firstChunkEnd);
                    const firstChunkArrayBuffer = await firstChunkBlob.arrayBuffer();
                    const firstChunkData = new Uint8Array(firstChunkArrayBuffer);
                    const firstChunkHash = await sha256(firstChunkData);
                    fileCID = firstChunkHash.substring(0, 8);
                    log(`æ±ºå®šè«–çš„CIDç”Ÿæˆ: ${fileCID}`, 'info');
                }
                
                // Store CID for later use
                window.currentFileCID = fileCID;
                
                // Initialize or use existing progress manager
                if (!progressManager) {
                    log('æ–°è¦ProgressManagerã‚’ä½œæˆä¸­...');
                    progressManager = new ProgressManager(currentFile, chunkSize, fileCID, 'upload');
                    await progressManager.initialize();
                    log(`ProgressManageråˆæœŸåŒ–å®Œäº† - ç·ãƒãƒ£ãƒ³ã‚¯æ•°: ${progressManager.progress.metadata.totalChunks}`);
                } else {
                    log(`æ—¢å­˜ã®ProgressManagerã‚’ä½¿ç”¨ - å®Œäº†æ¸ˆã¿: ${progressManager.progress.metadata.completedChunks}/${progressManager.progress.metadata.totalChunks}`);
                    
                    // Verify existing chunks on blockchain
                    const verified = await verifyProgressChunks(progressManager.progress);
                    if (!verified) {
                        log('ãƒãƒ£ãƒ³ã‚¯æ¤œè¨¼ã«å¤±æ•—ã—ãŸãŸã‚ã€ãƒ¬ã‚¸ãƒ¥ãƒ¼ãƒ ã‚’ã‚­ãƒ£ãƒ³ã‚»ãƒ«ã—ã¾ã™', 'error');
                        progressManager = null;
                        return;
                    }
                }
                
                // Get file hash for the entire file (expensive for large files, consider chunked hashing)
                let fileHash;
                if (currentFile.size < 10 * 1024 * 1024) { // Only hash small files completely
                    log('å°ã•ãªãƒ•ã‚¡ã‚¤ãƒ« - å…¨ä½“ã‚’ãƒãƒƒã‚·ãƒ¥åŒ–ä¸­...');
                    const data = new Uint8Array(await currentFile.arrayBuffer());
                    fileHash = await sha256(data);
                } else {
                    // For large files, hash first and last 1MB
                    log('å¤§ããªãƒ•ã‚¡ã‚¤ãƒ« - æœ€åˆã¨æœ€å¾Œã®1MBã‚’ãƒãƒƒã‚·ãƒ¥åŒ–ä¸­...');
                    const firstChunk = await currentFile.slice(0, 1024 * 1024).arrayBuffer();
                    const lastChunk = await currentFile.slice(-1024 * 1024).arrayBuffer();
                    const combined = new Uint8Array(firstChunk.byteLength + lastChunk.byteLength);
                    combined.set(new Uint8Array(firstChunk), 0);
                    combined.set(new Uint8Array(lastChunk), firstChunk.byteLength);
                    fileHash = await sha256(combined);
                }
                log(`ãƒ•ã‚¡ã‚¤ãƒ«ãƒãƒƒã‚·ãƒ¥: ${fileHash}`);
                
                // Compression strategy
                const useCompression = shouldCompress(currentFile.name);
                log(`åœ§ç¸®: ${useCompression ? 'æœ‰åŠ¹' : 'ç„¡åŠ¹'}`);
                
                // Generate salt
                const saltBase = fileHash + currentFile.name;
                const saltHash = await sha256(new TextEncoder().encode(saltBase));
                const salt = safeHexDecode(saltHash.substring(0, 32), 'salt generation');
                
                const key = await deriveKey(password, salt);
                
                // Update progress manager with encryption info
                progressManager.progress.encryption.salt = toBase64(salt);
                progressManager.progress.encryption.compressed = useCompression;
                
                // Get chunk size and apply safety limit
                const requestedChunkSize = parseInt(document.getElementById('chunkSize').value) * 1024;
                
                // v4.7.30: å‹•çš„ãƒãƒ£ãƒ³ã‚¯ã‚µã‚¤ã‚ºæœ€é©åŒ–ã‚’é©ç”¨
                let actualChunkSize;
                if (requestedChunkSize >= 20480) {
                    // å®Ÿé¨“çš„: åœ§ç¸®ç‡ã‚’è€ƒæ…®ã—ãŸå‹•çš„æœ€é©åŒ–
                    actualChunkSize = calculateOptimalChunkSize(
                        requestedChunkSize, 
                        currentFile.name, 
                        currentFile.type,
                        useCompression
                    );
                    
                    if (requestedChunkSize >= 22528) {
                        log(`ğŸš€ å‹•çš„æœ€é©åŒ–: ${(actualChunkSize/1024).toFixed(1)}KB ãƒãƒ£ãƒ³ã‚¯ã‚’ä½¿ç”¨`, 'warning');
                        log('ğŸ“Š ãƒšã‚¤ãƒ­ãƒ¼ãƒ‰åŠ¹ç‡: ' + ((actualChunkSize / 23984) * 100).toFixed(1) + '% (ç†è«–æœ€å¤§å€¤ã«å¯¾ã—ã¦)', 'info');
                        log('âš ï¸ ã“ã®æ©Ÿèƒ½ã¯å®Ÿé¨“çš„ã§ã™ã€‚å•é¡ŒãŒç™ºç”Ÿã—ãŸå ´åˆã¯12KBä»¥ä¸‹ã‚’é¸æŠã—ã¦ãã ã•ã„', 'warning');
                    } else {
                        log(`ğŸ§ª å®Ÿé¨“çš„æ©Ÿèƒ½: ${(actualChunkSize/1024).toFixed(1)}KB ãƒãƒ£ãƒ³ã‚¯ã‚’ä½¿ç”¨`, 'warning');
                        log('âš ï¸ ã“ã®æ©Ÿèƒ½ã¯å®Ÿé¨“çš„ã§ã™ã€‚å•é¡ŒãŒç™ºç”Ÿã—ãŸå ´åˆã¯12KBä»¥ä¸‹ã‚’é¸æŠã—ã¦ãã ã•ã„', 'warning');
                    }
                } else {
                    // é€šå¸¸: å®‰å…¨ãªã‚µã‚¤ã‚ºï¼ˆå¤‰æ›´ãªã—ï¼‰
                    actualChunkSize = calculateSafePayloadSize(requestedChunkSize);
                    if (actualChunkSize < requestedChunkSize) {
                        log(`ãƒãƒ£ãƒ³ã‚¯ã‚µã‚¤ã‚ºã‚’å®‰å…¨ãªå€¤ã«èª¿æ•´: ${(actualChunkSize/1024).toFixed(1)}KB`, 'warning');
                    }
                }
                
                const totalChunks = progressManager.progress.metadata.totalChunks;
                log(`ç·ãƒãƒ£ãƒ³ã‚¯æ•°: ${totalChunks}`);
                
                // Initial UTXO fetch
                let currentUtxos = null;
                
                // Start WebSocket monitoring for transaction confirmations
                if (!wsMonitorActive) {
                    log('WebSocketç›£è¦–ã‚’é–‹å§‹ã—ã¾ã™...', 'info');
                    await startMonitoring();
                } else {
                    log('WebSocketç›£è¦–ã¯æ—¢ã«å‹•ä½œä¸­ã§ã™', 'info');
                    // log(`ç¾åœ¨ç›£è¦–ä¸­ã®ãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³æ•°: ${monitoredTransactions.size}`, 'info');
                }
                
                
                // NEW: Process file with payload split approach
                const chunksList = document.getElementById('chunksList');
                chunksList.innerHTML = '';
                
                // Check if we need to use new approach
                const useNewApproach = actualChunkSize >= 22528; // Use new approach for 22KB chunks
                
                // v4.7.55: ãƒ‡ãƒãƒƒã‚°ãƒ­ã‚°ã‚’è¿½åŠ ï¼ˆæœ€å°é™ã®å¤‰æ›´ï¼‰
                if (actualChunkSize >= 22528) {
                    log(`[INFO] ãƒãƒ£ãƒ³ã‚¯ã‚µã‚¤ã‚º: ${actualChunkSize} - æ–°æ–¹å¼å¯¾è±¡`, 'info');
                }
                
                // Declare nextChunkIndex outside of if/else blocks
                let nextChunkIndex = -1;
                
                if (useNewApproach) {
                    log('ğŸš€ æ–°æ–¹å¼: æš—å·åŒ–å¾Œãƒšã‚¤ãƒ­ãƒ¼ãƒ‰åˆ†å‰²ã‚’ä½¿ç”¨', 'info');
                    
                    try {
                        // Process entire file and split into payloads
                        const { payloads, key: encKey, salt: encSalt, chunkBoundaries } = await processFileWithPayloadSplit(
                            currentFile, 
                            password, 
                            progressManager, 
                            useCompression
                        );
                    
                    // Upload each payload
                    for (let i = 0; i < payloads.length; i++) {
                        // Check if already uploaded
                        if (progressManager.isChunkCompleted(i)) {
                            log(`ãƒšã‚¤ãƒ­ãƒ¼ãƒ‰ ${i + 1}/${payloads.length} ã¯æ—¢ã«ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰æ¸ˆã¿`);
                            continue;
                        }
                        
                        // Get fresh UTXOs
                        const { entries } = await rpcClient.getUtxosByAddresses([address.toString()]);
                        if (!entries || entries.length === 0) {
                            throw new Error('åˆ©ç”¨å¯èƒ½ãªUTXOãŒã‚ã‚Šã¾ã›ã‚“');
                        }
                        
                        // Create UI element
                        const chunkDiv = document.createElement('div');
                        chunkDiv.className = 'chunk-item';
                        chunkDiv.innerHTML = `
                            <div>Payload ${i + 1}/${payloads.length} (${(payloads[i].length/1024).toFixed(1)}KB)</div>
                            <div class="chunk-status pending" id="chunk-status-${i}">
                                <span>å¾…æ©Ÿä¸­</span>
                            </div>
                        `;
                        chunksList.appendChild(chunkDiv);
                        
                        // Update status
                        const uploadingStatusElement = document.getElementById(`chunk-status-${i}`);
                        if (uploadingStatusElement) {
                            uploadingStatusElement.innerHTML = '<span class="uploading">ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ä¸­...</span>';
                        } else {
                            log(`[ERROR] chunk-status-${i} è¦ç´ ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ï¼ˆã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰é–‹å§‹æ™‚ï¼‰`, 'error');
                        }
                        
                        const payloadBytes = payloads[i];
                        log(`Payload ${i + 1} size: ${payloadBytes.length} bytes`);
                        
                        const uploadStartTime = Date.now();
                        
                        // Upload payload to blockchain
                        let txid = null;
                        let blockId = null;
                        let retries = 0;
                        
                        while (retries < config.retryCount && !txid) {
                            try {
                                // Check payload size
                                if (payloadBytes.length > 24000) {
                                    throw new Error(`Payload too large: ${payloadBytes.length} bytes (max 24000)`);
                                }
                                
                                // Create transaction
                                const formattedUtxos = entries.map(utxo => ({
                                    address: address.toString(),
                                    outpoint: {
                                        transactionId: utxo.outpoint.transactionId,
                                        index: utxo.outpoint.index
                                    },
                                    scriptPublicKey: utxo.scriptPublicKey,
                                    amount: BigInt(utxo.amount),
                                    isCoinbase: utxo.isCoinbase || false,
                                    blockDaaScore: BigInt(utxo.blockDaaScore)
                                }));
                                
                                const result = await kaspa.createTransactions({
                                    entries: formattedUtxos,
                                    outputs: [{
                                        address: address.toString(),
                                        amount: 100000000n // 1 KAS
                                    }],
                                    changeAddress: address.toString(),
                                    priorityFee: 10000n,
                                    networkId: config.network,
                                    payload: payloadBytes
                                });
                                
                                // Sign and submit
                                if (!result.transactions || result.transactions.length === 0) {
                                    throw new Error('No transactions generated');
                                }
                                
                                const pendingTx = result.transactions[0];
                                await pendingTx.sign([privateKey]);
                                txid = await pendingTx.submit(rpcClient);
                                
                                log(`ãƒšã‚¤ãƒ­ãƒ¼ãƒ‰ ${i + 1} TxID: ${txid.substring(0, 16)}...`, 'success');
                                
                                // Add to monitoring
                                uploadingChunksCount++;
                                monitoredTransactions.set(txid, {
                                    type: 'chunk',
                                    chunkIndex: i,
                                    timestamp: Date.now(),
                                    blockId: null
                                });
                                
                                // Wait for confirmation
                                await new Promise(resolve => setTimeout(resolve, 2000));
                                
                                // Get BlockID (existing logic)
                                let waitTime = 0;
                                const maxWaitTime = 30000;
                                
                                while (!blockId && waitTime < maxWaitTime) {
                                    if (wsMonitorActive && monitoredTransactions.has(txid)) {
                                        const monitorData = monitoredTransactions.get(txid);
                                        if (monitorData.blockId) {
                                            blockId = monitorData.blockId;
                                            monitoredTransactions.delete(txid);
                                            uploadingChunksCount--;
                                            break;
                                        }
                                    }
                                    
                                    await new Promise(resolve => setTimeout(resolve, 500));
                                    waitTime += 500;
                                }
                                
                                // Fallback to Explorer API
                                if (!blockId) {
                                    const apiUrl = `https://api-tn10.kaspa.org/transactions/${txid}`;
                                    const response = await fetchWithTimeout(apiUrl, {}, 15000, 3);
                                    if (response.ok) {
                                        const data = await response.json();
                                        blockId = data.block_hash?.[0] || data.accepting_block_hash;
                                    }
                                }
                                
                                if (!blockId) {
                                    throw new Error('BlockIDå–å¾—å¤±æ•—');
                                }
                                
                                // Update status
                                const chunkStatusElement = document.getElementById(`chunk-status-${i}`);
                                if (chunkStatusElement) {
                                    chunkStatusElement.innerHTML = '<span class="success">âœ… å®Œäº†</span>';
                                } else {
                                    log(`[ERROR] chunk-status-${i} è¦ç´ ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“`, 'error');
                                }
                                const uploadTime = Date.now() - uploadStartTime;
                                log(`ãƒšã‚¤ãƒ­ãƒ¼ãƒ‰ ${i + 1} ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰å®Œäº† (${(uploadTime/1000).toFixed(1)}ç§’)`);
                                
                                // Store chunk info
                                processedChunks.push({
                                    index: i,
                                    txid: txid,
                                    blockId: blockId,
                                    payloadSize: payloadBytes.length,
                                    uploadedAt: Date.now()
                                });
                                
                                // Update progress
                                await progressManager.markChunkComplete(i, txid, blockId, payloadBytes.length);
                                
                                break;
                                
                            } catch (error) {
                                retries++;
                                log(`ãƒšã‚¤ãƒ­ãƒ¼ãƒ‰ ${i + 1} ã‚¨ãƒ©ãƒ¼ (è©¦è¡Œ ${retries}/${config.retryCount}): ${error.message}`, 'error');
                                
                                if (retries >= config.retryCount) {
                                    const chunkStatusElement = document.getElementById(`chunk-status-${i}`);
                                    if (chunkStatusElement) {
                                        chunkStatusElement.innerHTML = '<span class="error">âŒ å¤±æ•—</span>';
                                    } else {
                                        log(`[ERROR] chunk-status-${i} è¦ç´ ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ï¼ˆã‚¨ãƒ©ãƒ¼æ™‚ï¼‰`, 'error');
                                    }
                                    progressManager.markChunkFailed(i);
                                    await progressManager.saveProgress();
                                    throw error;
                                }
                                await new Promise(resolve => setTimeout(resolve, 2000));
                            }
                        }
                        
                        // Update progress display
                        const completedChunks = progressManager.progress.metadata.completedChunks;
                        const totalPayloads = payloads.length;
                        const percentage = (completedChunks / totalPayloads * 100).toFixed(1);
                        
                        
                        // Update only the progress bar, not the entire container
                        const progressBar = document.getElementById('uploadProgressBar');
                        if (progressBar) {
                            progressBar.style.width = percentage + '%';
                            progressBar.textContent = percentage + '%';
                        } else {
                            log('[ERROR] uploadProgressBarè¦ç´ ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ï¼', 'error');
                        }
                        
                        // Add or update payload info
                        let payloadInfo = document.getElementById('payloadInfo');
                        if (!payloadInfo) {
                            // Create payload info element if it doesn't exist
                            payloadInfo = document.createElement('div');
                            payloadInfo.id = 'payloadInfo';
                            payloadInfo.style.marginTop = '10px';
                            
                            // Append after chunksList
                            const chunksList = document.getElementById('chunksList');
                            if (chunksList && chunksList.parentNode) {
                                chunksList.parentNode.appendChild(payloadInfo);
                            }
                        }
                        
                        if (payloadInfo) {
                            payloadInfo.innerHTML = `<strong>é€²æ—: ${completedChunks}/${totalPayloads} ãƒšã‚¤ãƒ­ãƒ¼ãƒ‰</strong>`;
                        }
                    }
                    
                    // Skip old chunk processing
                    nextChunkIndex = -1;
                    
                    } catch (error) {
                        // v4.7.57: æ–°æ–¹å¼ã®ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°
                        log(`[æ–°æ–¹å¼] ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ: ${error.message}`, 'error');
                        log(`[æ–°æ–¹å¼] å‡¦ç†ã‚’ä¸­æ–­ã—ã¾ã™`, 'error');
                        throw error;
                    }
                    
                } else {
                    // Use old approach for smaller chunks
                    log('å¾“æ¥æ–¹å¼: ãƒãƒ£ãƒ³ã‚¯å˜ä½ã®å‡¦ç†ã‚’ä½¿ç”¨', 'info');
                    
                    // Continue from next incomplete chunk
                    nextChunkIndex = progressManager.getNextChunkIndex();
                    while (nextChunkIndex >= 0) {
                    // Get fresh UTXOs for each chunk
                    log(`ãƒãƒ£ãƒ³ã‚¯ ${nextChunkIndex + 1}/${totalChunks} ã®å‡¦ç†ã‚’é–‹å§‹...`);
                    const { entries } = await rpcClient.getUtxosByAddresses([address.toString()]);
                    if (!entries || entries.length === 0) {
                        throw new Error('åˆ©ç”¨å¯èƒ½ãªUTXOãŒã‚ã‚Šã¾ã›ã‚“');
                    }
                    
                    const i = nextChunkIndex;
                    log(`ãƒãƒ£ãƒ³ã‚¯ ${i + 1}: ${entries.length} UTXOs åˆ©ç”¨å¯èƒ½`);
                    
                    // No iteration for old approach - use fixed chunk size
                    const optimalChunkSize = actualChunkSize;
                    
                    // Read chunk from file with optimal size
                    const start = i * actualChunkSize;
                    const end = Math.min(start + optimalChunkSize, currentFile.size);
                    log(`ãƒ•ã‚¡ã‚¤ãƒ«ã‹ã‚‰èª­ã¿è¾¼ã¿: ã‚ªãƒ•ã‚»ãƒƒãƒˆ ${start} - ${end} (${end - start} ãƒã‚¤ãƒˆ)`);
                    
                    const chunkBlob = currentFile.slice(start, end);
                    const chunkArrayBuffer = await chunkBlob.arrayBuffer();
                    const chunk = new Uint8Array(chunkArrayBuffer);
                    log(`ãƒãƒ£ãƒ³ã‚¯ã‚µã‚¤ã‚º: ${chunk.length} ãƒã‚¤ãƒˆ`);
                    
                    // Create chunk UI
                    const chunkDiv = document.createElement('div');
                    chunkDiv.className = 'chunk-item';
                    const sizeInfo = `(${(chunk.length/1024).toFixed(1)}KB)`;
                    chunkDiv.innerHTML = `
                        <div>Chunk ${i + 1}/${totalChunks} ${sizeInfo}</div>
                        <div class="chunk-status pending" id="chunk-status-${i}">
                            <span>å¾…æ©Ÿä¸­</span>
                        </div>
                    `;
                    chunksList.appendChild(chunkDiv);
                    
                    // Process chunk
                    const compressed = useCompression ? lzCompress(chunk) : chunk;
                    log(`[DEBUG Main] ãƒãƒ£ãƒ³ã‚¯${i + 1} åœ§ç¸®: ${chunk.length} â†’ ${compressed.length} ãƒã‚¤ãƒˆ (åœ§ç¸®${useCompression ? 'æœ‰åŠ¹' : 'ç„¡åŠ¹'})`, 'debug');
                    const encrypted = await encryptChunk(compressed, key, i);
                    log(`[DEBUG Main] ãƒãƒ£ãƒ³ã‚¯${i + 1} æš—å·åŒ–: ${compressed.length} â†’ ${encrypted.length} ãƒã‚¤ãƒˆ`, 'debug');
                    // No Base64 encoding - use raw binary
                    const payloadBytes = encrypted; // Direct binary payload
                    
                    // v4.7.30: ãƒšã‚¤ãƒ­ãƒ¼ãƒ‰ã‚µã‚¤ã‚ºã®è©³ç´°åˆ†æ
                    if (actualChunkSize >= 22528 && i === 0) { // æœ€åˆã®ãƒãƒ£ãƒ³ã‚¯ã®ã¿è©³ç´°è¡¨ç¤º
                        log(`ğŸ“Š ãƒãƒ£ãƒ³ã‚¯è©³ç´°åˆ†æ:`);
                        log(`  - å…ƒã®ã‚µã‚¤ã‚º: ${chunk.length.toLocaleString()} ãƒã‚¤ãƒˆ`);
                        log(`  - åœ§ç¸®å¾Œ: ${compressed.length.toLocaleString()} ãƒã‚¤ãƒˆ (${((compressed.length/chunk.length)*100).toFixed(1)}%)`);
                        log(`  - æš—å·åŒ–å¾Œ: ${encrypted.length.toLocaleString()} ãƒã‚¤ãƒˆ (+${encrypted.length - compressed.length} ãƒã‚¤ãƒˆ)`);
                        log(`  - ãƒšã‚¤ãƒ­ãƒ¼ãƒ‰åŠ¹ç‡: ${((encrypted.length/24000)*100).toFixed(1)}% / 24KBåˆ¶é™`);
                        
                        // åœ§ç¸®ç‡ãŒäºˆæ¸¬ã¨å¤§ããç•°ãªã‚‹å ´åˆã®è­¦å‘Š
                        const expectedRatio = estimateCompressionRatio(currentFile.name, currentFile.type);
                        const actualRatio = useCompression ? (compressed.length / chunk.length) : 1.0;
                        if (Math.abs(expectedRatio - actualRatio) > 0.2) {
                            log(`âš ï¸ åœ§ç¸®ç‡ã®ä¹–é›¢: äºˆæ¸¬${(expectedRatio*100).toFixed(1)}% vs å®Ÿéš›${(actualRatio*100).toFixed(1)}%`, 'warning');
                        }
                    }
                    
                    // Update status
                    document.getElementById(`chunk-status-${i}`).innerHTML = '<span class="uploading">ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ä¸­...</span>';
                    
                    // Upload to blockchain with retry
                    let txid = null;
                    let blockId = null;
                    let retries = 0;
                    
                    while (retries < config.retryCount && !txid) {
                        try {
                            // Create transaction with raw binary payload
                            
                            // Check payload size before sending
                            if (payloadBytes.length > 24000) {
                                throw new Error(`Payload too large: ${payloadBytes.length} bytes (max 24000)`);
                            }
                            
                            log(`Chunk ${i + 1} payload size: ${payloadBytes.length} bytes`);

                            
                            // Format current UTXOs
                            const formattedUtxos = entries.map(utxo => ({
                                address: address.toString(),
                                outpoint: {
                                    transactionId: utxo.outpoint.transactionId,
                                    index: utxo.outpoint.index
                                },
                                scriptPublicKey: utxo.scriptPublicKey,
                                amount: BigInt(utxo.amount),
                                isCoinbase: utxo.isCoinbase || false,
                                blockDaaScore: BigInt(utxo.blockDaaScore)
                            }));
                            
                            const result = await kaspa.createTransactions({
                                entries: formattedUtxos,
                                outputs: [{
                                    address: address.toString(),
                                    amount: 100000000n // 1 KAS
                                }],
                                changeAddress: address.toString(),
                                priorityFee: 10000n,
                                networkId: config.network,
                                payload: payloadBytes
                            });
                            
                            // Sign and submit transaction
                            if (!result.transactions || result.transactions.length === 0) {
                                throw new Error('No transactions generated');
                            }
                            
                            const pendingTx = result.transactions[0];
                            
                            // Sign the transaction
                            log(`ãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³ã«ç½²åä¸­...`);
                            await pendingTx.sign([privateKey]);
                            
                            // Submit to network
                            log(`ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ã«é€ä¿¡ä¸­...`);
                            txid = await pendingTx.submit(rpcClient);
                            
                            log(`ãƒãƒ£ãƒ³ã‚¯ ${i + 1} TxID: ${txid.substring(0, 16)}...`, 'success');
                            
                            // Add to monitoring list
                            uploadingChunksCount++;
                            monitoredTransactions.set(txid, {
                                type: 'chunk',
                                chunkIndex: i,
                                timestamp: Date.now(),
                                blockId: null
                            });
                            log(`[DEBUG] WebSocketç›£è¦–ãƒªã‚¹ãƒˆã«è¿½åŠ : TxID: ${txid.substring(0, 16)}... (ãƒãƒ£ãƒ³ã‚¯ ${i + 1}/${totalChunks})`, 'debug');
                            
                            log(`ãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³é€ä¿¡å®Œäº†: ${txid.substring(0, 16)}...`);
                            
                            // Wait for transaction to be accepted
                            log(`ãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³ã®ç¢ºèªå¾…ã¡...`);
                            await new Promise(resolve => setTimeout(resolve, 2000));
                            
                            // Try WebSocket monitoring first
                            log(`ãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³ç¢ºèªã‚’å¾…æ©Ÿä¸­...`);
                            
                            // Wait for confirmation (WebSocket or RPC)
                            let waitTime = 0;
                            const maxWaitTime = 30000; // 30 seconds for RPC check
                            
                            while (!blockId && waitTime < maxWaitTime) {
                                // Check WebSocket monitor first
                                if (wsMonitorActive && monitoredTransactions && monitoredTransactions.has(txid)) {
                                    const monitorData = monitoredTransactions.get(txid);
                                    if (monitorData.blockId) {
                                        blockId = monitorData.blockId;
                                        log(`WebSocketçµŒç”±ã§BlockIDå–å¾—: ${blockId.substring(0, 16)}...`);
                                        // Remove from monitoring list
                                        monitoredTransactions.delete(txid);
                                        uploadingChunksCount--;
                                        log(`[DEBUG] WebSocketç›£è¦–ãƒªã‚¹ãƒˆã‹ã‚‰å‰Šé™¤: TxID: ${txid.substring(0, 16)}... (BlockIDå–å¾—æ¸ˆã¿)`, 'debug');
                                        break;
                                    }
                                }
                                
                                // After 30 seconds, try RPC
                                if (waitTime >= 30000) {
                                    try {
                                        log('30ç§’çµŒé - RPCã§ç¢ºèªã‚’è©¦ã¿ã¾ã™...');
                                        const txInfo = await rpcClient.getTransaction({
                                            transactionId: txid,
                                            includeBlockInfo: true
                                        });
                                        
                                        if (txInfo && txInfo.blockHash) {
                                            blockId = txInfo.blockHash;
                                            log(`RPCçµŒç”±ã§BlockIDå–å¾—: ${blockId.substring(0, 16)}...`);
                                            // Remove from monitoring list if found via RPC
                                            if (monitoredTransactions.has(txid)) {
                                                monitoredTransactions.delete(txid);
                                                uploadingChunksCount--;
                                                log(`[DEBUG] WebSocketç›£è¦–ãƒªã‚¹ãƒˆã‹ã‚‰å‰Šé™¤: TxID: ${txid.substring(0, 16)}... (RPCçµŒç”±ã§BlockIDå–å¾—)`, 'debug');
                                            }
                                            break;
                                        }
                                    } catch (err) {
                                        // Transaction might not be confirmed yet
                                    }
                                }
                                
                                await new Promise(resolve => setTimeout(resolve, 500));
                                waitTime += 500;
                            }
                            
                            // Fallback to Explorer API
                            if (!blockId) {
                                if (wsMonitorActive && monitoredTransactions.has(txid)) {
                                    const elapsed = Date.now() - monitoredTransactions.get(txid).timestamp;
                                    log(`WebSocketã§${elapsed/1000}ç§’é–“è¦‹ã¤ã‹ã‚‰ãš - Explorer APIã‚’ä½¿ç”¨`);
                                } else {
                                    log(`RPCå¾…æ©Ÿã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆ - Explorer APIã‚’ä½¿ç”¨`);
                                }
                                const apiUrl = `https://api-tn10.kaspa.org/transactions/${txid}`;
                                const response = await fetchWithTimeout(apiUrl, {}, 15000, 3); // 15s timeout, 3 retries for important upload
                                if (response.ok) {
                                    const data = await response.json();
                                    blockId = data.block_hash?.[0] || data.accepting_block_hash;
                                    if (blockId) {
                                        log(`Explorer APIçµŒç”±ã§BlockIDå–å¾—: ${blockId.substring(0, 16)}...`);
                                    }
                                }
                            }
                            
                            if (!blockId) {
                                throw new Error('BlockIDå–å¾—å¤±æ•—');
                            }
                            
                            // Update status
                            document.getElementById(`chunk-status-${i}`).innerHTML = '<span class="success">âœ… å®Œäº†</span>';
                            log(`ãƒãƒ£ãƒ³ã‚¯ ${i + 1} ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰å®Œäº†`);
                            
                            // Get block time from monitored transactions
                            let chunkBlockTime = null;
                            if (monitoredTransactions.has(txid)) {
                                const txData = monitoredTransactions.get(txid);
                                if (txData.blockTime) {
                                    chunkBlockTime = txData.blockTime;
                                    log(`[DEBUG] ãƒãƒ£ãƒ³ã‚¯ ${i + 1} ã®ãƒ–ãƒ­ãƒƒã‚¯æ™‚åˆ»ã‚’å–å¾—: ${chunkBlockTime.toISOString()}`, 'debug');
                                }
                            }
                            
                            // Store chunk info
                            processedChunks.push({
                                index: i,
                                txid: txid,
                                blockId: blockId,
                                blockTime: chunkBlockTime,
                                originalSize: chunk.length,
                                compressedSize: compressed.length,
                                payloadSize: payloadBytes.length,
                                uploadedAt: Date.now()
                            });
                            
                            // Update progress manager
                            log(`é€²æ—æƒ…å ±ã‚’æ›´æ–°ä¸­...`);
                            await progressManager.markChunkComplete(i, txid, blockId, payloadBytes.length);
                            
                            break;
                            
                        } catch (error) {
                            retries++;
                            log(`ãƒãƒ£ãƒ³ã‚¯ ${i + 1} ã‚¨ãƒ©ãƒ¼ (è©¦è¡Œ ${retries}/${config.retryCount}): ${error.message || error}`, 'error');
                            console.error('è©³ç´°ã‚¨ãƒ©ãƒ¼:', error);
                            console.error('ã‚¹ã‚¿ãƒƒã‚¯ãƒˆãƒ¬ãƒ¼ã‚¹:', error.stack);
                            
                            if (retries >= config.retryCount) {
                                document.getElementById(`chunk-status-${i}`).innerHTML = '<span class="error">âŒ å¤±æ•—</span>';
                                progressManager.markChunkFailed(i);
                                log(`ãƒãƒ£ãƒ³ã‚¯ ${i + 1} ã®ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ãŒå¤±æ•— - é€²æ—ã‚’ä¿å­˜`);
                                await progressManager.saveProgress(); // Save progress on failure
                                throw error;
                            }
                            log(`2ç§’å¾…æ©Ÿå¾Œã«ãƒªãƒˆãƒ©ã‚¤...`);
                            await new Promise(resolve => setTimeout(resolve, 2000));
                        }
                    }
                    
                    // Update progress
                    const stats = progressManager.getStats();
                    const progress = stats.percentage;
                    document.getElementById('uploadProgressBar').style.width = progress + '%';
                    document.getElementById('uploadProgressBar').textContent = progress + '%';
                    
                    // Get next chunk
                    nextChunkIndex = progressManager.getNextChunkIndex();
                }
                } // End of old approach
                
                // Calculate cost
                const totalPayloadKB = processedChunks.reduce((sum, c) => sum + c.payloadSize, 0) / 1024;
                const totalCost = totalChunks * 0.00005 + totalPayloadKB * 0.00001;
                
                // Final progress save
                await progressManager.saveProgress();
                log('æœ€çµ‚é€²æ—ã‚’ä¿å­˜ã—ã¾ã—ãŸ', 'success');
                
                // Prepare metadata with unified structure
                kaspaMetadata = {
                    type: 'kaspa-file',
                    version: "3.3",  // v4.7.50: Updated to Format v3.3
                    created: new Date().toISOString(),
                    network: config.network,
                    
                    // Encryption at top level
                    encryption: {
                        algorithm: "AES-256-GCM",
                        pbkdf2: {
                            salt: toBase64(salt),
                            iterations: 100000
                        }
                    },
                    
                    // File-specific information
                    file: {
                        name: currentFile.name,
                        size: currentFile.size,
                        mimeType: currentFile.type || 'application/octet-stream',
                        sha256: fileHash,
                        encrypted: true,
                        compression: {
                            algorithm: useCompression ? "LZ77" : "none",
                            enabled: useCompression,
                            originalSize: currentFile.size,
                            compressedSize: processedChunks.reduce((sum, c) => sum + c.compressedSize, 0)
                        }
                    },
                    
                    // Chunk information
                    chunks: processedChunks.map(c => c.txid),
                    chunkBlockIds: processedChunks.map(c => c.blockId),
                    chunkSizes: processedChunks.map(c => c.originalSize), // v4.7.36: å„ãƒãƒ£ãƒ³ã‚¯ã®å®Ÿéš›ã®ã‚µã‚¤ã‚º
                    
                    // Recovery information
                    recovery: {
                        totalChunks: totalChunks,
                        chunkSize: config.chunkSize,
                        checksum: fileHash,
                        uploadCost: totalCost
                    },
                    
                    // Metadata
                    metadata: {
                        metaTxId: null, // Will be set if meta-tx is created
                        metaTxBlockId: null,
                        uploadDate: new Date().toISOString(),
                        blockTime: null,
                        uploadedBy: address.toString(),
                        payloadSplit: useNewApproach, // Flag for new approach
                        chunkBoundaries: useNewApproach ? progressManager.progress.metadata.chunkBoundaries : undefined
                    }
                };
                
                // Save to history
                uploadHistory.push({
                    filename: currentFile.name,
                    timestamp: Date.now(),
                    metadata: kaspaMetadata
                });
                
                log(`ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰å®Œäº†! ç·ã‚³ã‚¹ãƒˆ: ${totalCost.toFixed(5)} KAS`, 'success');
                
                // Add to history
                if (window.historyManager) {
                    // Get block time from last chunk or meta-tx
                    // Get block time from the last chunk
                    let blockTime = null;
                    if (processedChunks.length > 0) {
                        const lastChunk = processedChunks[processedChunks.length - 1];
                        if (lastChunk.blockTime) {
                            blockTime = lastChunk.blockTime.toISOString();
                            log(`[DEBUG] æœ€å¾Œã®ãƒãƒ£ãƒ³ã‚¯ã®ãƒ–ãƒ­ãƒƒã‚¯æ™‚åˆ»ã‚’å–å¾—: ${blockTime}`, 'debug');
                        }
                    }
                    
                    const uploadData = {
                        id: `upload_${Date.now()}`,
                        type: 'file',
                        fileName: currentFile.name,
                        fileSize: currentFile.size,
                        fileSha256: fileHash,
                        uploadDate: new Date().toISOString(),
                        blockTime: blockTime, // Add blockchain time if available
                        chunks: totalChunks,
                        totalCost: totalCost,
                        metaTxId: null, // Will be set if meta-tx is used
                        metaTxBlockId: null, // Will be set if meta-tx is used
                        firstChunkTxId: processedChunks[0]?.txid || '',
                        cid: window.currentFileCID || '',
                        password: currentPassword || null,
                        // New structure: store encryption info directly
                        encryption: {
                            algorithm: "AES-256-GCM",
                            salt: kaspaMetadata.encryption?.pbkdf2?.salt || '',
                            iterations: kaspaMetadata.encryption?.pbkdf2?.iterations || 10000
                        },
                        compression: kaspaMetadata.file?.compression || {
                            algorithm: "none",
                            enabled: false
                        },
                        // Store complete metadata for backward compatibility
                        metadata: kaspaMetadata,
                        chunkTxIds: processedChunks.map(c => c.txid),
                        chunkBlockIds: processedChunks.map(c => c.blockId),
                        chunkSize: config.chunkSize,
                        network: config.network
                    };
                    log(`[DEBUG] å±¥æ­´ãƒ‡ãƒ¼ã‚¿ç”Ÿæˆå®Œäº† - ID: ${uploadData.id}`, 'debug');
                    await window.historyManager.addUpload(uploadData);
                    
                    // Delete .kprogress file if exists
                    if (progressManager && window.workspaceHandle) {
                        try {
                            await window.workspaceHandle.removeEntry(progressManager.progressFileName);
                            log('.kprogressãƒ•ã‚¡ã‚¤ãƒ«ã‚’å‰Šé™¤ã—ã¾ã—ãŸ', 'info');
                        } catch (err) {
                            // File might not exist
                        }
                    }
                }
                
                // Check if meta-tx option is enabled
                const useMetaTx = document.getElementById('useMetaTx').checked;
                log(`[DEBUG] ãƒ¡ã‚¿Txä½¿ç”¨è¨­å®š: ${useMetaTx}`, 'debug');
                log(`[DEBUG] ãƒ¯ãƒ¼ã‚¯ã‚¹ãƒšãƒ¼ã‚¹è¨­å®š: ${window.workspaceHandle ? 'ã‚ã‚Š' : 'ãªã—'}`, 'debug');
                
                if (useMetaTx) {
                    log('[DEBUG] ãƒ¡ã‚¿Txä½œæˆã‚’é–‹å§‹ã—ã¾ã™', 'debug');
                    await createAndUploadMetaTx();
                } else {
                    log('[DEBUG] ãƒ¡ã‚¿Txã¯ä½œæˆã—ã¾ã›ã‚“ï¼ˆãƒã‚§ãƒƒã‚¯ãƒœãƒƒã‚¯ã‚¹ãŒOFFï¼‰', 'debug');
                    // Auto-stop monitoring for non-meta-tx uploads
                    if (window.wsMonitorActive) {
                        log('ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰å®Œäº† - WebSocketç›£è¦–ã‚’è‡ªå‹•åœæ­¢ã—ã¾ã™', 'info');
                        await stopMonitoring();
                    }
                    log('ğŸ‰ ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ãŒå®Œäº†ã—ã¾ã—ãŸï¼å±¥æ­´ã‚¿ãƒ–ã§è©³ç´°ã‚’ç¢ºèªã—ã¦ãã ã•ã„', 'success');
                    // Switch to History tab
                    switchTab('history');
                }
                
            } catch (error) {
                log(`ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ã‚¨ãƒ©ãƒ¼: ${error.message}`, 'error');
                console.error('Upload error stack:', error.stack);
                log(`[DEBUG] ã‚¨ãƒ©ãƒ¼ã‚¹ã‚¿ãƒƒã‚¯: ${error.stack}`, 'debug');
            } finally {
                // v3.6.3 fix: Clear upload flag
                isUploadingFile = false;
                document.getElementById('uploadBtn').disabled = false;
                
                // v4.7.13: Reset ProgressManager to prevent reuse
                progressManager = null;
                log('ProgressManagerã‚’ãƒªã‚»ãƒƒãƒˆã—ã¾ã—ãŸ', 'debug');
            }
        };

        // Generate .kaspa file - DEPRECATED: Now handled in History tab
        // Keeping for backward compatibility if needed
        /* window.generateKaspaFile = function() {
            if (!kaspaMetadata) {
                log('.kaspaãƒ•ã‚¡ã‚¤ãƒ«ç”Ÿæˆãƒ‡ãƒ¼ã‚¿ãŒã‚ã‚Šã¾ã›ã‚“', 'error');
                return;
            }
            
            try {
                const includePassword = document.getElementById('includePassword').checked;
                const kaspaData = JSON.parse(JSON.stringify(kaspaMetadata));
                
                if (includePassword && currentPassword) {
                    kaspaData.auth = {
                        passwordIncluded: true,
                        password: currentPassword,
                        warning: "ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ã¯å¹³æ–‡ã§ä¿å­˜ã•ã‚Œã¦ã„ã¾ã™ã€‚ä¿¡é ¼ã§ãã‚‹ç›¸æ‰‹ã¨ã®ã¿å…±æœ‰ã—ã¦ãã ã•ã„ã€‚"
                    };
                    log('âš ï¸ ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ãŒ.kaspaãƒ•ã‚¡ã‚¤ãƒ«ã«å«ã¾ã‚Œã¦ã„ã¾ã™', 'warning');
                }
                
                const kaspaFileContent = JSON.stringify(kaspaData, null, 2);
                const blob = new Blob([kaspaFileContent], { type: 'application/octet-stream' });
                const url = URL.createObjectURL(blob);
                
                const a = document.createElement('a');
                a.href = url;
                // Use CID in filename if available
                const cid = window.currentFileCID || generateRandomCID();
                a.download = generateSafeFilename(currentFile.name, cid);
                a.click();
                
                URL.revokeObjectURL(url);
                
                const kaspaResultElement = document.getElementById('kaspaResult');
                if (kaspaResultElement) {
                    kaspaResultElement.innerHTML = `
                        <div class="metric-box">
                            <h4 class="success">âœ… .kaspaãƒ•ã‚¡ã‚¤ãƒ«ç”Ÿæˆå®Œäº†</h4>
                            <p>ãƒ•ã‚¡ã‚¤ãƒ«å: ${generateSafeFilename(currentFile.name, cid)}</p>
                            <p>ã‚µã‚¤ã‚º: ${(kaspaFileContent.length/1024).toFixed(1)}KB</p>
                            ${includePassword ? '<p class="warning">âš ï¸ ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ãŒå«ã¾ã‚Œã¦ã„ã¾ã™</p>' : ''}
                        </div>
                    `;
                }
                
                log('.kaspaãƒ•ã‚¡ã‚¤ãƒ«ã‚’ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ã—ã¾ã—ãŸ', 'success');
                
            } catch (error) {
                log(`.kaspaãƒ•ã‚¡ã‚¤ãƒ«ç”Ÿæˆã‚¨ãƒ©ãƒ¼: ${error.message}`, 'error');
            }
        }; */

        // Create and upload meta transaction
        window.createAndUploadMetaTx = async function() {
            try {
                log('ãƒ¡ã‚¿ãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³ä½œæˆã‚’é–‹å§‹ã—ã¾ã™...', 'info');
                
                // Check if super metadata is needed based on chunk count
                const totalChunks = kaspaMetadata.chunks.length;
                const CHUNKS_PER_META = 2; // Testing with 2 chunks per meta
                
                if (totalChunks > CHUNKS_PER_META) {
                    log(`[SuperMeta] ãƒ†ã‚¹ãƒˆä¸­: ${totalChunks}ãƒãƒ£ãƒ³ã‚¯æ¤œå‡º (2ãƒãƒ£ãƒ³ã‚¯æ¯) - ã‚¹ãƒ¼ãƒ‘ãƒ¼ãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿ã‚’ç”Ÿæˆã—ã¾ã™`, 'info');
                    
                    // Group chunks
                    const chunkGroups = [];
                    for (let i = 0; i < totalChunks; i += CHUNKS_PER_META) {
                        const group = [];
                        for (let j = 0; j < CHUNKS_PER_META && i + j < totalChunks; j++) {
                            group.push({
                                txid: kaspaMetadata.chunks[i + j],
                                blockId: kaspaMetadata.chunkBlockIds[i + j]
                            });
                        }
                        chunkGroups.push(group);
                    }
                    
                    log(`[SuperMeta] ${chunkGroups.length}å€‹ã®ãƒãƒ£ãƒ³ã‚¯ã‚°ãƒ«ãƒ¼ãƒ—ã‚’ä½œæˆ`, 'info');
                    
                    // Create intermediate meta-txs
                    const intermediateMetaTxs = [];
                    for (let i = 0; i < chunkGroups.length; i++) {
                        const intermediateMeta = await createIntermediateMetaTx(
                            chunkGroups[i], 
                            i, 
                            chunkGroups.length,
                            kaspaMetadata,
                            currentPassword,
                            CHUNKS_PER_META
                        );
                        intermediateMetaTxs.push(intermediateMeta);
                    }
                    
                    // Create super meta-tx
                    const superMeta = await createSuperMetaTx(intermediateMetaTxs, kaspaMetadata, currentPassword);
                    
                    // Update metadata with super meta info
                    kaspaMetadata.metaTx = {
                        type: 'super',
                        txid: superMeta.txId,
                        blockId: superMeta.blockId,
                        reference: superMeta.blockId ? `${superMeta.txId}:${superMeta.blockId}` : superMeta.txId,
                        createdAt: Date.now(),
                        intermediateMetaTxs: intermediateMetaTxs
                    };
                    
                    // Update history
                    if (window.historyManager && window.currentFileCID) {
                        const history = window.historyManager.getHistory();
                        const latestUpload = history.find(h => h.cid === window.currentFileCID);
                        if (latestUpload) {
                            latestUpload.metaTxId = superMeta.txId;
                            latestUpload.metaTxBlockId = superMeta.blockId;
                            latestUpload.metaTxType = 'super';
                            localStorage.setItem(window.historyManager.dbName, JSON.stringify(history));
                            await window.historyManager.saveToFile();
                        }
                    }
                    
                    log(`[SuperMeta] ğŸ‰ ã‚¹ãƒ¼ãƒ‘ãƒ¼ãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿ä½œæˆå®Œäº†ï¼`, 'success');
                    
                    // Auto-stop monitoring
                    if (window.wsMonitorActive) {
                        await stopMonitoring();
                    }
                    
                    switchTab('history');
                    return;
                }
                
                // Regular meta-tx creation (for files <= 2 chunks)
                // Prepare meta-tx data with Format v3.3
                const metaTxData = {
                    type: "kaspa-meta-tx",
                    version: "3.3",  // v4.7.50: Updated to Format v3.3
                    created: kaspaMetadata.created,
                    network: kaspaMetadata.network,
                    encryption: kaspaMetadata.encryption,
                    file: kaspaMetadata.file,
                    chunks: kaspaMetadata.chunks,
                    chunkBlockIds: kaspaMetadata.chunkBlockIds,  // v3.3ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆæº–æ‹ 
                    recovery: kaspaMetadata.recovery,
                    metadata: kaspaMetadata.metadata,
                    // Add flat structure for regular meta-tx
                    chunkStructure: {
                        type: "flat",
                        totalChunks: totalChunks
                    }
                };
                
                // Encrypt meta-tx data with the same password
                const metaDataString = JSON.stringify(metaTxData);
                const metaDataBytes = new TextEncoder().encode(metaDataString);
                
                // Use the same salt and key from file encryption
                if (!kaspaMetadata.encryption || !kaspaMetadata.encryption.pbkdf2) {
                    throw new Error('æš—å·åŒ–æƒ…å ±ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“');
                }
                const salt = fromBase64(kaspaMetadata.encryption.pbkdf2.salt);
                const key = await deriveKey(currentPassword, salt);
                
                // Encrypt with chunk index -1 to indicate meta-tx
                const encryptedMetaData = await encryptChunk(metaDataBytes, key, -1);
                
                // Prepend salt to encrypted data for self-contained decryption
                const metaPayload = new Uint8Array(salt.length + encryptedMetaData.length);
                metaPayload.set(salt, 0);
                metaPayload.set(encryptedMetaData, salt.length);
                
                log(`ãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿ã‚µã‚¤ã‚º: ${metaDataBytes.length} bytes â†’ æš—å·åŒ–å¾Œ: ${metaPayload.length} bytes (saltå«ã‚€)`);
                
                // Upload meta-tx to blockchain
                const utxoResponse = await rpcClient.getUtxosByAddresses([address.toString()]);
                const entries = utxoResponse.entries || [];
                
                log(`${entries.length} UTXOs available for meta-tx`);
                
                const formattedUtxos = entries.map(utxo => {
                    try {
                        return {
                            address: address.toString(),
                            outpoint: {
                                transactionId: utxo.outpoint.transactionId,
                                index: utxo.outpoint.index
                            },
                            scriptPublicKey: utxo.scriptPublicKey,
                            amount: BigInt(utxo.amount),
                            isCoinbase: utxo.isCoinbase || false,
                            blockDaaScore: BigInt(utxo.blockDaaScore)
                        };
                    } catch (e) {
                        log(`UTXO formatting error: ${e.message}`, 'error');
                        console.error('UTXO:', utxo);
                        throw e;
                    }
                });
                
                log(`Creating meta-tx with ${formattedUtxos.length} UTXOs, payload size: ${metaPayload.length} bytes`);
                
                let result;
                try {
                    // Use same amount as regular chunks (1 KAS)
                    const amount = 100000000n; // 1 KAS
                    
                    result = await kaspa.createTransactions({
                        entries: formattedUtxos,
                        outputs: [{
                            address: address.toString(),
                            amount: amount
                        }],
                        changeAddress: address.toString(),
                        priorityFee: 10000n,
                        networkId: config.network,
                        payload: metaPayload
                    });
                } catch (e) {
                    log(`createTransactions error: ${e.message || e}`, 'error');
                    throw e;
                }
                
                if (!result) {
                    throw new Error('createTransactions returned null/undefined');
                }
                
                if (!result.transactions || result.transactions.length === 0) {
                    throw new Error('ãƒ¡ã‚¿ãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³ç”Ÿæˆå¤±æ•— - no transactions in result');
                }
                
                const pendingTx = result.transactions[0];
                await pendingTx.sign([privateKey]);
                const metaTxId = await pendingTx.submit(rpcClient);
                
                log(`ãƒ¡ã‚¿ãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³ã‚’é€ä¿¡ã—ã¾ã—ãŸ: ${metaTxId}`, 'success');
                
                // Add to monitoring list
                uploadingMetaTx = true;
                monitoredTransactions.set(metaTxId, {
                    type: 'meta-tx',
                    timestamp: Date.now(),
                    blockId: null
                });
                log(`[DEBUG] WebSocketç›£è¦–ãƒªã‚¹ãƒˆã«è¿½åŠ : TxID: ${metaTxId.substring(0, 16)}... (ãƒ¡ã‚¿ãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³)`, 'debug');
                
                // Wait for BlockID from WebSocket monitor
                log(`ãƒ¡ã‚¿ãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³ã®BlockIDã‚’å¾…æ©Ÿä¸­...`);
                let metaBlockId = null;
                let waitTime = 0;
                const maxWaitTime = 30000; // 30 seconds max
                
                while (!metaBlockId && waitTime < maxWaitTime) {
                    if (monitoredTransactions.has(metaTxId)) {
                        const monitorData = monitoredTransactions.get(metaTxId);
                        if (monitorData.blockId) {
                            metaBlockId = monitorData.blockId;
                            // Remove from monitoring list
                            monitoredTransactions.delete(metaTxId);
                            uploadingMetaTx = false;
                            log(`[DEBUG] WebSocketç›£è¦–ãƒªã‚¹ãƒˆã‹ã‚‰å‰Šé™¤: TxID: ${metaTxId.substring(0, 16)}... (ãƒ¡ã‚¿Tx BlockIDå–å¾—æ¸ˆã¿)`, 'debug');
                            break;
                        }
                    }
                    await new Promise(resolve => setTimeout(resolve, 500));
                    waitTime += 500;
                }
                
                let metaTxReference = metaTxId;
                if (metaBlockId) {
                    log(`BlockIDå–å¾—æˆåŠŸ: ${metaBlockId}`, 'success');
                    metaTxReference = `${metaTxId}:${metaBlockId}`;
                } else {
                    log(`BlockIDå–å¾—ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆ - ãƒ¡ã‚¿TxIDã®ã¿ã§ä¿å­˜`, 'warning');
                }
                
                // Log meta-tx creation success
                log(`ğŸ‰ ãƒ¡ã‚¿ãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³ä½œæˆå®Œäº†ï¼ ${metaBlockId ? 'TxID:BlockID' : 'TxID'}: ${metaTxReference}`, 'success');
                if (metaBlockId) {
                    log('âœ… REST APIä¸è¦ã§å¾©å…ƒå¯èƒ½ã§ã™', 'success');
                } else {
                    log('âš ï¸ BlockIDå–å¾—ã«å¤±æ•—ã—ã¾ã—ãŸã€‚å¾©å…ƒæ™‚ã«REST APIãŒå¿…è¦ã§ã™', 'warning');
                }
                
                // Add meta-tx to metadata for .kaspa file generation
                kaspaMetadata.metaTx = {
                    txid: metaTxId,
                    blockId: metaBlockId,
                    reference: metaTxReference,
                    createdAt: Date.now()
                };
                
                // Update history with metaTxId
                if (window.historyManager && window.currentFileCID) {
                    log(`[DEBUG] å±¥æ­´æ›´æ–°é–‹å§‹ - CID: ${window.currentFileCID}`, 'debug');
                    const history = window.historyManager.getHistory();
                    const latestUpload = history.find(h => h.cid === window.currentFileCID);
                    if (latestUpload) {
                        log(`[DEBUG] å±¥æ­´ã‚¨ãƒ³ãƒˆãƒªãƒ¼ç™ºè¦‹ - ID: ${latestUpload.id}`, 'debug');
                        // ä¸¡æ–¹ã®ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ã‚’æ­£ã—ãè¨­å®š
                        latestUpload.metaTxId = metaTxId;
                        latestUpload.metaTxBlockId = metaBlockId;
                        latestUpload.metaTxReference = metaTxReference; // å¾Œæ–¹äº’æ›æ€§ã®ãŸã‚
                        log(`[DEBUG] ãƒ¡ã‚¿TxIDè¨­å®š: ${metaTxId}`, 'debug');
                        log(`[DEBUG] ãƒ¡ã‚¿BlockIDè¨­å®š: ${metaBlockId || 'null'}`, 'debug');
                        // Save updated history
                        localStorage.setItem(window.historyManager.dbName, JSON.stringify(history));
                        await window.historyManager.saveToFile();
                        log('[UploadHistoryManager] ãƒ¡ã‚¿TxIDã¨BlockIDã‚’å±¥æ­´ã«è¿½åŠ ã—ã¾ã—ãŸ', 'debug');
                    } else {
                        log(`[DEBUG] CID ${window.currentFileCID} ã®å±¥æ­´ã‚¨ãƒ³ãƒˆãƒªãƒ¼ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“`, 'error');
                    }
                } else {
                    log(`[DEBUG] å±¥æ­´æ›´æ–°ã‚¹ã‚­ãƒƒãƒ— - historyManager: ${!!window.historyManager}, CID: ${window.currentFileCID || 'ãªã—'}`, 'warning');
                }
                
                // Auto-stop WebSocket monitoring after meta-tx creation
                if (window.wsMonitorActive) {
                    log('ãƒ¡ã‚¿ãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³ä½œæˆå®Œäº† - WebSocketç›£è¦–ã‚’è‡ªå‹•åœæ­¢ã—ã¾ã™', 'info');
                    await stopMonitoring();
                }
                
                // Switch to History tab
                log('å±¥æ­´ã‚¿ãƒ–ã§è©³ç´°ã‚’ç¢ºèªã—ã¦ãã ã•ã„', 'info');
                switchTab('history');
                
            } catch (error) {
                log(`ãƒ¡ã‚¿ãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³ä½œæˆã‚¨ãƒ©ãƒ¼: ${error.message || error}`, 'error');
                console.error('Meta-tx creation error:', error);
                
                // Try to log more details
                if (error.stack) {
                    console.error('Error stack:', error.stack);
                }
                
                // Error occurred - no fallback needed as .kaspa generation is in History tab
            }
        };

        // Create intermediate meta-tx for chunk groups (experimental)
        async function createIntermediateMetaTx(chunkGroup, groupIndex, totalGroups, fileMetadata, password, chunksPerMeta) {
            try {
                log(`[SuperMeta] ä¸­é–“ãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿ ${groupIndex + 1}/${totalGroups} ã‚’ç”Ÿæˆä¸­...`, 'info');
                
                // Create metadata for this chunk group
                const metaTxData = {
                    type: "kaspa-meta-tx",
                    version: "3.3",
                    created: new Date().toISOString(),
                    network: config.network,
                    
                    // Mark as intermediate metadata
                    chunkStructure: {
                        type: "meta",
                        level: 1,
                        groupIndex: groupIndex,
                        totalGroups: totalGroups,
                        chunkRange: [
                            groupIndex * chunksPerMeta,
                            Math.min((groupIndex + 1) * chunksPerMeta - 1, fileMetadata.recovery.totalChunks - 1)
                        ]
                    },
                    
                    encryption: fileMetadata.encryption,
                    file: fileMetadata.file,
                    
                    // Only include chunks for this group
                    chunks: chunkGroup.map(c => c.txid),
                    chunkBlockIds: chunkGroup.map(c => c.blockId),
                    
                    recovery: {
                        totalChunks: chunkGroup.length,
                        checksum: fileMetadata.file.sha256,
                        uploadCost: chunkGroup.length * 0.00005
                    },
                    
                    metadata: {
                        parentFile: fileMetadata.file.name,
                        groupInfo: {
                            index: groupIndex,
                            startChunk: groupIndex * chunksPerMeta,
                            endChunk: (groupIndex + 1) * chunksPerMeta - 1
                        },
                        // Pass through payloadSplit flag if present
                        payloadSplit: fileMetadata.metadata?.payloadSplit || false,
                        // Include chunk boundaries for this group if available
                        ...(fileMetadata.metadata?.chunkBoundaries ? {
                            chunkBoundaries: fileMetadata.metadata.chunkBoundaries.slice(
                                groupIndex * chunksPerMeta,
                                Math.min((groupIndex + 1) * chunksPerMeta, fileMetadata.metadata.chunkBoundaries.length)
                            )
                        } : {})
                    }
                };
                
                // Encrypt and upload
                const metaDataString = JSON.stringify(metaTxData);
                const metaDataBytes = new TextEncoder().encode(metaDataString);
                
                const salt = fromBase64(fileMetadata.encryption.pbkdf2.salt);
                const key = await deriveKey(password, salt);
                
                const encryptedMetaData = await encryptChunk(metaDataBytes, key, -1);
                const metaPayload = new Uint8Array(salt.length + encryptedMetaData.length);
                metaPayload.set(salt, 0);
                metaPayload.set(encryptedMetaData, salt.length);
                
                log(`[SuperMeta] ä¸­é–“ãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿ã‚µã‚¤ã‚º: ${metaDataBytes.length} bytes`, 'debug');
                
                // Upload to blockchain
                const utxoResponse = await rpcClient.getUtxosByAddresses([address.toString()]);
                const entries = utxoResponse.entries || [];
                
                const formattedUtxos = entries.map(utxo => ({
                    address: address.toString(),
                    outpoint: {
                        transactionId: utxo.outpoint.transactionId,
                        index: utxo.outpoint.index
                    },
                    scriptPublicKey: utxo.scriptPublicKey,
                    amount: BigInt(utxo.amount),
                    isCoinbase: utxo.isCoinbase || false,
                    blockDaaScore: BigInt(utxo.blockDaaScore)
                }));
                
                const result = await kaspa.createTransactions({
                    entries: formattedUtxos,
                    outputs: [{
                        address: address.toString(),
                        amount: 100000000n // 1 KAS
                    }],
                    changeAddress: address.toString(),
                    priorityFee: 10000n,
                    networkId: config.network,
                    payload: metaPayload
                });
                
                const pendingTx = result.transactions[0];
                await pendingTx.sign([privateKey]);
                
                // Debug: Check transaction before submission
                log(`[SuperMeta] ãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³é€ä¿¡å‰ - ãƒšã‚¤ãƒ­ãƒ¼ãƒ‰ã‚µã‚¤ã‚º: ${metaPayload.length} bytes`, 'debug');
                
                // Get transaction ID before submission for tracking
                const txId = pendingTx.id;
                log(`[SuperMeta] ãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³ID (é€ä¿¡å‰): ${txId.substring(0, 16)}...`, 'debug');
                
                // Declare metaTxId outside try block for proper scope
                let metaTxId;
                
                // Submit transaction - using the same pattern as chunk upload
                try {
                    metaTxId = await pendingTx.submit(rpcClient);
                    
                    if (!metaTxId) {
                        throw new Error('submit()ãŒnullã‚’è¿”ã—ã¾ã—ãŸ');
                    }
                    
                    log(`[SuperMeta] ä¸­é–“ãƒ¡ã‚¿TxID: ${metaTxId.substring(0, 16)}...`, 'success');
                    
                    // Add to monitored transactions (same as chunk upload)
                    monitoredTransactions.set(metaTxId, {
                        type: 'intermediate-meta',
                        groupIndex: groupIndex,
                        timestamp: Date.now(),
                        blockId: null
                    });
                } catch (submitError) {
                    log(`[SuperMeta] é€ä¿¡ã‚¨ãƒ©ãƒ¼: ${submitError.message}`, 'error');
                    throw submitError;
                }
                
                // Add to monitoring list
                if (window.wsMonitorActive && window.addTransactionToMonitor) {
                    window.addTransactionToMonitor(metaTxId, 'ä¸­é–“ãƒ¡ã‚¿ãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³');
                }
                
                // Wait for BlockID using WebSocket monitoring (same pattern as regular meta-tx)
                let metaBlockId = null;
                let waitTime = 0;
                const maxWaitTime = 30000; // 30 seconds max
                
                while (!metaBlockId && waitTime < maxWaitTime) {
                    if (monitoredTransactions.has(metaTxId)) {
                        const monitorData = monitoredTransactions.get(metaTxId);
                        if (monitorData.blockId) {
                            metaBlockId = monitorData.blockId;
                            // Remove from monitoring list
                            monitoredTransactions.delete(metaTxId);
                            log(`[SuperMeta] ä¸­é–“ãƒ¡ã‚¿BlockIDå–å¾—: ${metaBlockId.substring(0, 16)}...`, 'success');
                            break;
                        }
                    }
                    await new Promise(resolve => setTimeout(resolve, 500));
                    waitTime += 500;
                }
                
                if (!metaBlockId) {
                    log(`[SuperMeta] è­¦å‘Š: BlockIDå–å¾—ãŒã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆã—ã¾ã—ãŸ`, 'warning');
                    // Continue without BlockID (REST API fallback will be available)
                }
                
                return {
                    txId: metaTxId,
                    blockId: metaBlockId,
                    groupIndex: groupIndex,
                    chunkRange: metaTxData.chunkStructure.chunkRange
                };
                
            } catch (error) {
                log(`[SuperMeta] ä¸­é–“ãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿ç”Ÿæˆã‚¨ãƒ©ãƒ¼: ${error.message}`, 'error');
                throw error;
            }
        }

        // Create super meta-tx that references all intermediate meta-txs
        async function createSuperMetaTx(intermediateMetaTxs, fileMetadata, password) {
            try {
                log(`[SuperMeta] ã‚¹ãƒ¼ãƒ‘ãƒ¼ãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿ã‚’ç”Ÿæˆä¸­...`, 'info');
                
                // Create super metadata
                const superMetaTxData = {
                    type: "kaspa-meta-tx",
                    version: "3.3",
                    created: new Date().toISOString(),
                    network: config.network,
                    
                    // Mark as super metadata
                    chunkStructure: {
                        type: "super",
                        level: 2,
                        totalChunks: fileMetadata.recovery.totalChunks,
                        hierarchy: {
                            chunksPerMeta: 2,
                            metasPerSuper: intermediateMetaTxs.length
                        }
                    },
                    
                    encryption: fileMetadata.encryption,
                    file: fileMetadata.file,
                    
                    // chunks array contains intermediate meta-tx IDs
                    chunks: intermediateMetaTxs.map(m => m.txId),
                    chunkBlockIds: intermediateMetaTxs.map(m => m.blockId || ''),
                    
                    recovery: {
                        totalChunks: fileMetadata.recovery.totalChunks,
                        checksum: fileMetadata.file.sha256,
                        uploadCost: fileMetadata.recovery.uploadCost
                    },
                    
                    metadata: {
                        hierarchy: {
                            childMetadata: intermediateMetaTxs.map(m => ({
                                index: m.groupIndex,
                                range: m.chunkRange,
                                txId: m.txId,
                                blockId: m.blockId
                            }))
                        },
                        // SuperMetaã«ã¯ãƒãƒ£ãƒ³ã‚¯ãƒã‚¦ãƒ³ãƒ€ãƒªã‚’å«ã‚ãªã„ï¼ˆå®¹é‡åˆ¶é™ã®ãŸã‚ï¼‰
                        // å„ä¸­é–“ãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿ãŒç®¡è½„ã™ã‚‹ãƒãƒ£ãƒ³ã‚¯ã®ãƒã‚¦ãƒ³ãƒ€ãƒªã‚’ä¿æŒ
                        payloadSplit: fileMetadata.metadata?.payloadSplit || false
                    }
                };
                
                // Encrypt and upload
                const metaDataString = JSON.stringify(superMetaTxData);
                const metaDataBytes = new TextEncoder().encode(metaDataString);
                
                const salt = fromBase64(fileMetadata.encryption.pbkdf2.salt);
                const key = await deriveKey(password, salt);
                
                const encryptedMetaData = await encryptChunk(metaDataBytes, key, -1);
                const metaPayload = new Uint8Array(salt.length + encryptedMetaData.length);
                metaPayload.set(salt, 0);
                metaPayload.set(encryptedMetaData, salt.length);
                
                log(`[SuperMeta] ã‚¹ãƒ¼ãƒ‘ãƒ¼ãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿ã‚µã‚¤ã‚º: ${metaDataBytes.length} bytes`, 'debug');
                
                // Upload to blockchain
                const utxoResponse = await rpcClient.getUtxosByAddresses([address.toString()]);
                const entries = utxoResponse.entries || [];
                
                const formattedUtxos = entries.map(utxo => ({
                    address: address.toString(),
                    outpoint: {
                        transactionId: utxo.outpoint.transactionId,
                        index: utxo.outpoint.index
                    },
                    scriptPublicKey: utxo.scriptPublicKey,
                    amount: BigInt(utxo.amount),
                    isCoinbase: utxo.isCoinbase || false,
                    blockDaaScore: BigInt(utxo.blockDaaScore)
                }));
                
                const result = await kaspa.createTransactions({
                    entries: formattedUtxos,
                    outputs: [{
                        address: address.toString(),
                        amount: 100000000n // 1 KAS
                    }],
                    changeAddress: address.toString(),
                    priorityFee: 10000n,
                    networkId: config.network,
                    payload: metaPayload
                });
                
                const pendingTx = result.transactions[0];
                await pendingTx.sign([privateKey]);
                const superMetaTxId = await pendingTx.submit(rpcClient);
                
                log(`[SuperMeta] ã‚¹ãƒ¼ãƒ‘ãƒ¼ãƒ¡ã‚¿TxID: ${superMetaTxId}`, 'success');
                
                // Add to monitoring list for WebSocket
                monitoredTransactions.set(superMetaTxId, {
                    type: 'super-meta',
                    timestamp: Date.now(),
                    blockId: null
                });
                
                // Wait for confirmation
                let superMetaBlockId = null;
                let waitTime = 0;
                while (!superMetaBlockId && waitTime < 30000) {
                    if (monitoredTransactions.has(superMetaTxId)) {
                        const monitorData = monitoredTransactions.get(superMetaTxId);
                        if (monitorData.blockId) {
                            superMetaBlockId = monitorData.blockId;
                            log(`[SuperMeta] ã‚¹ãƒ¼ãƒ‘ãƒ¼ãƒ¡ã‚¿BlockIDå–å¾—: ${superMetaBlockId.substring(0, 16)}...`, 'success');
                            break;
                        }
                    }
                    await new Promise(resolve => setTimeout(resolve, 500));
                    waitTime += 500;
                }
                
                if (!superMetaBlockId) {
                    log(`[SuperMeta] è­¦å‘Š: BlockIDå–å¾—ãŒã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆã—ã¾ã—ãŸ`, 'warning');
                }
                
                return {
                    txId: superMetaTxId,
                    blockId: superMetaBlockId,
                    type: 'super',
                    metaCount: intermediateMetaTxs.length
                };
                
            } catch (error) {
                log(`[SuperMeta] ã‚¹ãƒ¼ãƒ‘ãƒ¼ãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿ç”Ÿæˆã‚¨ãƒ©ãƒ¼: ${error.message}`, 'error');
                throw error;
            }
        }

        // Load directory metadata
        async function loadDirectoryMetadata(dirMetadata) {
            try {
                log('ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿ã‚’å‡¦ç†ä¸­...', 'info');
                
                // ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªæƒ…å ±ã‚’è¡¨ç¤º
                const totalSize = dirMetadata.directory?.totalSize || 0;
                const fileCount = dirMetadata.directory?.fileCount || 0;
                const dirCount = dirMetadata.directory?.directoryCount || 0;
                
                document.getElementById('fileInfo').innerHTML = 
                    `<strong>ğŸ“ ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒª: ${dirMetadata.directory.name}</strong><br>` +
                    `ã‚¿ã‚¤ãƒ—: ${dirMetadata.type}<br>` +
                    `ãƒãƒ¼ã‚¸ãƒ§ãƒ³: ${dirMetadata.version}<br>` +
                    `ãƒ•ã‚¡ã‚¤ãƒ«æ•°: ${fileCount}<br>` +
                    `ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªæ•°: ${dirCount}<br>` +
                    `åˆè¨ˆã‚µã‚¤ã‚º: ${(totalSize/1024/1024).toFixed(2)}MB<br>` +
                    `ä½œæˆæ—¥æ™‚: ${new Date(dirMetadata.created).toLocaleString()}<br>`;
                
                // ãƒ•ã‚¡ã‚¤ãƒ«ä¸€è¦§ã‚’è¡¨ç¤º
                if (dirMetadata.entries && dirMetadata.entries.length > 0) {
                    log(`ãƒ•ã‚¡ã‚¤ãƒ«ä¸€è¦§ã‚’ç”Ÿæˆä¸­: ${dirMetadata.entries.length}ä»¶`, 'info');
                    let fileListHtml = '<br><strong>ğŸ“‹ ãƒ•ã‚¡ã‚¤ãƒ«ä¸€è¦§:</strong><br>';
                    fileListHtml += '<div style="max-height: 300px; overflow-y: auto; border: 1px solid #333; padding: 10px; margin-top: 10px; background: #0a2540;">';
                    
                    dirMetadata.entries.forEach((entry, index) => {
                        log(`ã‚¨ãƒ³ãƒˆãƒª${index}: ${entry.name}, MetaTxID: ${entry.metaTxId ? 'æœ‰' : 'ç„¡'}`, 'debug');
                        const icon = entry.type === 'directory' ? 'ğŸ“' : 'ğŸ“„';
                        const size = entry.size ? `${(entry.size/1024).toFixed(1)}KB` : '-';
                        const hasMetaTx = entry.metaTxId ? 'âœ…' : 'âŒ';
                        
                        const borderStyle = index === dirMetadata.entries.length - 1 ? 'border-bottom: none;' : '';
                        // v4.6.30: DOMæ“ä½œã«ã‚ˆã‚‹å®‰å…¨ãªãƒœã‚¿ãƒ³ç”Ÿæˆï¼ˆã‚¹ã‚³ãƒ¼ãƒ—ä¿®æ­£ï¼‰
                        let buttonsContainer = null;
                        
                        if (entry.metaTxId) {
                            buttonsContainer = document.createElement('span');
                            const txId = entry.metaTxId || '';
                            const blkId = entry.blockId || '';
                            const pwd = dirMetadata.auth?.password || '';
                            const fileName = entry.name || '';
                            
                            // ã‚³ãƒ”ãƒ¼ãƒœã‚¿ãƒ³
                            const copyBtn = document.createElement('button');
                            copyBtn.className = 'small-button';
                            copyBtn.style.marginLeft = '10px';
                            copyBtn.textContent = 'ğŸ“‹';
                            copyBtn.onclick = () => copyToClipboard(`${txId}:${blkId}`);
                            buttonsContainer.appendChild(copyBtn);
                            
                            // ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ãƒœã‚¿ãƒ³
                            const dlBtn = document.createElement('button');
                            dlBtn.className = 'small-button';
                            dlBtn.style.marginLeft = '5px';
                            dlBtn.textContent = 'ğŸ“¥';
                            dlBtn.onclick = () => {
                                log(`[DEBUG] Download button clicked for: ${fileName}`, 'debug');
                                // v4.7.8: pathã‚‚æ¸¡ã™
                                downloadFileFromDirectory(txId, blkId, fileName, pwd, entry.path || null);
                            };
                            buttonsContainer.appendChild(dlBtn);
                            
                            log(`[DEBUG] DOMæ“ä½œã§ãƒœã‚¿ãƒ³ã‚’ç”Ÿæˆ: ${fileName}`, 'debug');
                            log(`[DEBUG] buttonsContainerå­è¦ç´ æ•°: ${buttonsContainer.children.length}`, 'debug');
                            log(`[DEBUG] buttonsContainer HTML: ${buttonsContainer.innerHTML}`, 'debug');
                            // v4.6.30: ã‚¨ã‚¹ã‚±ãƒ¼ãƒ—ãƒã‚§ãƒƒã‚¯ã¯ä¸è¦ï¼ˆDOMæ“ä½œãªã®ã§ï¼‰
                        }
                        
                        fileListHtml += '<div style="padding: 5px; border-bottom: 1px solid #444; ' + borderStyle + '">';
                        fileListHtml += '<div style="display: flex; justify-content: space-between; align-items: center;">';
                        fileListHtml += '<span>' + icon + ' ' + (entry.path || entry.name) + '</span>';
                        // v4.6.29: rightSpanã‚’ãƒ—ãƒ¬ãƒ¼ã‚¹ãƒ›ãƒ«ãƒ€ãƒ¼IDã§ä¸€æ™‚çš„ã«ç½®ãæ›ãˆ
                        const placeholderId = `buttons_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
                        const rightSpan = `<span style="font-size: 12px; color: #999;">${size} | MetaTx: ${hasMetaTx} <span id="${placeholderId}"></span></span>`;
                        fileListHtml += rightSpan;
                        
                        // ãƒœã‚¿ãƒ³ã‚³ãƒ³ãƒ†ãƒŠã‚’å¾Œã§æŒ¿å…¥ã™ã‚‹ãŸã‚ã«ä¿å­˜ï¼ˆbuttonsContainerãŒå­˜åœ¨ã™ã‚‹å ´åˆã®ã¿ï¼‰
                        if (buttonsContainer) {
                            if (!window.pendingButtons) window.pendingButtons = [];
                            window.pendingButtons.push({ id: placeholderId, container: buttonsContainer });
                        }
                        fileListHtml += '</div></div>';
                    });
                    
                    fileListHtml += '</div>';
                    fileListHtml += `<br><div style="font-size: 12px; color: #999;">ğŸ“¥ ãƒœã‚¿ãƒ³ã‚’ã‚¯ãƒªãƒƒã‚¯ã—ã¦å€‹åˆ¥ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰</div>`;
                    
                    log(`[DEBUG] æœ€çµ‚çš„ãªfileListHtmlé•·ã•: ${fileListHtml.length}æ–‡å­—`, 'debug');
                    log(`[DEBUG] fileListHtmlã®ä¸€éƒ¨: ${fileListHtml.substring(0, 200)}...`, 'debug');
                    
                    // innerHTMLè¨­å®šç›´å‰ã®ã‚¨ã‚¹ã‚±ãƒ¼ãƒ—ãƒã‚§ãƒƒã‚¯
                    if (fileListHtml.includes('&apos;')) {
                        log('[DEBUG] âš ï¸ fileListHtmlã«&apos;ãŒå«ã¾ã‚Œã¦ã„ã¾ã™ï¼', 'error');
                        const count = (fileListHtml.match(/&apos;/g) || []).length;
                        log(`[DEBUG] &apos;ã®æ•°: ${count}å€‹`, 'error');
                    }
                    
                    const fileInfoElement = document.getElementById('fileInfo');
                    log(`[DEBUG] fileInfoè¦ç´ : ${fileInfoElement ? 'å­˜åœ¨' : 'å­˜åœ¨ã—ãªã„'}`, 'debug');
                    
                    if (fileInfoElement) {
                        const beforeLength = fileInfoElement.innerHTML.length;
                        fileInfoElement.innerHTML += fileListHtml;
                        const afterLength = fileInfoElement.innerHTML.length;
                        log(`[DEBUG] innerHTMLæ›´æ–°: ${beforeLength}æ–‡å­— â†’ ${afterLength}æ–‡å­—`, 'debug');
                        
                        // v4.6.31: DOMæ“ä½œã§ãƒœã‚¿ãƒ³ã‚’æŒ¿å…¥ï¼ˆè©³ç´°ãƒ‡ãƒãƒƒã‚°è¿½åŠ ï¼‰
                        log(`[DEBUG] pendingButtonsç¢ºèª: ${window.pendingButtons ? window.pendingButtons.length + 'ä»¶' : 'æœªå®šç¾©'}`, 'debug');
                        
                        if (window.pendingButtons && window.pendingButtons.length > 0) {
                            log(`[DEBUG] pendingButtonsè©³ç´°:`, 'debug');
                            window.pendingButtons.forEach(({ id, container }, index) => {
                                log(`[DEBUG]   [${index}] ID: ${id}`, 'debug');
                                log(`[DEBUG]   [${index}] Container: ${container ? container.tagName : 'null'}`, 'debug');
                                log(`[DEBUG]   [${index}] Containerå­è¦ç´ æ•°: ${container ? container.children.length : 0}`, 'debug');
                                
                                const placeholder = document.getElementById(id);
                                log(`[DEBUG]   [${index}] Placeholderæ¤œç´¢çµæœ: ${placeholder ? 'å­˜åœ¨' : 'å­˜åœ¨ã—ãªã„'}`, 'debug');
                                
                                if (placeholder) {
                                    log(`[DEBUG]   [${index}] appendChildå‰ã®placeHolderå†…å®¹: "${placeholder.innerHTML}"`, 'debug');
                                    placeholder.appendChild(container);
                                    log(`[DEBUG]   [${index}] appendChildå¾Œã®placeHolderå†…å®¹: "${placeholder.innerHTML}"`, 'debug');
                                    log(`[DEBUG]   [${index}] appendChildå¾Œã®placeHolder.textContent: "${placeholder.textContent}"`, 'debug');
                                    log(`[DEBUG]   [${index}] appendChildå¾Œã®placeHolder.children.length: ${placeholder.children.length}`, 'debug');
                                    log(`[DEBUG] ãƒœã‚¿ãƒ³ã‚’DOMæ“ä½œã§æŒ¿å…¥: ${id}`, 'debug');
                                } else {
                                    log(`[ERROR] Placeholder ID "${id}" ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“`, 'error');
                                }
                            });
                            window.pendingButtons = [];
                        } else {
                            log(`[DEBUG] pendingButtonsãŒç©ºã¾ãŸã¯æœªå®šç¾©ã®ãŸã‚ã€ãƒœã‚¿ãƒ³æŒ¿å…¥ã‚’ã‚¹ã‚­ãƒƒãƒ—`, 'debug');
                        }
                        
                        // v4.6.32: ãƒœã‚¿ãƒ³è¡¨ç¤ºç¢ºèªã®ãƒ‡ãƒãƒƒã‚°
                        setTimeout(() => {
                            const allButtons = fileInfoElement.querySelectorAll('button');
                            log(`[DEBUG] æœ€çµ‚çš„ãªãƒœã‚¿ãƒ³æ•°: ${allButtons.length}å€‹`, 'warning');
                            allButtons.forEach((btn, i) => {
                                log(`[DEBUG] ãƒœã‚¿ãƒ³${i}: ${btn.textContent}, display: ${window.getComputedStyle(btn).display}, visibility: ${window.getComputedStyle(btn).visibility}`, 'debug');
                            });
                            
                            // ãƒ—ãƒ¬ãƒ¼ã‚¹ãƒ›ãƒ«ãƒ€ãƒ¼ã®ç¢ºèª
                            const placeholders = fileInfoElement.querySelectorAll('span[id^="buttons_"]');
                            log(`[DEBUG] ãƒ—ãƒ¬ãƒ¼ã‚¹ãƒ›ãƒ«ãƒ€ãƒ¼æ•°: ${placeholders.length}å€‹`, 'debug');
                            placeholders.forEach((ph, i) => {
                                log(`[DEBUG] ãƒ—ãƒ¬ãƒ¼ã‚¹ãƒ›ãƒ«ãƒ€ãƒ¼${i}: ID=${ph.id}, å­è¦ç´ æ•°=${ph.children.length}`, 'debug');
                            });
                        }, 500);
                    }
                } else {
                    document.getElementById('fileInfo').innerHTML += '<br><strong>âš ï¸ ãƒ•ã‚¡ã‚¤ãƒ«ä¸€è¦§æƒ…å ±ãŒã‚ã‚Šã¾ã›ã‚“</strong>';
                }
                
                // ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰å‡¦ç†ï¼ˆv4.6.26: DOMæ“ä½œã®å®‰å…¨æ€§ã‚’æ”¹å–„ï¼‰
                const passwordSection = document.getElementById('passwordSection');
                if (dirMetadata.auth?.passwordIncluded) {
                    // æ—¢å­˜ã®è¦ç´ ã‚’å®‰å…¨ã«æ“ä½œ
                    const passwordInput = document.getElementById('downloadPassword');
                    if (passwordInput) {
                        passwordInput.style.display = 'none';
                        passwordInput.value = dirMetadata.auth.password;
                    }
                    
                    // ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰å€¤ã‚’ä¿æŒã—ãªãŒã‚‰UIã‚’æ›´æ–°
                    const savedPassword = dirMetadata.auth.password;
                    passwordSection.innerHTML = '<p>âœ… ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ãŒãƒ•ã‚¡ã‚¤ãƒ«ã«å«ã¾ã‚Œã¦ã„ã¾ã™ï¼ˆè‡ªå‹•å…¥åŠ›ï¼‰</p>' +
                        `<input type="hidden" id="downloadPassword" value="${savedPassword}">`;
                } else {
                    passwordSection.innerHTML = '<input type="password" id="downloadPassword" placeholder="ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ã‚’å…¥åŠ›">';
                }
                
                // v4.7.9: ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ãƒœã‚¿ãƒ³ã‚’ãƒ•ã‚©ãƒ«ãƒ€ä¸€æ‹¬ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ç”¨ã«è¨­å®š
                const downloadBtn = document.getElementById('downloadBtn');
                if (downloadBtn) {
                    downloadBtn.disabled = false;
                    downloadBtn.textContent = 'ãƒ•ã‚©ãƒ«ãƒ€ä¸€æ‹¬ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰';
                    downloadBtn.onclick = async () => {
                        await downloadAllFilesFromDirectory(dirMetadata);
                    };
                }
                
                // v4.6.33: ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã‚¿ã‚¤ãƒ—ã§ã‚‚ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã‚’è¡¨ç¤º
                document.getElementById('downloadSection').style.display = 'block';
                
                log('ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªæƒ…å ±ã®è¡¨ç¤ºå®Œäº†', 'success');
                
            } catch (error) {
                log(`ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿å‡¦ç†ã‚¨ãƒ©ãƒ¼: ${error.message}`, 'error');
            }
        }

        // v4.7.9: Download all files from directory
        window.downloadAllFilesFromDirectory = async function(dirMetadata) {
            log('[ä¸€æ‹¬ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰] ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªå†…ã®å…¨ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰é–‹å§‹', 'info');
            
            // Check workspace handle
            if (!window.workspaceHandle) {
                log('ä½œæ¥­ãƒ•ã‚©ãƒ«ãƒ€ãŒè¨­å®šã•ã‚Œã¦ã„ã¾ã›ã‚“ã€‚å…ˆã«è¨­å®šã—ã¦ãã ã•ã„ã€‚', 'error');
                alert('ä½œæ¥­ãƒ•ã‚©ãƒ«ãƒ€ãŒè¨­å®šã•ã‚Œã¦ã„ã¾ã›ã‚“ã€‚\nç”»é¢ä¸Šéƒ¨ã®ã€Œè¨­å®šã€ãƒœã‚¿ãƒ³ã‹ã‚‰ä½œæ¥­ãƒ•ã‚©ãƒ«ãƒ€ã‚’é¸æŠã—ã¦ãã ã•ã„ã€‚');
                await setupWorkspace();
                return;
            }
            
            try {
                // Get password
                let password = document.getElementById('downloadPassword').value;
                if (!password && dirMetadata.auth?.password) {
                    password = dirMetadata.auth.password;
                }
                
                if (!password || password.length < 8) {
                    log('ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ãŒå¿…è¦ã§ã™', 'error');
                    return;
                }
                
                // Create base directory
                const baseDirName = dirMetadata.directory?.name || 'download';
                let targetHandle = window.workspaceHandle;
                
                try {
                    targetHandle = await window.workspaceHandle.getDirectoryHandle(baseDirName, { create: true });
                    log(`[ä¸€æ‹¬ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰] ãƒ™ãƒ¼ã‚¹ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªä½œæˆ/å–å¾—: ${baseDirName}`, 'info');
                } catch (e) {
                    log(`[ä¸€æ‹¬ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰] ãƒ™ãƒ¼ã‚¹ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªä½œæˆã‚¨ãƒ©ãƒ¼: ${e.message}`, 'error');
                }
                
                // Process each entry
                const entries = dirMetadata.entries || [];
                const totalFiles = entries.filter(e => e.type === 'file').length;
                let completedFiles = 0;
                let skippedFiles = 0;
                let errorFiles = 0;
                
                document.getElementById('downloadProgress').style.display = 'block';
                
                for (const entry of entries) {
                    if (entry.type !== 'file') continue;
                    
                    try {
                        // Check if file already exists
                        let fileExists = false;
                        let currentTargetHandle = targetHandle;
                        
                        // Create subdirectories if path exists
                        if (entry.path) {
                            const pathParts = entry.path.split('/');
                            pathParts.pop(); // Remove filename
                            
                            for (const part of pathParts) {
                                if (part) {
                                    try {
                                        currentTargetHandle = await currentTargetHandle.getDirectoryHandle(part, { create: true });
                                    } catch (e) {
                                        log(`[ä¸€æ‹¬ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰] ã‚µãƒ–ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªä½œæˆã‚¨ãƒ©ãƒ¼: ${part}`, 'error');
                                    }
                                }
                            }
                        }
                        
                        // Check if file exists
                        try {
                            await currentTargetHandle.getFileHandle(entry.name);
                            fileExists = true;
                        } catch (e) {
                            // File doesn't exist, which is what we want
                        }
                        
                        if (fileExists) {
                            skippedFiles++;
                            log(`[ä¸€æ‹¬ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰] ã‚¹ã‚­ãƒƒãƒ—ï¼ˆæ—¢å­˜ï¼‰: ${entry.path || entry.name}`, 'info');
                            document.getElementById('downloadStatus').textContent = 
                                `${completedFiles + skippedFiles}/${totalFiles} ãƒ•ã‚¡ã‚¤ãƒ« (${skippedFiles}å€‹ã‚¹ã‚­ãƒƒãƒ—)`;
                            continue;
                        }
                        
                        // Download file
                        log(`[ä¸€æ‹¬ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰] ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ä¸­: ${entry.path || entry.name}`, 'info');
                        document.getElementById('downloadStatus').textContent = 
                            `ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ä¸­: ${entry.name} (${completedFiles + skippedFiles + 1}/${totalFiles})`;
                        
                        // Use DownloadManager
                        if (!window.downloadManager) {
                            window.downloadManager = new DownloadManager();
                        }
                        
                        const metadata = await window.downloadManager.fetchMetadata(entry.metaTxId, entry.blockId, password);
                        
                        const folderStructureOption = {
                            enabled: true,
                            basePath: baseDirName, // Use directory name instead of handle
                            filePath: entry.path || entry.name
                            // v4.7.12: Remove targetHandle to force folder picker each time
                        };
                        
                        await window.downloadManager.executeDownload(metadata, password, {
                            onProgress: (progress) => {
                                const percent = ((completedFiles + progress.current/progress.total) / totalFiles * 100).toFixed(0);
                                document.getElementById('downloadProgressBar').style.width = percent + '%';
                                document.getElementById('downloadProgressBar').textContent = percent + '%';
                            },
                            folderStructure: folderStructureOption
                        });
                        
                        completedFiles++;
                        
                    } catch (error) {
                        errorFiles++;
                        log(`[ä¸€æ‹¬ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰] ã‚¨ãƒ©ãƒ¼: ${entry.name} - ${error.message}`, 'error');
                    }
                }
                
                // Summary
                const summary = `å®Œäº†: ${completedFiles}å€‹, ã‚¹ã‚­ãƒƒãƒ—: ${skippedFiles}å€‹, ã‚¨ãƒ©ãƒ¼: ${errorFiles}å€‹`;
                log(`[ä¸€æ‹¬ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰] å®Œäº† - ${summary}`, 'success');
                document.getElementById('downloadStatus').textContent = summary;
                
                setTimeout(() => {
                    document.getElementById('downloadProgress').style.display = 'none';
                }, 3000);
                
            } catch (error) {
                log(`[ä¸€æ‹¬ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰] ã‚¨ãƒ©ãƒ¼: ${error.message}`, 'error');
                document.getElementById('downloadProgress').style.display = 'none';
            }
        };

        // Download individual file from directory
        window.downloadFileFromDirectory = async function(metaTxId, blockId, fileName, password, filePath) {
            // v4.7.8: DownloadManagerã‚’ä½¿ç”¨ã—ãŸãƒ•ã‚©ãƒ«ãƒ€æ§‹é€ å¯¾å¿œå®Ÿè£…
            log(`[DownloadManager] ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªå†…ãƒ•ã‚¡ã‚¤ãƒ«ã®ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰é–‹å§‹: ${fileName}`, 'info');
            if (filePath) {
                log(`[DownloadManager] ãƒ•ã‚¡ã‚¤ãƒ«ãƒ‘ã‚¹: ${filePath}`, 'info');
            }
            
            try {
                // ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ç¢ºèª
                if (!password || password.length < 8) {
                    password = prompt('ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„ï¼ˆ8æ–‡å­—ä»¥ä¸Šï¼‰:');
                    if (!password || password.length < 8) {
                        log('ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ã¯8æ–‡å­—ä»¥ä¸Šå¿…è¦ã§ã™', 'error');
                        return;
                    }
                }
                
                // DownloadManagerã‚’ä½¿ç”¨
                if (!window.downloadManager) {
                    log('[DownloadManager] åˆæœŸåŒ–ã•ã‚Œã¦ã„ã¾ã›ã‚“', 'error');
                    return;
                }
                
                if (!window.downloadManager.isReady()) {
                    log('[DownloadManager] ç¾åœ¨ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ä¸­ã§ã™', 'warning');
                    return;
                }
                
                // é€²æ—è¡¨ç¤º
                document.getElementById('downloadProgress').style.display = 'block';
                document.getElementById('downloadStatus').textContent = 'ãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—ä¸­...';
                
                // ãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿å–å¾—
                const metadata = await window.downloadManager.fetchMetadata(metaTxId, blockId, password);
                
                // v4.7.8: ãƒ•ã‚©ãƒ«ãƒ€æ§‹é€ ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã‚’è¿½åŠ 
                const folderStructureOption = (filePath && window.currentDirectoryMetadata) ? {
                    enabled: true,
                    basePath: window.currentDirectoryMetadata.directory?.name || null,
                    filePath: filePath
                } : null;
                
                // ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰å®Ÿè¡Œ
                await window.downloadManager.executeDownload(metadata, password, {
                    onProgress: (progress) => {
                        document.getElementById('downloadProgressBar').style.width = progress.percent + '%';
                        document.getElementById('downloadProgressBar').textContent = progress.percent + '%';
                        document.getElementById('downloadStatus').textContent = 
                            `ãƒãƒ£ãƒ³ã‚¯ ${progress.current}/${progress.total} ã‚’ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ä¸­...`;
                    },
                    onComplete: (blob, filename) => {
                        // ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰å®Œäº†ï¼ˆãƒ•ã‚©ãƒ«ãƒ€æ§‹é€ ã‚’ä½¿ç”¨ã—ãŸå ´åˆã¯ã“ã“ã¯å‘¼ã°ã‚Œãªã„ï¼‰
                        log(`[DownloadManager] ${filename} ã®ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ãŒå®Œäº†ã—ã¾ã—ãŸ`, 'success');
                        document.getElementById('downloadProgress').style.display = 'none';
                    },
                    folderStructure: folderStructureOption
                });
                
            } catch (error) {
                log(`[DownloadManager] ã‚¨ãƒ©ãƒ¼: ${error.message}`, 'error');
                document.getElementById('downloadProgress').style.display = 'none';
            }
        };

        // Load .kaspa file
        window.loadKaspaFile = async function(event) {
            log('=== loadKaspaFile é–‹å§‹ ===', 'info');
            log(`event: ${event}`, 'info');
            log(`event.target: ${event?.target}`, 'info');
            log(`event.target.files: ${event?.target?.files}`, 'info');
            log(`files.length: ${event?.target?.files?.length || 0}`, 'info');
            
            // v4.7.14: Clear previous metadata
            kaspaMetadata = null;
            if (window.downloadManager) {
                window.downloadManager.clearMetadata();
            }
            
            const file = event?.target?.files?.[0];
            log(`file: ${file}`, 'info');
            
            if (file) {
                log(`file.name: ${file.name}`, 'info');
                log(`file.type: ${file.type}`, 'info');
                log(`file.size: ${file.size} bytes`, 'info');
                log(`endsWith('.kaspa'): ${file.name.endsWith('.kaspa')}`, 'info');
                log(`toLowerCase().endsWith('.kaspa'): ${file.name.toLowerCase().endsWith('.kaspa')}`, 'info');
            }
            
            if (!file || !file.name.endsWith('.kaspa')) {
                log('æœ‰åŠ¹ãª.kaspaãƒ•ã‚¡ã‚¤ãƒ«ã‚’é¸æŠã—ã¦ãã ã•ã„', 'error');
                log(`ç†ç”±: file=${!!file}, name=${file?.name}, endsWith=${file?.name?.endsWith('.kaspa')}`, 'error');
                return;
            }
            
            try {
                log('ãƒ•ã‚¡ã‚¤ãƒ«å†…å®¹ã‚’èª­ã¿è¾¼ã¿ä¸­...', 'info');
                const content = await file.text();
                log(`ãƒ•ã‚¡ã‚¤ãƒ«å†…å®¹ã®é•·ã•: ${content.length} æ–‡å­—`, 'info');
                log(`æœ€åˆã®100æ–‡å­—: ${content.substring(0, 100)}...`, 'info');
                
                kaspaMetadata = JSON.parse(content);
                log('JSON parseæˆåŠŸ', 'info');
                log(`kaspaMetadata.version: ${kaspaMetadata.version}`, 'info');
                log(`kaspaMetadata.type: ${kaspaMetadata.type}`, 'info');
                log(`kaspaMetadata.chunks: ${kaspaMetadata.chunks?.length || 0} chunks`, 'info');
                log(`kaspaMetadata.auth: ${JSON.stringify(kaspaMetadata.auth)}`, 'info');
                
                // çµ±ä¸€ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰å‡¦ç† - ã‚¿ã‚¤ãƒ—åˆ¥ã«å‡¦ç†
                if (!kaspaMetadata.version) {
                    throw new Error('ç„¡åŠ¹ãª.kaspaãƒ•ã‚¡ã‚¤ãƒ«å½¢å¼');
                }
                
                // ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã‚¿ã‚¤ãƒ—ã®å ´åˆ
                if (kaspaMetadata.type === 'kaspa-directory') {
                    log('ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿ã‚’æ¤œå‡ºã—ã¾ã—ãŸ', 'info');
                    // v4.6.36: ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªå°‚ç”¨å¤‰æ•°ã«ä¿å­˜
                    window.directoryMetadata = kaspaMetadata;
                    window.currentDirectoryMetadata = kaspaMetadata; // v4.7.8: ãƒ•ã‚©ãƒ«ãƒ€æ§‹é€ ç”¨ã«ä¿æŒ
                    window.kaspaMetadata = null; // é€šå¸¸ã®ãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿ã‚’ã‚¯ãƒªã‚¢
                    await loadDirectoryMetadata(window.directoryMetadata);
                    return;
                }
                
                // é€šå¸¸ãƒ•ã‚¡ã‚¤ãƒ«ã®å ´åˆ
                if (!kaspaMetadata.chunks) {
                    throw new Error('ç„¡åŠ¹ãª.kaspaãƒ•ã‚¡ã‚¤ãƒ«å½¢å¼');
                }
                
                // v3.6.5 fix: Check for different metadata structures and cost fields
                const network = kaspaMetadata.kaspa?.network || kaspaMetadata.network || 'unknown';
                const createdAt = kaspaMetadata.metadata?.createdAt || kaspaMetadata.created || new Date().toISOString();
                const totalKAS = kaspaMetadata.metadata?.totalKAS || kaspaMetadata.recovery?.uploadCost || 0;
                
                document.getElementById('fileInfo').textContent = 
                    `ãƒ•ã‚¡ã‚¤ãƒ«: ${kaspaMetadata.file.name}\n` +
                    `ã‚µã‚¤ã‚º: ${(kaspaMetadata.file.size/1024/1024).toFixed(2)}MB\n` +
                    `ãƒãƒ£ãƒ³ã‚¯: ${kaspaMetadata.chunks.length}\n` +
                    `ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯: ${network}\n` +
                    `ä½œæˆæ—¥æ™‚: ${new Date(createdAt).toLocaleString()}\n` +
                    `ã‚³ã‚¹ãƒˆ: ${totalKAS.toFixed(5)} KAS`;
                
                // Handle password
                const passwordSection = document.getElementById('passwordSection');
                if (kaspaMetadata.auth?.passwordIncluded) {
                    // Keep the password input field but hide it
                    document.getElementById('downloadPassword').style.display = 'none';
                    document.getElementById('downloadPassword').value = kaspaMetadata.auth.password;
                    
                    // Show info message
                    const infoDiv = document.createElement('div');
                    infoDiv.className = 'metric-box';
                    infoDiv.innerHTML = '<p class="success">âœ… ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ã¯.kaspaãƒ•ã‚¡ã‚¤ãƒ«ã«å«ã¾ã‚Œã¦ã„ã¾ã™</p>';
                    passwordSection.insertBefore(infoDiv, passwordSection.firstChild);
                } else {
                    // Show password input
                    document.getElementById('downloadPassword').style.display = 'block';
                }
                
                document.getElementById('downloadSection').style.display = 'block';
                log('.kaspaãƒ•ã‚¡ã‚¤ãƒ«ã‚’èª­ã¿è¾¼ã¿ã¾ã—ãŸ', 'success');
                
            } catch (error) {
                log(`.kaspaãƒ•ã‚¡ã‚¤ãƒ«èª­ã¿è¾¼ã¿ã‚¨ãƒ©ãƒ¼: ${error.message}`, 'error');
            }
        };

        // Load from Meta-TxID
        // Unified input handler
        window.loadFromUnifiedInput = async function() {
            const txIdInput = document.getElementById('unifiedTxIdInput').value.trim();
            const password = document.getElementById('unifiedPassword').value;
            
            if (!txIdInput) {
                log('TxIDã‚’å…¥åŠ›ã—ã¦ãã ã•ã„', 'error');
                return;
            }
            
            log(`çµ±ä¸€å…¥åŠ›ã‹ã‚‰å¾©å…ƒé–‹å§‹: ${txIdInput.substring(0, 20)}...`, 'info');
            
            // v4.7.14: Clear previous metadata in DownloadManager
            if (window.downloadManager) {
                window.downloadManager.clearMetadata();
            }
            
            // Use existing loadFromMetaTxId logic
            document.getElementById('metaTxIdInput').value = txIdInput;
            document.getElementById('metaTxPassword').value = password;
            await loadFromMetaTxId();
        };

        window.loadFromMetaTxId = async function() {
            // v4.7.14: Clear previous global metadata to prevent reuse
            kaspaMetadata = null;
            
            const metaTxIdInput = document.getElementById('metaTxIdInput').value.trim();
            let passwordFromField = document.getElementById('metaTxPassword').value;
            
            // Check input format (supports 3 patterns)
            let metaTxId, blockId, password;
            const parts = metaTxIdInput.split(':');
            
            if (parts.length === 3) {
                // Format: TxID:BlockID:Password
                metaTxId = parts[0];
                blockId = parts[1];
                password = parts[2];
                log(`TxID:BlockID:Passwordå½¢å¼ã§å¾©å…ƒ: ${metaTxId.substring(0, 16)}...:${blockId.substring(0, 16)}...:****`, 'info');
                
                // Auto-fill password field for user visibility
                document.getElementById('metaTxPassword').value = password;
            } else if (parts.length === 2) {
                // Format: TxID:BlockID
                metaTxId = parts[0];
                blockId = parts[1];
                password = passwordFromField;
                log(`TxID:BlockIDå½¢å¼ã§å¾©å…ƒ: ${metaTxId.substring(0, 16)}...:${blockId.substring(0, 16)}...`, 'info');
            } else {
                // Format: TxID only
                metaTxId = parts[0];
                blockId = null;
                password = passwordFromField;
                log(`ãƒ¡ã‚¿TxIDã®ã¿ã§å¾©å…ƒï¼ˆREST APIä½¿ç”¨ï¼‰: ${metaTxId.substring(0, 16)}...`, 'info');
            }
            
            if (!metaTxId || metaTxId.length !== 64) {
                log('æœ‰åŠ¹ãªãƒ¡ã‚¿TxIDï¼ˆ64æ–‡å­—ï¼‰ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„', 'error');
                return;
            }
            
            if (blockId && blockId.length !== 64) {
                log('æœ‰åŠ¹ãªBlockIDï¼ˆ64æ–‡å­—ï¼‰ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„', 'error');
                return;
            }
            
            if (!password) {
                log('ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„', 'error');
                return;
            }
            
            if (!rpcClient) {
                log('å…ˆã«ã‚·ã‚¹ãƒ†ãƒ ã‚’åˆæœŸåŒ–ã—ã¦ãã ã•ã„', 'error');
                return;
            }
            
            try {
                // Get transaction from blockchain
                let payload = null;
                
                // If we have BlockID, use RPC directly (no REST API needed)
                if (blockId) {
                    log(`BlockIDã‚’ä½¿ç”¨ã—ã¦RPCçµŒç”±ã§å–å¾—ä¸­...`, 'info');
                    try {
                        const blockResponse = await rpcClient.getBlock({
                            hash: blockId,
                            includeTransactions: true
                        });
                        
                        const block = blockResponse?.block?.block || blockResponse?.block;
                        if (!block) {
                            throw new Error(`ãƒ–ãƒ­ãƒƒã‚¯ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“: ${blockId}`);
                        }
                        
                        // Find the meta transaction in the block
                        for (const tx of block.transactions || []) {
                            const txId = tx.verboseData?.transactionId || tx.id || tx.transactionId;
                            if (txId === metaTxId) {
                                if (tx.payload && tx.payload !== '') {
                                    const hexPayload = tx.payload;
                                    payload = safeHexDecode(hexPayload, 'meta-tx payload from RPC');
                                    log(`ãƒ¡ã‚¿ãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³ã‚’ãƒ–ãƒ­ãƒƒã‚¯ã‹ã‚‰å–å¾—: ${payload.length} bytes`, 'success');
                                    break;
                                }
                            }
                        }
                        
                        if (!payload) {
                            throw new Error(`ãƒ–ãƒ­ãƒƒã‚¯å†…ã«ãƒ¡ã‚¿ãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“`);
                        }
                    } catch (rpcError) {
                        log(`RPCã‚¨ãƒ©ãƒ¼: ${rpcError.message}`, 'error');
                        throw rpcError;
                    }
                } else {
                    // Fall back to REST API if no BlockID provided
                    log(`ãƒ¡ã‚¿TxID ${metaTxId.substring(0, 16)}... ã‹ã‚‰REST APIçµŒç”±ã§å¾©å…ƒã‚’é–‹å§‹`, 'info');
                    
                    try {
                    // First try to get via Explorer API (more reliable)
                    log('Explorer APIçµŒç”±ã§ãƒ¡ã‚¿ãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³ã‚’å–å¾—ä¸­...', 'info');
                    const apiUrl = `https://api-tn10.kaspa.org/transactions/${metaTxId}`;
                    const response = await fetchWithTimeout(apiUrl, {}, 15000, 3); // 15s timeout, 3 retries
                    
                    if (response.ok) {
                        const data = await response.json();
                        
                        log(`Transaction data received, checking for payload...`, 'info');
                        
                        // First, check if there's a direct payload field
                        if (data.payload) {
                            log(`Found direct payload field, length: ${data.payload.length} chars`, 'info');
                            log(`Payload preview: ${data.payload.substring(0, 100)}...`, 'info');
                            
                            // The payload is a hex string, convert it to bytes
                            const hexString = data.payload;
                            
                            // Check if it's valid hex
                            if (!/^[0-9a-fA-F]+$/.test(hexString)) {
                                log('Warning: Payload contains non-hex characters', 'warning');
                            }
                            
                            // The blockchain returns the payload as hex, decode it directly
                            // Same as chunk download (line 1746)
                            payload = safeHexDecode(hexString, 'meta-tx payload from REST API');
                            log(`Decoded payload: ${payload.length} bytes`, 'info');
                            
                        } else if (data.outputs && data.outputs.length > 0) {
                            // Extract payload from transaction outputs
                            log(`Checking ${data.outputs.length} outputs for payload...`, 'info');
                            
                            for (let i = 0; i < data.outputs.length; i++) {
                                const output = data.outputs[i];
                                log(`Output ${i}: type=${output.script_public_key_type || output.scriptPublicKeyType}, script length=${output.script_public_key?.length || output.scriptPublicKey?.scriptPublicKey?.length || 0}`, 'info');
                                log(`Output structure: ${JSON.stringify(Object.keys(output))}`, 'debug');
                                
                                if (output.script_public_key_type === 'pubkey' && output.script_public_key) {
                                    const scriptHex = output.script_public_key || output.scriptPublicKey?.scriptPublicKey;
                                    
                                    if (!scriptHex) {
                                        log(`Warning: No script found in output ${i}`, 'warning');
                                        continue;
                                    }
                                    
                                    // In Kaspa, payload transactions have a different script structure
                                    // The script should contain the payload data embedded
                                    if (scriptHex.length > 140) {
                                        log(`Found long script (${scriptHex.length} chars), attempting to extract payload...`, 'info');
                                        log(`Script preview: ${scriptHex.substring(0, 100)}...`, 'info');
                                        
                                        // Try different extraction methods
                                        // Method 1: Skip first 4 chars and last 68 chars
                                        const payloadHex = scriptHex.substring(4, scriptHex.length - 68);
                                        payload = safeHexDecode(payloadHex, 'meta-tx payload from script');
                                        log(`Extracted payload size: ${payload.length} bytes`, 'info');
                                        break;
                                    }
                                }
                            }
                        }
                        
                        // Check if we have transaction with payload in a different format
                        if (!payload && data.subnetwork_id === "0000000000000000000000000000000000000000") {
                            log(`Checking for payload in transaction data...`, 'info');
                            console.log('Full transaction data:', data);
                        }
                    }
                } catch (apiError) {
                    log(`Explorer APIã‚¨ãƒ©ãƒ¼: ${apiError.message}`, 'warning');
                }
                
                // If Explorer API failed or payload is incomplete, try RPC
                if (!payload || payload.length < 100) {
                    log('Explorer APIã®ãƒšã‚¤ãƒ­ãƒ¼ãƒ‰ãŒä¸å®Œå…¨ã€RPCçµŒç”±ã§å†è©¦è¡Œ...', 'warning');
                    
                    try {
                        // Get transaction via RPC
                        const txResponse = await rpcClient.getTransaction({
                            transactionId: metaTxId,
                            includeBlockInfo: true
                        });
                        
                        if (txResponse && txResponse.transaction) {
                            log('RPCçµŒç”±ã§ãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³å–å¾—æˆåŠŸ', 'info');
                            
                            // Extract payload from transaction
                            const tx = txResponse.transaction;
                            if (tx.payload) {
                                // RPC might return hex or base64 encoded payload
                                // Check if it's hex
                                if (/^[0-9a-fA-F]+$/.test(tx.payload)) {
                                    payload = safeHexDecode(tx.payload, 'meta-tx payload from block tx');
                                    log(`RPC hex payload: ${payload.length} bytes`, 'info');
                                } else {
                                    // Assume base64
                                    payload = fromBase64(tx.payload);
                                    log(`RPC base64 payload: ${payload.length} bytes`, 'info');
                                }
                            } else if (tx.verboseData && tx.verboseData.payload) {
                                if (/^[0-9a-fA-F]+$/.test(tx.verboseData.payload)) {
                                    payload = safeHexDecode(tx.verboseData.payload, 'meta-tx payload from verbose data');
                                    log(`RPC verbose hex payload: ${payload.length} bytes`, 'info');
                                } else {
                                    payload = fromBase64(tx.verboseData.payload);
                                    log(`RPC verbose base64 payload: ${payload.length} bytes`, 'info');
                                }
                            }
                        }
                    } catch (rpcError) {
                        log(`RPCå–å¾—ã‚¨ãƒ©ãƒ¼: ${rpcError.message}`, 'error');
                    }
                }
                }
                
                if (!payload) {
                    throw new Error('ãƒ¡ã‚¿ãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³ã®ãƒšã‚¤ãƒ­ãƒ¼ãƒ‰ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“');
                }
                
                log(`ãƒšã‚¤ãƒ­ãƒ¼ãƒ‰å–å¾—æˆåŠŸ: ${payload.length} bytes`, 'info');
                
                // Try to decrypt the payload
                try {
                    // First, try to derive key with a temporary salt (we'll get the real salt from decrypted data)
                    // Use the metaTxId as a deterministic salt source for the first attempt
                    const tempSalt = new Uint8Array(16);
                    for (let i = 0; i < 16; i++) {
                        tempSalt[i] = parseInt(metaTxId.substr(i * 2, 2), 16);
                    }
                    
                    // Try decrypting with chunk index -1 (meta-tx indicator)
                    let decrypted;
                    let metaData;
                    
                    // We need to try different approaches since we don't have the salt yet
                    // The actual implementation would need to extract salt from the encrypted data
                    // or use a standardized approach
                    
                    // For now, let's try to extract the salt from the beginning of the payload
                    if (payload.length > 16) {
                        const salt = payload.slice(0, 16);
                        const encryptedData = payload.slice(16);
                        
                        const key = await deriveKey(password, salt);
                        
                        try {
                            log(`Attempting to decrypt with salt (${salt.length} bytes) and encrypted data (${encryptedData.length} bytes)`, 'info');
                            decrypted = await decryptChunk(encryptedData, key, -1);
                            const metaDataString = new TextDecoder().decode(decrypted);
                            log(`Decrypted string preview: ${metaDataString.substring(0, 50)}...`, 'info');
                            metaData = JSON.parse(metaDataString);
                        } catch (e) {
                            log('å¾©å·åŒ–å¤±æ•— - ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ãŒé–“é•ã£ã¦ã„ã‚‹å¯èƒ½æ€§ãŒã‚ã‚Šã¾ã™', 'error');
                            log(`Decryption error details: ${e.message || e}`, 'error');
                            console.error('Decryption error:', e);
                            
                            // Log first few bytes of payload for debugging
                            const payloadPreview = Array.from(payload.slice(0, 32)).map(b => b.toString(16).padStart(2, '0')).join(' ');
                            log(`Payload hex preview: ${payloadPreview}`, 'info');
                            throw e;
                        }
                    } else {
                        throw new Error('ãƒšã‚¤ãƒ­ãƒ¼ãƒ‰ãŒçŸ­ã™ãã¾ã™');
                    }
                    
                    // Verify this is a valid metadata (meta-tx or directory)
                    if ((metaData.version === "2.1" || metaData.version === "3.3" || metaData.version === "3.1.1") && 
                        (metaData.type === "kaspa-meta-tx" || metaData.type === "kaspa-directory")) {
                        log(`ãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿ã‚’æ­£å¸¸ã«å¾©å·åŒ–ã—ã¾ã—ãŸ (v${metaData.version}, type: ${metaData.type})`, 'success');
                        log(`ãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿å†…å®¹: ${JSON.stringify(metaData, null, 2)}`, 'info');
                        
                        // ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã‚¿ã‚¤ãƒ—ã®å ´åˆ
                        if (metaData.type === 'kaspa-directory') {
                            log('ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿ã‚’æ¤œå‡ºã—ã¾ã—ãŸ', 'info');
                            
                            // ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿ã¨ã—ã¦å‡¦ç†
                            const dirMetadata = {
                                ...metaData,
                                auth: {
                                    passwordIncluded: true,
                                    password: password
                                }
                            };
                            
                            await loadDirectoryMetadata(dirMetadata);
                            document.getElementById('downloadSection').style.display = 'block';
                            return;
                        }
                        
                        // é€šå¸¸ãƒ•ã‚¡ã‚¤ãƒ«ã®å ´åˆ
                        
                        // Check if this is super metadata
                        if (metaData.chunkStructure?.type === 'super') {
                            log('[SuperMeta] ã‚¹ãƒ¼ãƒ‘ãƒ¼ãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿ã‚’æ¤œå‡ºã—ã¾ã—ãŸ', 'info');
                            log(`[SuperMeta] ãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿æ•°: ${metaData.chunks.length}`, 'info');
                            log(`[SuperMeta] ç·ãƒãƒ£ãƒ³ã‚¯æ•°: ${metaData.chunkStructure.totalChunks}`, 'info');
                            
                            // Download all intermediate metadata
                            const intermediateMetadatas = [];
                            for (let i = 0; i < metaData.chunks.length; i++) {
                                const intMetaTxId = metaData.chunks[i];
                                const intMetaBlockId = metaData.chunkBlockIds[i];
                                
                                log(`[SuperMeta] ä¸­é–“ãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿ ${i + 1}/${metaData.chunks.length} ã‚’å–å¾—ä¸­...`, 'info');
                                
                                // Download intermediate metadata
                                try {
                                    // Try BlockID first if available
                                    let intPayload = null;
                                    
                                    if (intMetaBlockId && intMetaBlockId !== '') {
                                        // Try to get via BlockID
                                        try {
                                            const blockResponse = await rpcClient.getBlock({
                                                hash: intMetaBlockId,
                                                includeTransactions: true
                                            });
                                            
                                            const block = blockResponse?.block?.block || blockResponse?.block;
                                            if (!block) {
                                                throw new Error(`ä¸­é–“ãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿ã®ãƒ–ãƒ­ãƒƒã‚¯ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“: ${intMetaBlockId}`);
                                            }
                                            
                                            // Find the intermediate meta transaction
                                            for (const tx of block.transactions || []) {
                                                const txId = tx.verboseData?.transactionId || tx.id || tx.transactionId;
                                                if (txId === intMetaTxId) {
                                                    if (tx.payload && tx.payload !== '') {
                                                        const hexPayload = tx.payload;
                                                        intPayload = safeHexDecode(hexPayload, 'intermediate meta-tx payload');
                                                        break;
                                                    }
                                                }
                                            }
                                        } catch (blockError) {
                                            log(`[SuperMeta] BlockIDçµŒç”±ã®å–å¾—ã«å¤±æ•—ã€REST APIã«ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯`, 'warning');
                                        }
                                    }
                                    
                                    // Fallback to REST API if BlockID failed or not available
                                    if (!intPayload) {
                                        log(`[SuperMeta] REST APIçµŒç”±ã§ä¸­é–“ãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—ä¸­...`, 'info');
                                        
                                        const txResponse = await fetch(`https://api.kaspa.org/transactions/${intMetaTxId}`);
                                        if (!txResponse.ok) {
                                            throw new Error(`ä¸­é–“ãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“: ${intMetaTxId}`);
                                        }
                                        
                                        const txData = await txResponse.json();
                                        
                                        if (txData.payload && txData.payload !== '') {
                                            intPayload = safeHexDecode(txData.payload, 'intermediate meta-tx payload from API');
                                        } else {
                                            throw new Error(`ä¸­é–“ãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿ã®ãƒšã‚¤ãƒ­ãƒ¼ãƒ‰ãŒç©ºã§ã™`);
                                        }
                                    }
                                    
                                    // Decrypt intermediate metadata
                                    const intSalt = intPayload.slice(0, 16);
                                    const intEncryptedData = intPayload.slice(16);
                                    const intKey = await deriveKey(password, intSalt);
                                    const intDecrypted = await decryptChunk(intEncryptedData, intKey, -1);
                                    const intMetaData = JSON.parse(new TextDecoder().decode(intDecrypted));
                                    
                                    // ãƒ‡ãƒãƒƒã‚°: ä¸­é–“ãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿ã®å†…å®¹ã‚’ç¢ºèª
                                    log(`[SuperMeta DEBUG] ä¸­é–“ãƒ¡ã‚¿ ${i + 1} - payloadSplit: ${intMetaData.metadata?.payloadSplit}, chunkBoundaries: ${intMetaData.metadata?.chunkBoundaries?.length || 0}`, 'debug');
                                    if (intMetaData.metadata?.chunkBoundaries?.length > 0) {
                                        log(`[SuperMeta DEBUG] ä¸­é–“ãƒ¡ã‚¿ ${i + 1} - ãƒã‚¦ãƒ³ãƒ€ãƒª[0]: ${JSON.stringify(intMetaData.metadata.chunkBoundaries[0])}`, 'debug');
                                    }
                                    
                                    intermediateMetadatas.push(intMetaData);
                                    log(`[SuperMeta] ä¸­é–“ãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿ ${i + 1} å–å¾—å®Œäº†`, 'success');
                                    
                                } catch (error) {
                                    log(`[SuperMeta] ä¸­é–“ãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿å–å¾—ã‚¨ãƒ©ãƒ¼: ${error.message}`, 'error');
                                    throw error;
                                }
                            }
                            
                            // Merge all chunk references from intermediate metadata
                            const allChunks = [];
                            const allChunkBlockIds = [];
                            let payloadSplitFlag = false;
                            const allChunkBoundaries = [];
                            
                            for (const intMeta of intermediateMetadatas) {
                                allChunks.push(...intMeta.chunks);
                                allChunkBlockIds.push(...intMeta.chunkBlockIds);
                                // Check if any intermediate metadata has payloadSplit flag
                                if (intMeta.metadata?.payloadSplit) {
                                    payloadSplitFlag = true;
                                }
                                // Collect chunk boundaries if present
                                if (intMeta.metadata?.chunkBoundaries) {
                                    allChunkBoundaries.push(...intMeta.metadata.chunkBoundaries);
                                }
                            }
                            
                            // ãƒ‡ãƒãƒƒã‚°: ä¸­é–“ãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿ã®å†…å®¹ã‚’ç¢ºèª
                            if (payloadSplitFlag && allChunkBoundaries.length === 0) {
                                log(`[SuperMeta WARNING] payloadSplitãƒ•ãƒ©ã‚°ãŒtrueã§ã™ãŒã€ãƒãƒ£ãƒ³ã‚¯ãƒã‚¦ãƒ³ãƒ€ãƒªãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“`, 'warning');
                                log(`[SuperMeta DEBUG] ä¸­é–“ãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿æ•°: ${intermediateMetadatas.length}`, 'debug');
                                for (let i = 0; i < intermediateMetadatas.length; i++) {
                                    const intMeta = intermediateMetadatas[i];
                                    log(`[SuperMeta DEBUG] ä¸­é–“ãƒ¡ã‚¿[${i}] payloadSplit: ${intMeta.metadata?.payloadSplit}, boundaries: ${intMeta.metadata?.chunkBoundaries?.length || 0}`, 'debug');
                                }
                            }
                            
                            // Create unified metadata from super metadata
                            kaspaMetadata = {
                                ...metaData,
                                chunks: allChunks,
                                chunkBlockIds: allChunkBlockIds,
                                chunkStructure: {
                                    ...metaData.chunkStructure,
                                    intermediateMetadatas: intermediateMetadatas.length
                                },
                                // Merge metadata with payloadSplit flag
                                metadata: {
                                    ...metaData.metadata,
                                    payloadSplit: payloadSplitFlag,
                                    // ãƒãƒ£ãƒ³ã‚¯ãƒã‚¦ãƒ³ãƒ€ãƒªã¯éšå±¤çš„ã«ç®¡ç†ï¼ˆä¸­é–“ãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿ã‹ã‚‰åé›†ï¼‰
                                    ...(allChunkBoundaries.length > 0 ? { chunkBoundaries: allChunkBoundaries } : {})
                                },
                                // ä¸­é–“ãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿ã‚’ä¿æŒï¼ˆå°†æ¥ã®æ‹¡å¼µç”¨ï¼‰
                                _intermediateMetadatas: intermediateMetadatas,
                                metaTx: {
                                    type: 'super',
                                    txid: metaTxId,
                                    blockId: blockId,
                                    loadedAt: Date.now()
                                }
                            };
                            
                            // å¾Œæ–¹äº’æ›æ€§: v5.0.7ä»¥å‰ã®ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ã§ãƒãƒ£ãƒ³ã‚¯ãƒã‚¦ãƒ³ãƒ€ãƒªãŒãªã„å ´åˆã®å¯¾å¿œ
                            if (payloadSplitFlag && allChunkBoundaries.length === 0) {
                                log(`[SuperMeta COMPAT] v5.0.7ä»¥å‰ã®ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ã‚’æ¤œå‡º - ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ãƒ’ã‚¹ãƒˆãƒªãƒ¼ã‹ã‚‰ãƒãƒ£ãƒ³ã‚¯ãƒã‚¦ãƒ³ãƒ€ãƒªã‚’å–å¾—è©¦è¡Œ`, 'warning');
                                
                                // ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ãƒ’ã‚¹ãƒˆãƒªãƒ¼ã‹ã‚‰è©²å½“ã™ã‚‹ãƒ•ã‚¡ã‚¤ãƒ«ã‚’æ¢ã™
                                try {
                                    const history = JSON.parse(localStorage.getItem('kaspa_upload_history') || '[]');
                                    const matchingEntry = history.find(entry => 
                                        entry.metadata?.metaTx?.txid === metaTxId ||
                                        (entry.metadata?.file?.sha256 === metaData.file?.sha256 && 
                                         entry.metadata?.file?.size === metaData.file?.size)
                                    );
                                    
                                    if (matchingEntry && matchingEntry.metadata?.metadata?.chunkBoundaries) {
                                        kaspaMetadata.metadata.chunkBoundaries = matchingEntry.metadata.metadata.chunkBoundaries;
                                        log(`[SuperMeta COMPAT] ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ãƒ’ã‚¹ãƒˆãƒªãƒ¼ã‹ã‚‰ãƒãƒ£ãƒ³ã‚¯ãƒã‚¦ãƒ³ãƒ€ãƒªã‚’å¾©å…ƒ: ${kaspaMetadata.metadata.chunkBoundaries.length}å€‹`, 'success');
                                    } else {
                                        log(`[SuperMeta COMPAT] ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ãƒ’ã‚¹ãƒˆãƒªãƒ¼ã«ãƒãƒ£ãƒ³ã‚¯ãƒã‚¦ãƒ³ãƒ€ãƒªãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“`, 'warning');
                                    }
                                } catch (e) {
                                    log(`[SuperMeta COMPAT] ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ãƒ’ã‚¹ãƒˆãƒªãƒ¼ã®èª­ã¿è¾¼ã¿ã‚¨ãƒ©ãƒ¼: ${e.message}`, 'error');
                                }
                            }
                            
                            log(`[SuperMeta] çµ±åˆå®Œäº†: ${allChunks.length}ãƒãƒ£ãƒ³ã‚¯`, 'success');
                            log(`[SuperMeta DEBUG] çµ±åˆå¾Œã®chunks[0]: ${kaspaMetadata.chunks[0]?.substring(0, 16)}...`, 'debug');
                            log(`[SuperMeta DEBUG] allChunks[0]: ${allChunks[0]?.substring(0, 16)}...`, 'debug');
                            log(`[SuperMeta DEBUG] ãƒãƒ£ãƒ³ã‚¯ãƒã‚¦ãƒ³ãƒ€ãƒªæ•°: ${allChunkBoundaries.length}`, 'debug');
                            if (allChunkBoundaries.length > 0) {
                                log(`[SuperMeta DEBUG] ãƒãƒ£ãƒ³ã‚¯ãƒã‚¦ãƒ³ãƒ€ãƒª[0]: ${JSON.stringify(allChunkBoundaries[0])}`, 'debug');
                            }
                            
                        } else {
                            // Regular metadata
                            kaspaMetadata = {
                                ...metaData,  // Keep all fields from meta-tx
                                metaTx: {
                                    txid: metaTxId,
                                    blockId: blockId,
                                    loadedAt: Date.now()
                                }
                            };
                        }
                        
                        // Show file info
                        const metaType = kaspaMetadata.chunkStructure?.type || 'flat';
                        const totalChunks = kaspaMetadata.chunkStructure?.totalChunks || kaspaMetadata.chunks.length;
                        
                        document.getElementById('fileInfo').textContent = 
                            `ãƒ•ã‚¡ã‚¤ãƒ«å: ${kaspaMetadata.file.name}\n` +
                            `ã‚µã‚¤ã‚º: ${(kaspaMetadata.file.size / 1024).toFixed(1)} KB\n` +
                            `ãƒãƒ£ãƒ³ã‚¯æ•°: ${totalChunks} (${metaType === 'super' ? 'ã‚¹ãƒ¼ãƒ‘ãƒ¼ãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿' : 'é€šå¸¸'})\n` +
                            `æš—å·åŒ–: ${kaspaMetadata.encryption.algorithm}\n` +
                            `åœ§ç¸®: ${kaspaMetadata.file?.compression?.enabled ? kaspaMetadata.file.compression.algorithm : 'ãªã—'}\n` +
                            `ä½œæˆæ—¥æ™‚: ${new Date(kaspaMetadata.created || kaspaMetadata.metadata?.createdAt).toLocaleString()}\n` +
                            `ãƒ¡ã‚¿TxID: ${metaTxId.substring(0, 16)}...`;
                        
                        // Set password for download
                        document.getElementById('downloadPassword').value = password;
                        document.getElementById('downloadPassword').style.display = 'none';
                        
                        // Show download section
                        document.getElementById('downloadSection').style.display = 'block';
                        
                        log('ãƒ¡ã‚¿TxIDã‹ã‚‰ã®å¾©å…ƒæº–å‚™å®Œäº†ï¼ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ãƒœã‚¿ãƒ³ã‚’ã‚¯ãƒªãƒƒã‚¯ã—ã¦ãã ã•ã„ã€‚', 'success');
                        
                    } else {
                        throw new Error('ã“ã‚Œã¯æœ‰åŠ¹ãªãƒ¡ã‚¿ãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³ã§ã¯ã‚ã‚Šã¾ã›ã‚“');
                    }
                    
                } catch (error) {
                    log(`å¾©å·åŒ–ã‚¨ãƒ©ãƒ¼: ${error.message}`, 'error');
                    throw error;
                }
                
            } catch (error) {
                log(`ãƒ¡ã‚¿TxIDå¾©å…ƒã‚¨ãƒ©ãƒ¼: ${error.message}`, 'error');
            }
        };

        // Download file
        window.downloadFile = async function() {
            let password = document.getElementById('downloadPassword').value;
            log(`ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã®å€¤: ${password ? 'å…¥åŠ›ã‚ã‚Š' : 'ç©º'}`, 'debug');
            
            if (kaspaMetadata.auth?.passwordIncluded && kaspaMetadata.auth?.password) {
                password = kaspaMetadata.auth.password;
                log(`ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ã‚’.kaspaãƒ•ã‚¡ã‚¤ãƒ«ã‹ã‚‰å–å¾—ã—ã¾ã—ãŸ (é•·ã•: ${password.length})`, 'info');
            }
            
            if (!password) {
                log('ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„', 'error');
                return;
            }
            
            log(`ä½¿ç”¨ã™ã‚‹ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰: ${password.substring(0, 3)}... (é•·ã•: ${password.length})`, 'debug');
            
            if (!kaspaMetadata) {
                log('.kaspaãƒ•ã‚¡ã‚¤ãƒ«ãŒèª­ã¿è¾¼ã¾ã‚Œã¦ã„ã¾ã›ã‚“', 'error');
                return;
            }
            
            if (!rpcClient) {
                log('å…ˆã«ã‚·ã‚¹ãƒ†ãƒ ã‚’åˆæœŸåŒ–ã—ã¦ãã ã•ã„', 'error');
                return;
            }
            
            document.getElementById('downloadProgress').style.display = 'block';
            
            try {
                // v4.6.27: ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã‚¿ã‚¤ãƒ—å¯¾å¿œ
                const fileName = kaspaMetadata.file?.name || 
                               kaspaMetadata.directory?.name || 
                               'unknown';
                log(`ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰é–‹å§‹: ${fileName}`);
                log(`[DEBUG] ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰æ™‚ã®chunks[0]: ${kaspaMetadata.chunks[0]?.substring(0, 16)}...`, 'debug');
                log(`[DEBUG] chunksé…åˆ—é•·: ${kaspaMetadata.chunks?.length}`, 'debug');
                
                // Derive key
                if (!kaspaMetadata.encryption || !kaspaMetadata.encryption.pbkdf2) {
                    throw new Error('æš—å·åŒ–æƒ…å ±ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“');
                }
                const salt = fromBase64(kaspaMetadata.encryption.pbkdf2.salt);
                log(`Salt (base64): ${kaspaMetadata.encryption.pbkdf2.salt}`, 'debug');
                log(`Salt (bytes): ${salt.length} bytes`, 'debug');
                
                // v3.0ã¨v3.1ã®äº’æ›æ€§å¯¾å¿œ
                let iterations = kaspaMetadata.encryption.pbkdf2.iterations || 100000;
                if (kaspaMetadata.version === "3.0") {
                    // v3.0ã®å ´åˆã¯10000å›ã‚’ä½¿ç”¨
                    iterations = 10000;
                    log(`v3.0ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆæ¤œå‡º: PBKDF2 ${iterations}å›ã‚’ä½¿ç”¨`, 'info');
                } else if (kaspaMetadata.version === "3.3") {
                    log(`v3.3ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆæ¤œå‡º: PBKDF2 ${iterations}å›ã‚’ä½¿ç”¨`, 'info');
                } else {
                    log(`v${kaspaMetadata.version}ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆ: PBKDF2 ${iterations}å›ã‚’ä½¿ç”¨`, 'info');
                }
                
                // v4.7.43: Use DownloadManager internally
                log('[v4.7.43] DownloadManagerã‚’ä½¿ç”¨ã—ã¦ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰å‡¦ç†ã‚’å®Ÿè¡Œ', 'info');
                
                const onProgress = (progress) => {
                    const percent = progress.percent || 0;
                    document.getElementById('downloadProgressBar').style.width = percent + '%';
                    document.getElementById('downloadProgressBar').textContent = percent + '%';
                    if (progress.current && progress.total) {
                        document.getElementById('downloadStatus').textContent = 
                            `ãƒãƒ£ãƒ³ã‚¯ ${progress.current}/${progress.total} ã‚’å–å¾—ä¸­...`;
                    }
                };
                
                await window.downloadManager.executeDownload(
                    kaspaMetadata,
                    password,
                    {
                        onProgress: onProgress
                    }
                );
                
                log('ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰å‡¦ç†å®Œäº†', 'success');
                document.getElementById('downloadProgress').style.display = 'none';
                
                return; // æ–°ã—ã„å‡¦ç†ã¯ã“ã“ã§çµ‚äº†
                
                // ä»¥ä¸‹ã¯æ—§å‡¦ç†ï¼ˆåˆ°é”ã—ãªã„ï¼‰
                const key = await deriveKey(password, salt, iterations);
                log(`ã‚­ãƒ¼ç”Ÿæˆå®Œäº† (iterations: ${iterations})`, 'debug');
                
                const chunks = [];
                
                // Check if parallel download should be used
                // v4.7.44: Enable parallel download for 2+ chunks
                const useParallel = parallelDownloadEnabled && kaspaMetadata.chunks.length >= 2;
                
                if (useParallel) {
                    // Parallel download
                    log(`ä¸¦åˆ—ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ãƒ¢ãƒ¼ãƒ‰ã‚’ä½¿ç”¨ã—ã¾ã™ (${kaspaMetadata.chunks.length}ãƒãƒ£ãƒ³ã‚¯)`, 'info');
                    
                    try {
                        const downloader = new ParallelDownloader(rpcClient, 8);
                        
                        const parallelChunks = await downloader.downloadChunks(
                            kaspaMetadata.chunks,
                            kaspaMetadata.chunkBlockIds,
                            key,
                            kaspaMetadata,
                            (progress) => {
                                const percent = ((progress.completed / progress.total) * 100).toFixed(0);
                                document.getElementById('downloadProgressBar').style.width = percent + '%';
                                document.getElementById('downloadProgressBar').textContent = percent + '%';
                                document.getElementById('downloadStatus').textContent = 
                                    `${progress.completed}/${progress.total} ãƒãƒ£ãƒ³ã‚¯ (${progress.speed.toFixed(1)} ãƒãƒ£ãƒ³ã‚¯/ç§’, ${progress.throughput.toFixed(1)} MB/ç§’)`;
                            }
                        );
                        
                        chunks.push(...parallelChunks);
                    } catch (parallelError) {
                        log(`ä¸¦åˆ—ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ã‚¨ãƒ©ãƒ¼: ${parallelError.message}`, 'error');
                        log('ã‚·ãƒ¼ã‚±ãƒ³ã‚·ãƒ£ãƒ«ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ã«ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ã—ã¾ã™', 'warning');
                        
                        // Fallback to sequential
                        chunks.length = 0;
                        for (let i = 0; i < kaspaMetadata.chunks.length; i++) {
                    const txId = kaspaMetadata.chunks[i];
                    const blockId = kaspaMetadata.chunkBlockIds[i];
                    
                    document.getElementById('downloadStatus').textContent = 
                        `ãƒãƒ£ãƒ³ã‚¯ ${i + 1}/${kaspaMetadata.chunks.length} ã‚’å–å¾—ä¸­...`;
                    
                    try {
                        log(`ãƒãƒ£ãƒ³ã‚¯ ${i + 1}: TxID ${txId.substring(0, 16)}... BlockID ${blockId.substring(0, 16)}...`, 'info');
                        
                        // Get block data
                        const request = { 
                            hash: blockId, 
                            includeTransactions: true 
                        };
                        log(`RPC getBlock request: ${JSON.stringify(request)}`, 'info');
                        
                        let response;
                        try {
                            response = await rpcClient.getBlock(request);
                            log(`RPC getBlock response received`, 'info');
                            log(`Response type: ${typeof response}`, 'info');
                            log(`Response keys: ${Object.keys(response || {}).join(', ')}`, 'info');
                        } catch (rpcError) {
                            log(`RPC getBlock error: ${rpcError.message || rpcError}`, 'error');
                            log(`Error type: ${rpcError.constructor.name}`, 'error');
                            throw rpcError;
                        }
                        
                        const block = response?.block?.block || response?.block;
                        log(`Block extracted: ${!!block}`, 'info');
                        
                        if (!block) {
                            log(`Block not found in response structure`, 'error');
                            throw new Error(`ãƒ–ãƒ­ãƒƒã‚¯ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“: ${blockId}`);
                        }
                        
                        // Find transaction with matching TxID
                        let payload = null;
                        const txCount = block.transactions?.length || 0;
                        log(`ãƒ–ãƒ­ãƒƒã‚¯å†…ã®ãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³æ•°: ${txCount}`, 'info');
                        
                        if (txCount === 0) {
                            log(`è­¦å‘Š: ãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³ãŒå«ã¾ã‚Œã¦ã„ã¾ã›ã‚“`, 'warning');
                            // BigIntã‚’å«ã‚€å¯èƒ½æ€§ãŒã‚ã‚‹ã®ã§JSON.stringifyã¯é¿ã‘ã‚‹
                            log(`Block has header.hash: ${block.header?.hash}`, 'warning');
                        }
                        
                        for (const tx of block.transactions || []) {
                            // BigIntã‚’å«ã‚€å¯èƒ½æ€§ãŒã‚ã‚‹ã®ã§JSON.stringifyã¯é¿ã‘ã‚‹
                            log(`Checking transaction...`, 'info');
                            const txHash = tx.verboseData?.transactionId || tx.id || tx.transactionId;
                            log(`Transaction ID variants: verboseData.transactionId=${tx.verboseData?.transactionId}, tx.id=${tx.id}, tx.transactionId=${tx.transactionId}`, 'info');
                            
                            if (txHash === txId) {
                                log(`TxIDä¸€è‡´: ${txId.substring(0, 16)}...`, 'info');
                                log(`tx.payload exists: ${!!tx.payload}, length: ${tx.payload?.length || 0}`, 'info');
                                
                                if (tx.payload && tx.payload !== '') {
                                    // Get raw binary payload from hex (blockchain stores as hex)
                                    const hexPayload = tx.payload;
                                    log(`ãƒšã‚¤ãƒ­ãƒ¼ãƒ‰é•·: ${hexPayload.length} æ–‡å­— (hex)`, 'info');
                                    log(`æœ€åˆã®100æ–‡å­—: ${hexPayload.substring(0, 100)}...`, 'info');
                                    
                                    // Blockchain stores binary payloads as hex strings
                                    try {
                                        payload = safeHexDecode(hexPayload, 'chunk payload');
                                        log(`Hex decodeæˆåŠŸ: ${payload.length} ãƒã‚¤ãƒˆ (ç”Ÿãƒã‚¤ãƒŠãƒª)`, 'info');
                                    } catch (e) {
                                        log(`Hex decode error details: ${e.stack || e}`, 'error');
                                        throw new Error(`ãƒšã‚¤ãƒ­ãƒ¼ãƒ‰ã®ãƒ‡ã‚³ãƒ¼ãƒ‰ã«å¤±æ•—: ${e.message}`);
                                    }
                                    break;
                                } else {
                                    log(`è­¦å‘Š: ãƒšã‚¤ãƒ­ãƒ¼ãƒ‰ãŒç©ºã§ã™ (TxID: ${txId})`, 'warning');
                                }
                            } else {
                                log(`TxIDä¸ä¸€è‡´: ${txHash} !== ${txId}`, 'info');
                            }
                        }
                        
                        if (!payload) {
                            throw new Error(`ãƒãƒ£ãƒ³ã‚¯ ${i + 1} ã®ãƒšã‚¤ãƒ­ãƒ¼ãƒ‰ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“`);
                        }
                        
                        // Decrypt and decompress
                        const encrypted = payload; // Already binary Uint8Array
                        const compressed = await decryptChunk(encrypted, key, i);
                        const original = kaspaMetadata.file?.compression?.enabled ? lzDecompress(compressed) : compressed;
                        
                        chunks.push(original);
                        
                        // Update progress
                        const progress = ((i + 1) / kaspaMetadata.chunks.length * 100).toFixed(0);
                        document.getElementById('downloadProgressBar').style.width = progress + '%';
                        document.getElementById('downloadProgressBar').textContent = progress + '%';
                        
                        log(`ãƒãƒ£ãƒ³ã‚¯ ${i + 1} å–å¾—æˆåŠŸ`);
                        
                    } catch (error) {
                        log(`ãƒãƒ£ãƒ³ã‚¯ ${i + 1} ã‚¨ãƒ©ãƒ¼: ${error.message}`, 'error');
                        throw error;
                    }
                }
                    }
                } else {
                    // Sequential download (default)
                    log(`ã‚·ãƒ¼ã‚±ãƒ³ã‚·ãƒ£ãƒ«ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ãƒ¢ãƒ¼ãƒ‰ã‚’ä½¿ç”¨ã—ã¾ã™ (${kaspaMetadata.chunks.length}ãƒãƒ£ãƒ³ã‚¯)`, 'info');
                    log(`åœ§ç¸®è¨­å®š: ${JSON.stringify(kaspaMetadata.file?.compression)}`, 'info');
                    
                    for (let i = 0; i < kaspaMetadata.chunks.length; i++) {
                        const txId = kaspaMetadata.chunks[i];
                        const blockId = kaspaMetadata.chunkBlockIds[i];
                        
                        document.getElementById('downloadStatus').textContent = 
                            `ãƒãƒ£ãƒ³ã‚¯ ${i + 1}/${kaspaMetadata.chunks.length} ã‚’å–å¾—ä¸­...`;
                        
                        try {
                            log(`ãƒãƒ£ãƒ³ã‚¯ ${i + 1}: TxID ${txId.substring(0, 16)}... BlockID ${blockId.substring(0, 16)}...`, 'info');
                            
                            // Get block data
                            const request = { 
                                hash: blockId, 
                                includeTransactions: true 
                            };
                            log(`RPC getBlock request: ${JSON.stringify(request)}`, 'info');
                            
                            let response;
                            try {
                                response = await rpcClient.getBlock(request);
                                log(`RPC getBlock response received`, 'info');
                                log(`Response type: ${typeof response}`, 'info');
                                log(`Response keys: ${Object.keys(response || {}).join(', ')}`, 'info');
                            } catch (rpcError) {
                                log(`RPC getBlock error: ${rpcError.message || rpcError}`, 'error');
                                log(`Error type: ${rpcError.constructor.name}`, 'error');
                                throw rpcError;
                            }
                            
                            const block = response?.block?.block || response?.block;
                            log(`Block extracted: ${!!block}`, 'info');
                            
                            if (!block) {
                                log(`Block not found in response structure`, 'error');
                                throw new Error(`ãƒ–ãƒ­ãƒƒã‚¯ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“: ${blockId}`);
                            }
                            
                            // Find transaction with matching TxID
                            let payload = null;
                            const txCount = block.transactions?.length || 0;
                            log(`ãƒ–ãƒ­ãƒƒã‚¯å†…ã®ãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³æ•°: ${txCount}`, 'info');
                            
                            if (txCount === 0) {
                                log(`è­¦å‘Š: ãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³ãŒå«ã¾ã‚Œã¦ã„ã¾ã›ã‚“`, 'warning');
                                // BigIntã‚’å«ã‚€å¯èƒ½æ€§ãŒã‚ã‚‹ã®ã§JSON.stringifyã¯é¿ã‘ã‚‹
                                log(`Block has header.hash: ${block.header?.hash}`, 'warning');
                            }
                            
                            for (const tx of block.transactions || []) {
                                // BigIntã‚’å«ã‚€å¯èƒ½æ€§ãŒã‚ã‚‹ã®ã§JSON.stringifyã¯é¿ã‘ã‚‹
                                log(`Checking transaction...`, 'info');
                                const txHash = tx.verboseData?.transactionId || tx.id || tx.transactionId;
                                log(`Transaction ID variants: verboseData.transactionId=${tx.verboseData?.transactionId}, tx.id=${tx.id}, tx.transactionId=${tx.transactionId}`, 'info');
                                
                                if (txHash === txId) {
                                    log(`TxIDä¸€è‡´: ${txId.substring(0, 16)}...`, 'info');
                                    log(`tx.payload exists: ${!!tx.payload}, length: ${tx.payload?.length || 0}`, 'info');
                                    
                                    if (tx.payload && tx.payload !== '') {
                                        // Get raw binary payload from hex (blockchain stores as hex)
                                        payload = safeHexDecode(tx.payload, 'chunk payload');
                                        log(`ãƒšã‚¤ãƒ­ãƒ¼ãƒ‰å–å¾—æˆåŠŸ: ${payload.length} bytes`, 'info');
                                        break;
                                    }
                                }
                            }
                            
                            if (!payload) {
                                throw new Error(`ãƒãƒ£ãƒ³ã‚¯ ${i + 1} ã®ãƒšã‚¤ãƒ­ãƒ¼ãƒ‰ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“`);
                            }
                            
                            // Decrypt and decompress
                            const encrypted = payload; // Already binary Uint8Array
                            log(`ãƒãƒ£ãƒ³ã‚¯ ${i + 1}: æš—å·åŒ–ãƒ‡ãƒ¼ã‚¿ ${encrypted.length} bytes`, 'info');
                            // Log first few bytes for debugging
                            const preview = Array.from(encrypted.slice(0, 16)).map(b => b.toString(16).padStart(2, '0')).join(' ');
                            log(`ãƒãƒ£ãƒ³ã‚¯ ${i + 1}: ãƒ‡ãƒ¼ã‚¿ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼: ${preview}...`, 'debug');
                            const compressed = await decryptChunk(encrypted, key, i);
                            log(`ãƒãƒ£ãƒ³ã‚¯ ${i + 1}: å¾©å·åŒ–å¾Œ ${compressed.length} bytes`, 'info');
                            log(`åœ§ç¸®ãŒæœ‰åŠ¹ã‹: ${kaspaMetadata.file?.compression?.enabled}`, 'info');
                            const original = kaspaMetadata.file?.compression?.enabled ? lzDecompress(compressed) : compressed;
                            
                            chunks.push(original);
                            log(`ãƒãƒ£ãƒ³ã‚¯ ${i + 1}: æœ€çµ‚ã‚µã‚¤ã‚º ${original.length} bytes`, 'info');
                            
                            // Update progress
                            const progress = ((i + 1) / kaspaMetadata.chunks.length * 100).toFixed(0);
                            document.getElementById('downloadProgressBar').style.width = progress + '%';
                            document.getElementById('downloadProgressBar').textContent = progress + '%';
                            
                            log(`ãƒãƒ£ãƒ³ã‚¯ ${i + 1} å–å¾—æˆåŠŸ`);
                            
                        } catch (error) {
                            log(`ãƒãƒ£ãƒ³ã‚¯ ${i + 1} ã‚¨ãƒ©ãƒ¼: ${error.message || error}`, 'error');
                            console.error(`ãƒãƒ£ãƒ³ã‚¯ ${i + 1} è©³ç´°ã‚¨ãƒ©ãƒ¼:`, error);
                            throw error;
                        }
                    }
                }
                
                // Combine chunks
                const totalSize = chunks.reduce((sum, chunk) => sum + chunk.length, 0);
                const combined = new Uint8Array(totalSize);
                let offset = 0;
                for (const chunk of chunks) {
                    combined.set(chunk, offset);
                    offset += chunk.length;
                }
                
                // Verify hash
                const downloadedHash = await sha256(combined);
                log(`ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ã—ãŸãƒ•ã‚¡ã‚¤ãƒ«ã®ãƒãƒƒã‚·ãƒ¥: ${downloadedHash}`, 'info');
                log(`æœŸå¾…ã•ã‚Œã‚‹ãƒãƒƒã‚·ãƒ¥: ${kaspaMetadata.file.sha256}`, 'info');
                log(`ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ã—ãŸãƒ•ã‚¡ã‚¤ãƒ«ã‚µã‚¤ã‚º: ${combined.length} bytes`, 'info');
                log(`æœŸå¾…ã•ã‚Œã‚‹ãƒ•ã‚¡ã‚¤ãƒ«ã‚µã‚¤ã‚º: ${kaspaMetadata.file.size} bytes`, 'info');
                
                if (downloadedHash !== kaspaMetadata.file.sha256) {
                    throw new Error('ãƒ•ã‚¡ã‚¤ãƒ«æ•´åˆæ€§ãƒã‚§ãƒƒã‚¯å¤±æ•—ï¼');
                }
                
                // Download
                const blob = new Blob([combined], { type: kaspaMetadata.file.mimeType });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = kaspaMetadata.file.name;
                a.click();
                URL.revokeObjectURL(url);
                
                log(`ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰å®Œäº†: ${kaspaMetadata.file.name}`, 'success');
                
            } catch (error) {
                log(`ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ã‚¨ãƒ©ãƒ¼: ${error.message}`, 'error');
            }
        };

        // Check if monitoring should stop
        async function checkMonitoringStop() {
            // v3.6.3 fix: Check overall upload status
            if (uploadingChunksCount === 0 && !uploadingMetaTx && !uploadingDirMeta && !isUploadingFile) {
                log(`[DEBUG] WebSocketç›£è¦–: æ®‹ã‚Š0ä»¶ - è‡ªå‹•åœæ­¢ã—ã¾ã™`, 'debug');
                await stopMonitoring();
            }
        }
        
        // Removed duplicate startMonitoring function - see line 6106 for the unified version

        window.stopMonitoring = async function() {
            if (!wsMonitorActive) {
                log('ç›£è¦–ã¯é–‹å§‹ã•ã‚Œã¦ã„ã¾ã›ã‚“', 'warning');
                return;
            }
            
            try {
                if (rpcClient) {
                    await rpcClient.unsubscribeBlockAdded();
                }
                wsMonitorActive = false;
                
                // Clear timeout
                if (wsMonitorTimeout) {
                    clearTimeout(wsMonitorTimeout);
                    wsMonitorTimeout = null;
                }
                
                // Reset counters
                uploadingChunksCount = 0;
                uploadingMetaTx = false;
                
                log('WebSocketç›£è¦–ã‚’åœæ­¢ã—ã¾ã—ãŸ', 'info');
                
            } catch (error) {
                log(`ç›£è¦–åœæ­¢ã‚¨ãƒ©ãƒ¼: ${error.message}`, 'error');
            }
        };

        // Toggle parallel download
        window.toggleParallelDownload = function() {
            parallelDownloadEnabled = document.getElementById('parallelDownloadToggle').checked;
            localStorage.setItem('kaspaParallelDownload', parallelDownloadEnabled.toString());
            
            if (parallelDownloadEnabled) {
                log('ä¸¦åˆ—ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ã‚’æœ‰åŠ¹ã«ã—ã¾ã—ãŸï¼ˆå®Ÿé¨“çš„æ©Ÿèƒ½ï¼‰', 'warning');
            } else {
                log('ä¸¦åˆ—ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ã‚’ç„¡åŠ¹ã«ã—ã¾ã—ãŸï¼ˆå®‰å®šãƒ¢ãƒ¼ãƒ‰ï¼‰', 'success');
            }
        };
        
        // Settings functions
        window.exportLogs = function() {
            const exportData = {
                timestamp: new Date().toISOString(),
                logs: systemLogs,
                uploadHistory: uploadHistory,
                monitoredTransactions: Array.from(monitoredTransactions.entries())
            };
            
            const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `kaspa-p2p-logs-${Date.now()}.json`;
            a.click();
            URL.revokeObjectURL(url);
            
            log('ãƒ­ã‚°ã‚’ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆã—ã¾ã—ãŸ', 'success');
        };

        window.clearLogs = function() {
            if (confirm('ã™ã¹ã¦ã®ãƒ­ã‚°ã‚’ã‚¯ãƒªã‚¢ã—ã¾ã™ã‹ï¼Ÿ')) {
                systemLogs = [];
                document.getElementById('systemLog').innerHTML = '';
                document.getElementById('monitorLog').innerHTML = '';
                log('ãƒ­ã‚°ã‚’ã‚¯ãƒªã‚¢ã—ã¾ã—ãŸ', 'info');
            }
        };

        window.copyLog = function() {
            const logText = systemLogs.map(log => 
                `[${log.time}] ${log.type.toUpperCase()}: ${log.message}`
            ).join('\n');
            
            navigator.clipboard.writeText(logText).then(() => {
                alert('ãƒ­ã‚°ã‚’ã‚¯ãƒªãƒƒãƒ—ãƒœãƒ¼ãƒ‰ã«ã‚³ãƒ”ãƒ¼ã—ã¾ã—ãŸ');
            });
        };

        // Drag and drop
        window.handleDragOver = function(e) {
            e.preventDefault();
            e.currentTarget.classList.add('dragover');
        };

        window.handleDragLeave = function(e) {
            e.preventDefault();
            e.currentTarget.classList.remove('dragover');
        };

        window.handleKaspaDrop = function(e) {
            e.preventDefault();
            e.currentTarget.classList.remove('dragover');
            
            log('=== handleKaspaDrop é–‹å§‹ ===', 'info');
            log(`e.dataTransfer.files: ${e.dataTransfer.files}`, 'info');
            log(`files.length: ${e.dataTransfer.files.length}`, 'info');
            
            const file = e.dataTransfer.files[0];
            log(`file: ${file}`, 'info');
            
            if (file) {
                log(`file.name: ${file.name}`, 'info');
                log(`file.type: ${file.type}`, 'info');
                log(`file.size: ${file.size} bytes`, 'info');
                log(`endsWith('.kaspa'): ${file.name.endsWith('.kaspa')}`, 'info');
            }
            
            if (file && file.name.endsWith('.kaspa')) {
                document.getElementById('kaspaFileInput').files = e.dataTransfer.files;
                loadKaspaFile({ target: { files: [file] } });
            } else {
                log('ãƒ‰ãƒ­ãƒƒãƒ—ã•ã‚ŒãŸãƒ•ã‚¡ã‚¤ãƒ«ã¯.kaspaãƒ•ã‚¡ã‚¤ãƒ«ã§ã¯ã‚ã‚Šã¾ã›ã‚“', 'error');
            }
        };

        // File upload drag and drop
        document.addEventListener('DOMContentLoaded', () => {
            const fileLabel = document.querySelector('.file-input-label');
            
            fileLabel.addEventListener('dragover', handleDragOver);
            fileLabel.addEventListener('dragleave', handleDragLeave);
            fileLabel.addEventListener('drop', (e) => {
                e.preventDefault();
                e.currentTarget.classList.remove('dragover');
                
                const file = e.dataTransfer.files[0];
                if (file) {
                    document.getElementById('fileInput').files = e.dataTransfer.files;
                    handleFileSelect({ target: { files: [file] } });
                }
            });
            
            // Update config from settings
            document.getElementById('networkSelect').addEventListener('change', (e) => {
                config.network = e.target.value;
                log(`ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯å¤‰æ›´: ${config.network}`, 'info');
            });
            
            document.getElementById('retryCount').addEventListener('change', (e) => {
                config.retryCount = parseInt(e.target.value);
                log(`ãƒªãƒˆãƒ©ã‚¤å›æ•°å¤‰æ›´: ${config.retryCount}`, 'info');
            });
            
            document.getElementById('timeout').addEventListener('change', (e) => {
                config.timeout = parseInt(e.target.value) * 1000;
                log(`ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆå¤‰æ›´: ${config.timeout/1000}ç§’`, 'info');
            });
            
            // Display upload history
            setInterval(() => {
                const historyDiv = document.getElementById('uploadHistory');
                if (uploadHistory.length > 0) {
                    historyDiv.innerHTML = uploadHistory.slice(-5).reverse().map(item => `
                        <div class="metric-box">
                            <strong>${item.filename}</strong><br>
                            ${new Date(item.timestamp).toLocaleString()}<br>
                            ${item.metadata?.chunks?.length || item.fileCount || 0} ${item.type === 'directory' ? 'ãƒ•ã‚¡ã‚¤ãƒ«' : 'ãƒãƒ£ãƒ³ã‚¯'}
                        </div>
                    `).join('');
                } else {
                    historyDiv.innerHTML = '<p>ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰å±¥æ­´ã¯ã‚ã‚Šã¾ã›ã‚“</p>';
                }
            }, 5000);
            
            // Debug: Add event listener to file input
            const kaspaFileInput = document.getElementById('kaspaFileInput');
            if (kaspaFileInput) {
                log('kaspaFileInputè¦ç´ ãŒè¦‹ã¤ã‹ã‚Šã¾ã—ãŸ', 'info');
                kaspaFileInput.addEventListener('change', (e) => {
                    log('=== kaspaFileInput change event ===', 'info');
                    log(`Event fired, files: ${e.target.files?.length || 0}`, 'info');
                });
            } else {
                log('è­¦å‘Š: kaspaFileInputè¦ç´ ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“', 'error');
            }
            
            log(`ğŸš€ Kaspa P2P v${getAppVersion()} æº–å‚™å®Œäº†ï¼`, 'info');
            log(`ğŸ“‹ v${getAppVersion()}: ã‚¹ãƒ¼ãƒ‘ãƒ¼ãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿ã§å¤§è¦æ¨¡ãƒ•ã‚¡ã‚¤ãƒ«å¯¾å¿œ`, 'info');
            log('âœ¨ ä¸¦åˆ—ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰: ' + (parallelDownloadEnabled ? 'æœ‰åŠ¹' : 'ç„¡åŠ¹'), 'info');
            log('ã‚·ã‚¹ãƒ†ãƒ ã‚’åˆæœŸåŒ–ã—ã¦ãã ã•ã„', 'info');
            
            // Update title and subtitle with dynamic version
            const version = getAppVersion();
            const titleElement = document.getElementById('appTitle');
            const subtitleElement = document.getElementById('appSubtitle');
            
            if (titleElement) {
                // Extract the subtitle from the document title
                const fullTitle = document.title;
                const titleParts = fullTitle.match(/v[\d.]+\s*-\s*(.+)$/);
                const subtitle = titleParts ? titleParts[1] : 'No LocalStorage Cache';
                titleElement.textContent = `ğŸš€ Kaspa P2P File Storage v${version} - ${subtitle}`;
            }
            
            if (subtitleElement) {
                subtitleElement.textContent = `ğŸ“‹ v${version}: No LocalStorage Cache`;
            }
            
            // Initialize workspace prompt
            setTimeout(async () => {
                // Check if File System Access API is available
                if ('showDirectoryPicker' in window) {
                    const hasWorkspace = window.workspaceHandle !== null;
                    if (!hasWorkspace) {
                        const useFileAPI = confirm(
                            'Kaspa P2P File Storage\n\n' +
                            'ä½œæ¥­ãƒ•ã‚©ãƒ«ãƒ€ã‚’è¨­å®šã—ã¾ã™ã‹ï¼Ÿ\n\n' +
                            'è¨­å®šã™ã‚‹ã¨ï¼š\n' +
                            'âœ“ é€²æ—ãŒãƒ•ã‚¡ã‚¤ãƒ«ã«è‡ªå‹•ä¿å­˜ã•ã‚Œã¾ã™\n' +
                            'âœ“ ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ãƒ•ã‚¡ã‚¤ãƒ«ãŒæ•´ç†ã•ã‚Œã¾ã™\n' +
                            'âœ“ ãƒ–ãƒ©ã‚¦ã‚¶ã‚’é–‰ã˜ã¦ã‚‚é€²æ—ãŒæ®‹ã‚Šã¾ã™\n\n' +
                            'è¨­å®šã—ãªã„å ´åˆï¼š\n' +
                            'âœ“ ãƒ–ãƒ©ã‚¦ã‚¶å†…ã«é€²æ—ãŒä¿å­˜ã•ã‚Œã¾ã™\n' +
                            'âœ“ ãƒ•ã‚¡ã‚¤ãƒ«ã®è‡ªå‹•ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ã¯ã‚ã‚Šã¾ã›ã‚“\n\n' +
                            'â€»ã€Œä½œæ¥­ãƒ•ã‚©ãƒ«ãƒ€è¨­å®šã€ãƒœã‚¿ãƒ³ã§å¾Œã‹ã‚‰è¨­å®šã§ãã¾ã™'
                        );
                        
                        if (useFileAPI) {
                            await setupWorkspace();
                        } else {
                            log('ä½œæ¥­ãƒ•ã‚©ãƒ«ãƒ€æœªè¨­å®š - ãƒ–ãƒ©ã‚¦ã‚¶å†…ã«é€²æ—ã‚’ä¿å­˜ã—ã¾ã™', 'info');
                            showWorkspaceStatus();
                        }
                    } else {
                        showWorkspaceStatus();
                    }
                } else {
                    log('File System Access APIã¯ã“ã®ãƒ–ãƒ©ã‚¦ã‚¶ã§ã¯åˆ©ç”¨ã§ãã¾ã›ã‚“', 'warning');
                }
                
                // Check for saved progress
                const metadata = localStorage.getItem('kaspa-upload-metadata');
                if (metadata) {
                    try {
                        const meta = JSON.parse(metadata);
                        if (meta.completedChunks < meta.totalChunks) {
                            const hoursSince = (Date.now() - meta.lastUpdate) / (1000 * 60 * 60);
                            if (hoursSince < 24) {
                                log(`æœªå®Œäº†ã®ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ãŒè¦‹ã¤ã‹ã‚Šã¾ã—ãŸ`, 'warning');
                                log(`ãƒ•ã‚¡ã‚¤ãƒ«: ${meta.fileName} (${meta.completedChunks}/${meta.totalChunks} ãƒãƒ£ãƒ³ã‚¯)`, 'info');
                                log('ã€Œé€²æ—ãƒ•ã‚¡ã‚¤ãƒ«ã‹ã‚‰å†é–‹ã€ãƒœã‚¿ãƒ³ã‚’ã‚¯ãƒªãƒƒã‚¯ã—ã¦ç¶šè¡Œ', 'info');
                            }
                        }
                    } catch (err) {}
                }
            }, 1000);
            
            // Network status monitoring
            window.addEventListener('online', async () => {
                log('ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯æ¥ç¶šãŒå¾©æ´»ã—ã¾ã—ãŸ', 'success');
                if (rpcClient) {
                    updateNetworkStatus('online', 'ã‚ªãƒ³ãƒ©ã‚¤ãƒ³');
                    
                    // Check if we need to reconnect RPC client
                    if (progressManager && progressManager.progress && 
                        progressManager.progress.metadata.completedChunks < progressManager.progress.metadata.totalChunks) {
                        log('ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ä¸­ - RPCæ¥ç¶šã‚’ç¢ºèªã—ã¾ã™', 'info');
                        
                        // Test RPC connection
                        try {
                            const info = await rpcClient.getServerInfo();
                            log(`RPCæ¥ç¶šç¢ºèª: ${info.serverVersion}`, 'success');
                        } catch (err) {
                            log('RPCæ¥ç¶šã‚¨ãƒ©ãƒ¼ - å†æ¥ç¶šã‚’è©¦ã¿ã¾ã™', 'error');
                            // Reinitialize RPC client
                            await initializeRpcClient();
                            
                            // Restart WebSocket monitoring if it was active
                            if (wsMonitorActive) {
                                log('WebSocketç›£è¦–ã‚’å†é–‹ã—ã¾ã™', 'info');
                                await restartMonitoring();
                            }
                        }
                    }
                }
            });
            
            window.addEventListener('offline', async () => {
                log('ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯æ¥ç¶šãŒåˆ‡æ–­ã•ã‚Œã¾ã—ãŸ', 'error');
                updateNetworkStatus('offline', 'ã‚ªãƒ•ãƒ©ã‚¤ãƒ³');
                
                // Save progress if uploading
                if (progressManager && progressManager.progress) {
                    await progressManager.saveProgress();
                    log('é€²æ—ã‚’è‡ªå‹•ä¿å­˜ã—ã¾ã—ãŸ', 'info');
                }
            });
            
            // Periodic cleanup of old progress data
            setInterval(() => {
                const metadata = localStorage.getItem('kaspa-upload-metadata');
                if (metadata) {
                    try {
                        const meta = JSON.parse(metadata);
                        const daysSince = (Date.now() - meta.lastUpdate) / (1000 * 60 * 60 * 24);
                        if (daysSince > 7) {
                            // Clean up old progress after 7 days
                            localStorage.removeItem('kaspa-upload-progress');
                            localStorage.removeItem('kaspa-upload-metadata');
                            log('å¤ã„é€²æ—ãƒ‡ãƒ¼ã‚¿ã‚’å‰Šé™¤ã—ã¾ã—ãŸ', 'info');
                        }
                    } catch (err) {}
                }
            }, 3600000); // Every hour
            
            // Make functions available globally
            window.setupWorkspace = setupWorkspace;
            window.showWorkspaceStatus = showWorkspaceStatus;
        });
        
        // WebSocket monitoring (unified version with reconnection support)
        window.startMonitoring = async function() {
            if (!rpcClient) {
                log('å…ˆã«ã‚·ã‚¹ãƒ†ãƒ ã‚’åˆæœŸåŒ–ã—ã¦ãã ã•ã„', 'error');
                return;
            }
            
            // Check connection status and reconnect if needed
            try {
                // Test connection with a simple RPC call
                await rpcClient.getServerInfo();
            } catch (error) {
                try {
                    log('RPCå†æ¥ç¶šä¸­...', 'info');
                    await rpcClient.connect();
                    log('RPCå†æ¥ç¶šæˆåŠŸ', 'success');
                } catch (reconnectError) {
                    log(`RPCå†æ¥ç¶šã‚¨ãƒ©ãƒ¼: ${reconnectError.message}`, 'error');
                    return;
                }
            }
            
            if (wsMonitorActive) {
                log('ã™ã§ã«ç›£è¦–ä¸­ã§ã™', 'warning');
                return;
            }
            
            try {
                log('WebSocketç›£è¦–ã‚’é–‹å§‹...', 'info');
                wsMonitorActive = true;
                
                // Set 5 minute timeout
                if (wsMonitorTimeout) {
                    clearTimeout(wsMonitorTimeout);
                }
                wsMonitorTimeout = setTimeout(async () => {
                    log('WebSocketç›£è¦–: 5åˆ†ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆ - è‡ªå‹•åœæ­¢', 'warning');
                    await stopMonitoring();
                }, 5 * 60 * 1000);
                
                await rpcClient.subscribeBlockAdded();
                log('Block Addedã‚¤ãƒ™ãƒ³ãƒˆã‚’è³¼èª­ã—ã¾ã—ãŸ', 'success');
                log('WebSocketçµŒç”±ã§ãƒ–ãƒ­ãƒƒã‚¯è¿½åŠ ã‚¤ãƒ™ãƒ³ãƒˆã®ç›£è¦–ã‚’é–‹å§‹', 'info');
                
                rpcClient.addEventListener('block-added', (event) => {
                    const block = event.data.block;
                    const blockId = block.header.hash;
                    const blockTime = new Date(Number(block.header.timestamp));
                    
                    // Clean up old transactions (older than 90 seconds)
                    const now = Date.now();
                    for (const [txid, txData] of monitoredTransactions.entries()) {
                        if (now - txData.timestamp > 90000) {
                            monitoredTransactions.delete(txid);
                            // log(`WebSocketç›£è¦–ã‹ã‚‰å¤ã„ãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³ã‚’å‰Šé™¤: ${txid.substring(0, 16)}... (90ç§’çµŒé)`, 'debug');
                        }
                    }
                    
                    if (block.transactions && block.transactions.length > 0) {
                        let myTransactionFound = false;
                        
                        for (const tx of block.transactions) {
                            const txId = tx.verboseData?.transactionId || tx.id || tx.transactionId;
                            if (txId) {
                                // Check if this is one of our monitored transactions
                                if (monitoredTransactions.has(txId)) {
                                    // Update existing entry (preserve original data)
                                    const existing = monitoredTransactions.get(txId);
                                    existing.blockId = blockId;
                                    existing.blockTime = blockTime;
                                    existing.foundAt = new Date();
                                    
                                    log(`[DEBUG] WebSocket: ç›£è¦–ä¸­ã®ãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³æ¤œå‡ºï¼ TxID: ${txId.substring(0, 16)}... BlockID: ${blockId.substring(0, 16)}...`, 'debug');
                                    log(`[DEBUG] WebSocket: ãƒ–ãƒ­ãƒƒã‚¯æ™‚åˆ»ã‚’ä¿å­˜ - Time: ${blockTime.toISOString()}`, 'debug');
                                    myTransactionFound = true;
                                    
                                    // Check if there's a pending callback for this transaction
                                    if (window.pendingBlockIds && window.pendingBlockIds.has(txId)) {
                                        log(`[DEBUG] WebSocket: pendingBlockIds ã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯ã‚’å®Ÿè¡Œ - TxID: ${txId.substring(0, 16)}...`, 'debug');
                                        const callback = window.pendingBlockIds.get(txId);
                                        window.pendingBlockIds.delete(txId);
                                        callback(blockId);
                                    } else {
                                        log(`[DEBUG] WebSocket: pendingBlockIds ã«ã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ - TxID: ${txId.substring(0, 16)}...`, 'debug');
                                    }
                                    
                                    // Check if upload is complete after finding this transaction
                                    setTimeout(checkMonitoringStop, 100);
                                } else {
                                    // Skip monitoring other transactions to reduce noise
                                    // We only care about our own transactions
                                }
                            }
                        }
                        
                        
                        // Only log if we found our transaction or if it's a small block
                        if (myTransactionFound) {
                            log(`âœ… WebSocket: ãƒ–ãƒ­ãƒƒã‚¯ ${blockId.substring(0, 16)}... ã§ç›£è¦–ä¸­ã®ãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³ã‚’ç¢ºèª`, 'success');
                        } else if (block.transactions.length <= 5) {
                            // Only log small blocks to reduce noise
                            // log(`WebSocket: ãƒ–ãƒ­ãƒƒã‚¯ ${blockId.substring(0, 16)}... ã« ${block.transactions.length} ãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³`, 'debug');
                        }
                    }
                });
                
                // log(`ç¾åœ¨ç›£è¦–ä¸­ã®ãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³æ•°: ${monitoredTransactions.size}`, 'info');
                
            } catch (error) {
                log(`WebSocketç›£è¦–ã‚¨ãƒ©ãƒ¼: ${error.message}`, 'error');
                wsMonitorActive = false;
                
                // Network error recovery - will retry on reconnect
                if (error.message.includes('network') || error.message.includes('connection')) {
                    log('ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ã‚¨ãƒ©ãƒ¼ã‚’æ¤œå‡º - å†æ¥ç¶šæ™‚ã«å†è©¦è¡Œã—ã¾ã™', 'warning');
                }
            }
        };

        // Monitor log function
        function monitorLog(message, type = 'info') {
            log(`[Monitor] ${message}`, type);
        }

        window.stopMonitoring = async function() {
            if (!wsMonitorActive) {
                monitorLog('ç›£è¦–ã¯é–‹å§‹ã•ã‚Œã¦ã„ã¾ã›ã‚“', 'warning');
                return;
            }
            
            try {
                if (rpcClient) {
                    await rpcClient.unsubscribeBlockAdded();
                    monitorLog('ç›£è¦–ã‚’åœæ­¢ã—ã¾ã—ãŸ', 'success');
                    log('WebSocketç›£è¦–ã‚’åœæ­¢ã—ã¾ã—ãŸ', 'info');
                }
                wsMonitorActive = false;
                
            } catch (error) {
                monitorLog(`ç›£è¦–åœæ­¢ã‚¨ãƒ©ãƒ¼: ${error.message}`, 'error');
                log(`WebSocketç›£è¦–åœæ­¢ã‚¨ãƒ©ãƒ¼: ${error.message}`, 'error');
            }
        };
        
        // Restart monitoring after network recovery
        async function restartMonitoring() {
            if (wsMonitorActive) {
                log('WebSocketç›£è¦–ã®å†èµ·å‹•ã‚’è©¦ã¿ã¾ã™', 'info');
                await stopMonitoring();
                await new Promise(resolve => setTimeout(resolve, 1000)); // Wait 1 second
                await startMonitoring();
            }
        }
        
        // Directory from History functions
        window.selectedHistoryFiles = new Set();
        
        window.showHistoryForDirectory = function() {
            const historyFileSelector = document.getElementById('historyFileSelector');
            const historyFileList = document.getElementById('historyFileList');
            
            // Get history from localStorage
            const history = window.historyManager.getHistory();
            
            // v4.7.24: Filter only file uploads with password AND metaTxId to prevent crashes
            const fileHistory = history.filter(item => {
                if (item.type === 'directory') return false;
                
                // Check if item has password
                const hasPassword = item.password && item.password !== 'ãªã—';
                
                // Check if item has metaTxId
                const hasMetaTxId = item.metaTxId || 
                    (item.metaTxReference && item.metaTxReference.includes(':')) ||
                    item.firstChunkTxId ||
                    (item.chunkTxIds && item.chunkTxIds.length > 0);
                
                // Only show items with both password and TxID
                return hasPassword && hasMetaTxId;
            });
            
            if (fileHistory.length === 0) {
                historyFileList.innerHTML = '<p style="text-align: center; color: #999;">ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ä»˜ãã§TxIDãŒã‚ã‚‹ãƒ•ã‚¡ã‚¤ãƒ«ãŒã‚ã‚Šã¾ã›ã‚“</p>';
            } else {
                historyFileList.innerHTML = fileHistory.map(item => `
                    <div style="padding: 8px; margin-bottom: 5px; background: #0f3460; border-radius: 5px; cursor: pointer;">
                        <label style="display: flex; align-items: center; cursor: pointer;">
                            <input type="checkbox" value="${item.id}" onchange="toggleFileSelection('${item.id}')" style="margin-right: 10px;">
                            <span>
                                ğŸ“„ ${item.fileName || item.name}<br>
                                <small style="color: #999;">
                                    ${formatSize(item.fileSize || item.totalSize)} | 
                                    ${new Date(item.uploadDate).toLocaleDateString('ja-JP')} | 
                                    ğŸ” Passä»˜ã
                                </small>
                            </span>
                        </label>
                    </div>
                `).join('');
            }
            
            historyFileSelector.style.display = 'block';
            window.selectedHistoryFiles.clear();
            updateSelectedFilesInfo();
        };
        
        window.toggleFileSelection = function(fileId) {
            if (window.selectedHistoryFiles.has(fileId)) {
                window.selectedHistoryFiles.delete(fileId);
            } else {
                window.selectedHistoryFiles.add(fileId);
            }
            updateSelectedFilesInfo();
        };
        
        function updateSelectedFilesInfo() {
            const count = window.selectedHistoryFiles.size;
            document.getElementById('selectedCount').textContent = count;
            document.getElementById('selectedFilesInfo').style.display = count > 0 ? 'block' : 'none';
            
            // v4.7.22: Check all conditions for prepare button
            const dirName = document.getElementById('directoryName').value.trim();
            const password = document.getElementById('directoryPassword').value;
            const hasFiles = count > 0;
            
            document.getElementById('prepareDirBtn').disabled = !hasFiles || !dirName || password.length < 8;
            document.getElementById('prepareAndUploadBtn').disabled = !hasFiles || !dirName || password.length < 8;
        }
        
        window.createDirectoryFromHistory = async function() {
            const dirName = document.getElementById('directoryName').value.trim();
            if (!dirName) {
                alert('ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªåã‚’å…¥åŠ›ã—ã¦ãã ã•ã„');
                return;
            }
            
            if (window.selectedHistoryFiles.size === 0) {
                alert('ãƒ•ã‚¡ã‚¤ãƒ«ã‚’é¸æŠã—ã¦ãã ã•ã„');
                return;
            }
            
            const history = window.historyManager.getHistory();
            const selectedFiles = [];
            
            // Collect selected files
            for (const fileId of window.selectedHistoryFiles) {
                const item = history.find(h => h.id === fileId);
                if (item) {
                    // Extract metaTxId properly if it's in old format
                    let metaTxId = item.metaTxId;
                    let blockId = item.metaTxBlockId;
                    
                    // Check if metaTxId contains old format (TxID:BlockID)
                    if (metaTxId && metaTxId.includes(':')) {
                        const parts = metaTxId.split(':');
                        metaTxId = parts[0];
                        blockId = parts[1] || blockId;
                    }
                    
                    // If no metaTxId, use first chunk TxID
                    if (!metaTxId) {
                        metaTxId = item.firstChunkTxId || (item.chunkTxIds && item.chunkTxIds[0]);
                    }
                    
                    selectedFiles.push({
                        name: item.fileName || item.name,
                        path: item.fileName || item.name,
                        type: 'file',
                        metaTxId: metaTxId || '',
                        blockId: blockId || (item.chunkBlockIds && item.chunkBlockIds[0]) || '',
                        size: item.fileSize || item.totalSize || 0
                    });
                }
            }
            
            // Get the first file's password if available
            const firstFileWithPassword = history.find(h => 
                window.selectedHistoryFiles.has(h.id) && h.password
            );
            const password = firstFileWithPassword ? firstFileWithPassword.password : generateRandomCID();
            
            // Check file count warning
            if (selectedFiles.length > 100) {
                log(`âš ï¸ æ³¨æ„: ${selectedFiles.length}å€‹ã®ãƒ•ã‚¡ã‚¤ãƒ«ãŒé¸æŠã•ã‚Œã¦ã„ã¾ã™`, 'warning');
                log('ğŸ“ æ¨å¥¨: 100ãƒ•ã‚¡ã‚¤ãƒ«ä»¥ä¸‹ã«ã™ã‚‹ã“ã¨ã‚’æ¨å¥¨ã—ã¾ã™', 'info');
            }
            
            // Create directory metadata
            const dirMetadata = await createDirectoryMetadata(dirName, selectedFiles, password);
            
            // Check if password should be included
            const includePassword = document.getElementById('includePasswordInDir').checked;
            if (includePassword && firstFileWithPassword) {
                dirMetadata.auth = {
                    passwordIncluded: true,
                    password: firstFileWithPassword.password,
                    warning: "ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ã¯å¹³æ–‡ã§ä¿å­˜ã•ã‚Œã¦ã„ã¾ã™ã€‚ä¿¡é ¼ã§ãã‚‹ç›¸æ‰‹ã¨ã®ã¿å…±æœ‰ã—ã¦ãã ã•ã„ã€‚"
                };
            } else {
                dirMetadata.auth = {
                    passwordIncluded: false,
                    password: null,
                    warning: null
                };
            }
            
            // Generate .kaspa file
            const cid = generateRandomCID();
            const filename = `${dirName}.${cid}.kaspa`;
            const blob = new Blob([JSON.stringify(dirMetadata, null, 2)], { type: 'application/octet-stream' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            a.click();
            URL.revokeObjectURL(url);
            
            log(`ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒª.kaspaãƒ•ã‚¡ã‚¤ãƒ«ã‚’ç”Ÿæˆã—ã¾ã—ãŸ: ${filename}`, 'success');
            
            // Store directory metadata for upload
            window.currentDirectoryMetadata = dirMetadata;
            window.currentDirectoryPassword = password;
            
            // Enable upload button
            document.getElementById('uploadDirBtn').disabled = false;
            
            // Reset UI
            document.getElementById('directoryName').value = '';
            document.getElementById('historyFileSelector').style.display = 'none';
            window.selectedHistoryFiles.clear();
            updateSelectedFilesInfo();
        };
        
        // Prepare directory metadata (v4.7.22)
        window.prepareDirectoryMetadata = async function() {
            const dirName = document.getElementById('directoryName').value.trim();
            if (!dirName) {
                alert('ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªåã‚’å…¥åŠ›ã—ã¦ãã ã•ã„');
                return;
            }
            
            const password = document.getElementById('directoryPassword').value;
            if (password.length < 8) {
                alert('ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ã¯8æ–‡å­—ä»¥ä¸Šå¿…è¦ã§ã™');
                return;
            }
            
            if (window.selectedHistoryFiles.size === 0) {
                alert('ãƒ•ã‚¡ã‚¤ãƒ«ã‚’é¸æŠã—ã¦ãã ã•ã„');
                return;
            }
            
            const history = window.historyManager.getHistory();
            const selectedFiles = [];
            
            // Collect selected files
            for (const fileId of window.selectedHistoryFiles) {
                const item = history.find(h => h.id === fileId);
                if (item) {
                    // Extract metaTxId properly if it's in old format
                    let metaTxId = item.metaTxId;
                    let blockId = item.metaTxBlockId;
                    
                    // Check if metaTxId contains old format (TxID:BlockID)
                    if (metaTxId && metaTxId.includes(':')) {
                        const parts = metaTxId.split(':');
                        metaTxId = parts[0];
                        blockId = parts[1] || blockId;
                    }
                    
                    // If no metaTxId, use first chunk TxID
                    if (!metaTxId) {
                        metaTxId = item.firstChunkTxId || (item.chunkTxIds && item.chunkTxIds[0]);
                    }
                    
                    selectedFiles.push({
                        name: item.fileName || item.name,
                        path: item.fileName || item.name,
                        type: 'file',
                        metaTxId: metaTxId || '',
                        blockId: blockId || (item.chunkBlockIds && item.chunkBlockIds[0]) || '',
                        size: item.fileSize || item.totalSize || 0
                    });
                }
            }
            
            // Check file count warning
            if (selectedFiles.length > 100) {
                log(`âš ï¸ æ³¨æ„: ${selectedFiles.length}å€‹ã®ãƒ•ã‚¡ã‚¤ãƒ«ãŒé¸æŠã•ã‚Œã¦ã„ã¾ã™`, 'warning');
                log('ğŸ“ æ¨å¥¨: 100ãƒ•ã‚¡ã‚¤ãƒ«ä»¥ä¸‹ã«ã™ã‚‹ã“ã¨ã‚’æ¨å¥¨ã—ã¾ã™', 'info');
            }
            
            // Create directory metadata
            const dirMetadata = await createDirectoryMetadata(dirName, selectedFiles, password);
            
            // Store metadata temporarily in memory
            window.tempDirectoryMetadata = {
                metadata: dirMetadata,
                password: password,
                dirName: dirName
            };
            
            // Add entry to history WITHOUT TxID (only in memory for now)
            const uploadData = {
                id: `dir_temp_${Date.now()}`,
                type: 'directory',
                fileName: dirName, // Use fileName for consistency
                name: dirName,
                uploadDate: new Date().toISOString(),
                fileCount: selectedFiles.length,
                totalSize: selectedFiles.reduce((sum, f) => sum + f.size, 0),
                totalCost: 0, // Will be updated after blockchain upload
                metaTxId: null, // Will be filled after blockchain upload
                metaTxBlockId: null,
                password: password,
                metadata: dirMetadata,
                entries: selectedFiles,
                network: config.network,
                isTemporary: true // Mark as temporary until blockchain upload
            };
            
            // Add to history manager
            await window.historyManager.addUpload(uploadData);
            window.historyManager.updateHistoryUI();
            
            log(`ğŸ“ ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿ã‚’ç”Ÿæˆã—ã¾ã—ãŸ: ${dirName}`, 'success');
            log(`å«ã¾ã‚Œã‚‹ãƒ•ã‚¡ã‚¤ãƒ«æ•°: ${selectedFiles.length}`, 'info');
            
            // Reset UI
            document.getElementById('directoryName').value = '';
            document.getElementById('directoryPassword').value = '';
            document.getElementById('historyFileSelector').style.display = 'none';
            window.selectedHistoryFiles.clear();
            updateSelectedFilesInfo();
        };
        
        // Prepare and upload directory metadata in one step
        window.prepareAndUploadDirectory = async function() {
            try {
                log('ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿ã®ç”Ÿæˆã¨ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ã‚’é–‹å§‹ã—ã¾ã™', 'info');
                
                // First, prepare the metadata
                await prepareDirectoryMetadata();
                
                // If metadata was successfully prepared, upload it
                if (window.tempDirectoryMetadata) {
                    log('ãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿ç”ŸæˆæˆåŠŸã€‚ãƒ–ãƒ­ãƒƒã‚¯ãƒã‚§ãƒ¼ãƒ³ã¸ã®ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ã‚’é–‹å§‹ã—ã¾ã™', 'info');
                    await uploadDirectoryToBlockchain();
                } else {
                    log('ã‚¨ãƒ©ãƒ¼: ãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿ãŒç”Ÿæˆã•ã‚Œã¾ã›ã‚“ã§ã—ãŸ', 'error');
                }
            } catch (error) {
                log(`ã‚¨ãƒ©ãƒ¼: ${error.message}`, 'error');
                console.error('prepareAndUploadDirectory error:', error);
            }
        };
        
        // Upload directory metadata to blockchain
        window.uploadDirectoryToBlockchain = async function() {
            if (!window.tempDirectoryMetadata) {
                alert('å…ˆã«ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿ã‚’ç”Ÿæˆã—ã¦ãã ã•ã„');
                return;
            }
            
            const { metadata: dirMetadata, password, dirName } = window.tempDirectoryMetadata;
            
            try {
                // Start WebSocket monitoring if not already active
                if (!wsMonitorActive) {
                    log('WebSocketç›£è¦–ã‚’é–‹å§‹ã—ã¾ã™...', 'info');
                    await startMonitoring();
                }
                
                // Show progress
                log('ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿ã‚’ãƒ–ãƒ­ãƒƒã‚¯ãƒã‚§ãƒ¼ãƒ³ã«ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ä¸­...', 'info');
                
                // Upload directory metadata
                const result = await uploadDirectoryMetadata(dirMetadata, password);
                
                if (result.success) {
                    // Update metadata with blockchain info
                    dirMetadata.metadata.metaTxId = result.txid;
                    dirMetadata.metadata.metaTxBlockId = result.blockId;
                    dirMetadata.metadata.blockTime = new Date().toISOString();
                    
                    // Update recovery info
                    dirMetadata.recovery.uploadCost = result.cost;
                    dirMetadata.recovery.uploadDuration = Date.now() - Date.parse(dirMetadata.created);
                    
                    log(`âœ… ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿ã®ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰å®Œäº†`, 'success');
                    log(`MetaTxID: ${result.txid}`, 'success');
                    log(`BlockID: ${result.blockId}`, 'info');
                    log(`ã‚³ã‚¹ãƒˆ: ${result.cost} KAS`, 'info');
                    
                    // Copy MetaTxID to clipboard
                    await copyToClipboard(`${result.txid}:${result.blockId}`);
                    log('MetaTxID:BlockIDã‚’ã‚¯ãƒªãƒƒãƒ—ãƒœãƒ¼ãƒ‰ã«ã‚³ãƒ”ãƒ¼ã—ã¾ã—ãŸ', 'info');
                    
                    // Update the temporary history entry with blockchain info
                    const history = window.historyManager.getHistory();
                    const tempEntry = history.find(h => h.isTemporary && h.name === dirName);
                    
                    if (tempEntry) {
                        // Update existing entry
                        tempEntry.metaTxId = result.txid;
                        tempEntry.metaTxBlockId = result.blockId;
                        tempEntry.totalCost = result.cost;
                        tempEntry.blockTime = dirMetadata.metadata.blockTime;
                        tempEntry.isTemporary = false; // Remove temporary flag
                        
                        // Save updated history
                        await window.historyManager.saveToFile();
                        window.historyManager.updateHistoryUI();
                        
                        log('å±¥æ­´ã®TxIDã‚’æ›´æ–°ã—ã¾ã—ãŸ', 'success');
                    }
                    
                    // Clear stored metadata
                    window.tempDirectoryMetadata = null;
                    
                } else {
                    log(`âŒ ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ã‚¨ãƒ©ãƒ¼: ${result.error}`, 'error');
                }
                
            } catch (error) {
                log(`âŒ ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ã‚¨ãƒ©ãƒ¼: ${error.message}`, 'error');
            }
        };
        
        // Initialize history manager on load
        window.historyManager = new UploadHistoryManager();
        window.directoryManager = new DirectoryManager();
        window.downloadManager = new DownloadManager();
        
        // Debug information collection
        function collectDebugInfo() {
            const info = {
                userAgent: navigator.userAgent,
                platform: navigator.platform,
                memory: performance.memory ? {
                    used: Math.round(performance.memory.usedJSHeapSize / 1048576) + ' MB',
                    total: Math.round(performance.memory.totalJSHeapSize / 1048576) + ' MB',
                    limit: Math.round(performance.memory.jsHeapSizeLimit / 1048576) + ' MB'
                } : 'N/A',
                localStorage: {
                    size: new Blob(Object.values(localStorage)).size,
                    keys: Object.keys(localStorage).length
                },
                windowSize: `${window.innerWidth}x${window.innerHeight}`,
                devicePixelRatio: window.devicePixelRatio,
                online: navigator.onLine,
                language: navigator.language,
                cookieEnabled: navigator.cookieEnabled,
                webGL: (() => {
                    const canvas = document.createElement('canvas');
                    const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
                    return gl ? 'Supported' : 'Not supported';
                })()
            };
            return info;
        }

        // Global error handler
        window.addEventListener('error', (event) => {
            console.error('Global error caught:', {
                message: event.message,
                filename: event.filename,
                lineno: event.lineno,
                colno: event.colno,
                error: event.error,
                stack: event.error?.stack
            });
            log(`ã‚¨ãƒ©ãƒ¼: ${event.message} (${event.filename}:${event.lineno})`, 'error');
        });

        window.addEventListener('unhandledrejection', (event) => {
            console.error('Unhandled promise rejection:', event.reason);
            log(`æœªå‡¦ç†ã®Promiseã‚¨ãƒ©ãƒ¼: ${event.reason}`, 'error');
        });

        // Memory monitoring
        let memoryMonitorInterval;
        function startMemoryMonitoring() {
            if (!performance.memory) return;
            
            memoryMonitorInterval = setInterval(() => {
                const used = Math.round(performance.memory.usedJSHeapSize / 1048576);
                const total = Math.round(performance.memory.totalJSHeapSize / 1048576);
                const percent = Math.round((used / total) * 100);
                
                if (percent > 90) {
                    log(`âš ï¸ ãƒ¡ãƒ¢ãƒªä½¿ç”¨ç‡è­¦å‘Š: ${percent}% (${used}MB/${total}MB)`, 'warning');
                } else if (percent > 95) {
                    log(`ğŸš¨ ãƒ¡ãƒ¢ãƒªä½¿ç”¨ç‡å±é™º: ${percent}% (${used}MB/${total}MB)`, 'error');
                }
            }, 30000); // Check every 30 seconds
        }

        // Cleanup on page unload
        window.addEventListener('beforeunload', (event) => {
            console.log('Page unloading - cleaning up resources');
            
            // Stop memory monitoring
            if (memoryMonitorInterval) {
                clearInterval(memoryMonitorInterval);
            }
            
            // Close WebSocket connections
            if (window.ws && window.ws.readyState === WebSocket.OPEN) {
                console.log('Closing WebSocket connection');
                window.ws.close();
            }
            
            // Save any pending data
            if (window.historyManager) {
                try {
                    window.historyManager.saveHistory();
                } catch (e) {
                    console.error('Failed to save history on unload:', e);
                }
            }
            
            // Log final debug info
            const finalDebugInfo = collectDebugInfo();
            console.log('=== FINAL DEBUG INFO ===', finalDebugInfo);
        });

        // Auto-initialize WASM on page load
        window.addEventListener('DOMContentLoaded', async function() {
            // Log debug info at startup
            const debugInfo = collectDebugInfo();
            console.log('=== DEBUG INFO ===', debugInfo);
            log(`ãƒ‡ãƒãƒƒã‚°æƒ…å ±: ${JSON.stringify(debugInfo, null, 2)}`, 'debug');
            
            log('ãƒšãƒ¼ã‚¸èª­ã¿è¾¼ã¿å®Œäº† - ã‚·ã‚¹ãƒ†ãƒ ã‚’è‡ªå‹•åˆæœŸåŒ–ã—ã¾ã™', 'info');
            loadParallelSetting(); // Load parallel download setting
            
            try {
                await initializeSystem();
                // Start memory monitoring after successful initialization
                startMemoryMonitoring();
            } catch (error) {
                console.error('Initialization error:', error);
                log(`åˆæœŸåŒ–ã‚¨ãƒ©ãƒ¼: ${error.message}`, 'error');
            }
            
            // Add event listeners for directory inputs
            const dirNameInput = document.getElementById('directoryName');
            if (dirNameInput) {
                dirNameInput.addEventListener('input', function() {
                    updateSelectedFilesInfo();
                });
            }
            
            const dirPasswordInput = document.getElementById('directoryPassword');
            if (dirPasswordInput) {
                dirPasswordInput.addEventListener('input', function() {
                    updateSelectedFilesInfo();
                });
            }
        });
    </script>
    
    <!-- Multi-Wallet Phase 1 Integration -->
    <script>
        // ã‚°ãƒ­ãƒ¼ãƒãƒ«å¤‰æ•°ã¨ã—ã¦å®šç¾©
        let multiWalletTestMode = false;
        let simpleWalletManager = null;
    </script>
    <script src="phase1-multi-wallet.js"></script>
    <script>
        // UIç”¨ã®é–¢æ•°
        function runPhase1Test() {
            const statusEl = document.getElementById('phase1TestStatus');
            statusEl.style.display = 'block';
            statusEl.textContent = 'Running Phase 1 test...\n';
            
            try {
                // ãƒ†ã‚¹ãƒˆå®Ÿè¡Œ
                testPhase1_Basic();
                
                statusEl.textContent += '\nâœ… Phase 1 test completed successfully!\n';
                statusEl.textContent += 'Check browser console for detailed results.\n';
                statusEl.textContent += '\nGenerated wallets:\n';
                
                if (simpleWalletManager && simpleWalletManager.subWallets.length > 0) {
                    simpleWalletManager.subWallets.forEach((w, i) => {
                        statusEl.textContent += `${i + 1}. ${w.address.substring(0, 20)}...${w.address.substring(w.address.length - 10)}\n`;
                    });
                }
                
            } catch (error) {
                statusEl.textContent += `\nâŒ Error: ${error.message}\n`;
                console.error('Phase 1 test error:', error);
            }
        }

        function viewTestResults() {
            const statusEl = document.getElementById('phase1TestStatus');
            statusEl.style.display = 'block';
            
            const data = localStorage.getItem('multiWalletTest_public');
            
            if (data) {
                const parsed = JSON.parse(data);
                statusEl.textContent = 'Saved wallet data:\n\n';
                statusEl.textContent += `Version: ${parsed.version}\n`;
                statusEl.textContent += `Test Mode: ${parsed.testMode}\n`;
                statusEl.textContent += `Timestamp: ${parsed.timestamp}\n`;
                statusEl.textContent += `Wallets: ${parsed.wallets.length}\n\n`;
                
                parsed.wallets.forEach(w => {
                    statusEl.textContent += `${w.id}: ${w.address.substring(0, 20)}...${w.address.substring(w.address.length - 10)}\n`;
                });
            } else {
                statusEl.textContent = 'No saved wallet data found.\n';
                statusEl.textContent += 'Run the test first to generate wallets.';
            }
        }

        function clearPhase1Data() {
            if (confirm('Clear all test wallet data?')) {
                clearTestData();
                const statusEl = document.getElementById('phase1TestStatus');
                statusEl.style.display = 'block';
                statusEl.textContent = 'Test data cleared.';
            }
        }
    </script>
</body>
</html><!-- Force GitHub Pages update: Sat Jul  5 09:53:35 JST 2025 -->

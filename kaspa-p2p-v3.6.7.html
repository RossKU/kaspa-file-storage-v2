<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Kaspa P2P File Storage v3.6.7 - Version Display Update</title>
    <style>
        body {
            font-family: 'Arial', sans-serif;
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
            background: #1a1a2e;
            color: #eee;
        }
        .header {
            background: linear-gradient(135deg, #16213e 0%, #0f3460 100%);
            padding: 30px;
            border-radius: 10px;
            text-align: center;
            margin-bottom: 30px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.3);
        }
        h1 {
            margin: 0;
            color: #e94560;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
        }
        .container {
            background: #0f3460;
            padding: 25px;
            border-radius: 10px;
            margin-bottom: 20px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.2);
        }
        .tab-buttons {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
        }
        .tab-btn {
            flex: 1;
            background: #16213e;
            color: #e94560;
            border: 2px solid #e94560;
            padding: 15px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
            transition: all 0.3s;
        }
        .tab-btn:hover {
            background: #1a2540;
            transform: translateY(-2px);
        }
        .tab-btn.active {
            background: #e94560;
            color: white;
        }
        .tab-content {
            display: none;
        }
        .tab-content.active {
            display: block;
        }
        button {
            background: #e94560;
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
            margin: 5px;
            transition: all 0.3s;
        }
        button:hover {
            background: #c13651;
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(233, 69, 96, 0.3);
        }
        button:disabled {
            background: #666;
            cursor: not-allowed;
            transform: none;
        }
        .small-button {
            background: #16213e;
            color: #49EACB;
            border: 1px solid #49EACB;
            padding: 8px 16px;
            font-size: 14px;
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.3s;
        }
        .small-button:hover {
            background: #49EACB;
            color: #16213e;
        }
        .history-item {
            background: #16213e;
            border: 1px solid #333;
            padding: 15px;
            margin-bottom: 10px;
            border-radius: 5px;
            transition: all 0.3s;
        }
        .history-item:hover {
            border-color: #e94560;
        }
        .history-item-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }
        .history-item-actions button {
            margin-left: 5px;
            padding: 5px 10px;
            font-size: 12px;
        }
        input[type="text"], input[type="password"], input[type="number"], select, textarea {
            width: 100%;
            background: #16213e;
            color: #eee;
            border: 1px solid #e94560;
            padding: 10px;
            border-radius: 5px;
            margin: 5px 0;
            font-family: 'Consolas', monospace;
        }
        input[type="file"] {
            display: none;
        }
        .file-input-label {
            display: inline-block;
            background: #16213e;
            color: #e94560;
            border: 2px dashed #e94560;
            padding: 30px;
            border-radius: 5px;
            cursor: pointer;
            text-align: center;
            transition: all 0.3s;
            width: 100%;
            box-sizing: border-box;
            margin: 10px 0;
        }
        .file-input-label:hover {
            background: #1a2540;
            border-color: #ff5c7c;
        }
        .metric-box {
            background: rgba(233, 69, 96, 0.1);
            border: 1px solid #e94560;
            padding: 15px;
            border-radius: 5px;
            margin: 10px 0;
        }
        .success { color: #4CAF50; }
        .error { color: #ff5252; }
        .warning { color: #ffc107; }
        .info { color: #2196F3; }
        .progress-bar {
            width: 100%;
            height: 30px;
            background: #16213e;
            border-radius: 15px;
            overflow: hidden;
            margin: 10px 0;
        }
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #e94560, #ff5c7c);
            transition: width 0.3s;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: bold;
        }
        .status-indicator {
            display: inline-block;
            width: 10px;
            height: 10px;
            border-radius: 50%;
            margin-right: 5px;
        }
        .status-online { background: #4CAF50; }
        .status-offline { background: #ff5252; }
        .status-connecting { background: #ffc107; animation: pulse 1s infinite; }
        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.5; }
            100% { opacity: 1; }
        }
        .log-container {
            background: #0a0a0a;
            color: #0f0;
            font-family: 'Consolas', monospace;
            font-size: 12px;
            padding: 10px;
            height: 200px;
            overflow-y: auto;
            border-radius: 5px;
            margin: 10px 0;
            white-space: pre-wrap;
            word-wrap: break-word;
        }
        .log-entry {
            margin: 2px 0;
        }
        .log-time {
            color: #888;
        }
        .log-error {
            color: #ff5252;
        }
        .log-success {
            color: #4CAF50;
        }
        .log-info {
            color: #2196F3;
        }
        .log-warning {
            color: #ffc107;
        }
        .chunk-item {
            background: #16213e;
            padding: 10px;
            margin: 5px 0;
            border-radius: 5px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border: 1px solid rgba(233, 69, 96, 0.3);
        }
        .chunk-status {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        .chunk-status.pending { color: #888; }
        .chunk-status.uploading { color: #ffc107; }
        .chunk-status.success { color: #4CAF50; }
        .chunk-status.error { color: #ff5252; }
        .json-view {
            background: #0a0a0a;
            color: #4CAF50;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
            font-family: 'Consolas', monospace;
            font-size: 14px;
            line-height: 1.5;
            max-height: 400px;
            overflow-y: auto;
        }
        .grid-2 {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
        }
        .checkbox-label {
            display: flex;
            align-items: center;
            gap: 10px;
            margin: 10px 0;
        }
        .checkbox-label input[type="checkbox"] {
            width: auto;
        }
        .kaspa-file-drop {
            background: #16213e;
            border: 2px dashed #e94560;
            padding: 40px;
            text-align: center;
            border-radius: 10px;
            transition: all 0.3s;
        }
        .kaspa-file-drop:hover {
            background: #1a2540;
            border-color: #ff5c7c;
        }
        .kaspa-file-drop.dragover {
            background: #1a2540;
            border-color: #4CAF50;
        }
        .copy-btn {
            background: #16213e;
            color: #e94560;
            border: 1px solid #e94560;
            padding: 5px 10px;
            font-size: 12px;
            cursor: pointer;
        }
        .copy-btn:hover {
            background: #e94560;
        }
        /* Toggle switch styles for parallel download */
        .toggle-switch {
            position: relative;
            display: inline-block;
            width: 50px;
            height: 24px;
            margin-left: 10px;
            vertical-align: middle;
        }
        .toggle-switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }
        .toggle-slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #666;
            transition: .4s;
            border-radius: 24px;
        }
        .toggle-slider:before {
            position: absolute;
            content: "";
            height: 18px;
            width: 18px;
            left: 3px;
            bottom: 3px;
            background-color: white;
            transition: .4s;
            border-radius: 50%;
        }
        input:checked + .toggle-slider {
            background-color: #49EACB;
        }
        input:checked + .toggle-slider:before {
            transform: translateX(26px);
        }
        .setting-row {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin: 15px 0;
        }
        .setting-label {
            font-size: 14px;
            color: #eee;
            color: white;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 15px 0;
        }
        th, td {
            padding: 12px;
            text-align: left;
            border-bottom: 1px solid rgba(255,255,255,0.1);
        }
        th {
            background: rgba(233, 69, 96, 0.2);
            color: #e94560;
        }
        .section-divider {
            border-top: 2px solid #e94560;
            margin: 20px 0;
            padding-top: 20px;
        }
        .history-item {
            background: #16213e;
            border: 1px solid rgba(233, 69, 96, 0.3);
            padding: 15px;
            margin: 10px 0;
            border-radius: 8px;
            transition: all 0.3s;
        }
        .history-item:hover {
            border-color: #e94560;
            background: #1a2540;
        }
        .history-item-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 10px;
        }
        .history-item-actions {
            display: flex;
            gap: 5px;
            flex-wrap: wrap;
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>🚀 Kaspa P2P File Storage v3.5.0 - Auto-Resume & History Edition</h1>
        <p>実ネットワーク接続による完全なP2Pファイル共有システム（レジューム＆履歴管理対応）</p>
        <p style="font-size: 12px; color: #49EACB; margin-top: 5px;">📋 v3.5.0: 履歴タブ5ボタン化＆TxID:BlockID:Password形式サポート</p>
        <div id="networkStatus" style="margin-top: 10px;">
            <span class="status-indicator status-offline"></span>
            <span id="statusText">未接続</span>
        </div>
    </div>

    <!-- Tab Navigation -->
    <div class="tab-buttons">
        <button class="tab-btn active" onclick="switchTab('upload')">📤 Upload</button>
        <button class="tab-btn" onclick="switchTab('download')">📥 Download</button>
        <button class="tab-btn" onclick="switchTab('history')">📜 History</button>
        <button class="tab-btn" onclick="switchTab('settings')">⚙️ Settings</button>
    </div>

    <!-- Upload Tab -->
    <div id="upload-tab" class="tab-content active">
        <!-- WASM Initialization -->
        <div class="container">
            <h2>🔧 システム初期化</h2>
            <div class="grid-2">
                <button onclick="initializeSystem()" id="initBtn">システムを初期化</button>
                <button onclick="setupWorkspace()" id="workspaceBtn">作業フォルダ設定</button>
                <button onclick="testConnection()" id="testBtn" disabled>接続テスト</button>
            </div>
            <div id="initStatus" class="metric-box" style="display: none;"></div>
        </div>

        <!-- File Upload -->
        <div class="container">
            <h2>📁 ファイルアップロード</h2>
            
            <label for="fileInput" class="file-input-label">
                📁 ファイルを選択<br>
                <small>またはドラッグ&ドロップ</small>
            </label>
            <input type="file" id="fileInput" onchange="handleFileSelect(event)">
            
            <!-- Resume Section -->
            <div class="section-divider" style="margin: 20px 0;">
                <p style="text-align: center; color: #999;">または</p>
                <button onclick="loadProgressFile()" style="background: #16213e; color: #e94560; border: 2px solid #e94560;">
                    📂 進捗ファイル (.kprogress) から再開
                </button>
                <input type="file" id="progressFileInput" accept=".kprogress" style="display: none;" onchange="handleProgressFileSelect(event)">
            </div>
            
            <!-- Resume Info -->
            <div id="resumeInfo" style="display: none;" class="metric-box">
                <h4 class="success">✅ レジューム準備完了</h4>
                <div id="resumeDetails"></div>
                <button onclick="cancelResume()" style="background: #666; margin-top: 10px;">キャンセル</button>
            </div>
            
            <div class="grid-2">
                <div>
                    <label>パスワード (8文字以上)</label>
                    <input type="password" id="uploadPassword" placeholder="強力なパスワードを入力">
                </div>
                <div>
                    <label>チャンクサイズ</label>
                    <select id="chunkSize">
                        <option value="10">10KB chunks (安全)</option>
                        <option value="12" selected>12KB chunks (推奨)</option>
                        <option value="15">15KB chunks (リスクあり)</option>
                    </select>
                </div>
            </div>
            
            <div class="checkbox-label">
                <input type="checkbox" id="includePassword">
                <label for="includePassword">パスワードを.kaspaファイルに含める（⚠️ セキュリティリスク）</label>
            </div>
            
            <div class="checkbox-label">
                <input type="checkbox" id="useMetaTx">
                <label for="useMetaTx">メタTxIDを使用（.kaspaファイル不要で共有可能）</label>
            </div>
            
            <div class="checkbox-label">
                <input type="checkbox" id="useRandomCid">
                <label for="useRandomCid">ランダムCIDを使用（検閲回避）</label>
            </div>
            
            <button onclick="processAndUpload()" id="uploadBtn" disabled>
                ファイルを処理してアップロード
            </button>
            
            <!-- Upload Progress -->
            <div id="uploadProgress" style="display: none;">
                <div class="progress-bar">
                    <div class="progress-fill" id="uploadProgressBar">0%</div>
                </div>
                <div id="chunksList"></div>
            </div>
            
            <!-- .kaspa generation moved to History tab -->
        </div>
    </div>

    <!-- Download Tab -->
    <div id="download-tab" class="tab-content">
        <div class="container">
            <h2>📥 ファイルダウンロード</h2>
            
            <!-- Meta-TxID input option -->
            <div class="section-divider">
                <h3>🔗 メタTxIDから復元</h3>
                <input type="text" id="metaTxIdInput" placeholder="メタTxID または TxID:BlockID を入力" style="width: 100%;">
                <input type="password" id="metaTxPassword" placeholder="パスワード" style="width: 100%; margin-top: 10px;">
                <button onclick="loadFromMetaTxId()" style="margin-top: 10px;">メタTxIDから復元</button>
                <div class="info" style="margin-top: 10px; font-size: 12px;">
                    <p>📌 対応フォーマット:</p>
                    <ul style="margin: 5px 0; padding-left: 20px;">
                        <li>TxID:BlockID:Password形式（パスワード自動入力）</li>
                        <li>TxID:BlockID形式（推奨、REST API不要）</li>
                        <li>TxIDのみ（REST API必要）</li>
                    </ul>
                </div>
            </div>
            
            <div class="section-divider" style="margin-top: 20px;">
                <h3>📁 または.kaspaファイルから復元</h3>
                <div class="kaspa-file-drop" onclick="document.getElementById('kaspaFileInput').click()" 
                     ondrop="handleKaspaDrop(event)" 
                     ondragover="handleDragOver(event)" 
                     ondragleave="handleDragLeave(event)">
                    <p>📁 .kaspaファイルをクリックして選択<br>またはドラッグ&ドロップ</p>
                </div>
                <input type="file" id="kaspaFileInput" accept=".kaspa" style="display:none" onchange="loadKaspaFile(event)">
            </div>
            
            <div id="downloadSection" style="display: none;">
                <div class="metric-box">
                    <h3>ファイル情報</h3>
                    <pre id="fileInfo"></pre>
                </div>
                
                <div id="passwordSection">
                    <label>パスワード</label>
                    <input type="password" id="downloadPassword" placeholder="パスワードを入力">
                </div>
                
                <button onclick="downloadFile()">ファイルをダウンロード</button>
                
                <div id="downloadProgress" style="display: none;">
                    <div class="progress-bar">
                        <div class="progress-fill" id="downloadProgressBar">0%</div>
                    </div>
                    <div id="downloadStatus"></div>
                </div>
            </div>
        </div>
    </div>

    <!-- History Tab -->
    <div id="history-tab" class="tab-content">
        <div class="container">
            <h2>📜 アップロード履歴</h2>
            
            <div class="metric-box">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
                    <h3>履歴管理</h3>
                    <div>
                        <button onclick="window.historyManager?.exportKenv()" class="small-button">📥 .kenvエクスポート</button>
                        <button onclick="window.historyManager?.importKenv()" class="small-button">📤 .kenvインポート</button>
                    </div>
                </div>
                
                <div id="historyStats" style="margin-bottom: 15px; padding: 10px; background: #0f3460; border-radius: 5px;">
                    <span>総アップロード: <strong id="totalUploads">0</strong></span> | 
                    <span>総容量: <strong id="totalSize">0 KB</strong></span> | 
                    <span>総コスト: <strong id="totalCost">0 KAS</strong></span>
                </div>
                
                <div id="historyList" style="max-height: 400px; overflow-y: auto;">
                    <!-- 履歴アイテムがここに動的に追加される -->
                </div>
            </div>
        </div>
    </div>

    <!-- Settings Tab -->
    <div id="settings-tab" class="tab-content">
        <div class="container">
            <h2>⚙️ 設定</h2>
            
            <div class="metric-box">
                <h3>ネットワーク設定</h3>
                <label>ネットワーク</label>
                <select id="networkSelect">
                    <option value="testnet-10" selected>Testnet-10 (テスト用)</option>
                    <option value="mainnet">Mainnet (本番)</option>
                </select>
                
                <label>リトライ回数</label>
                <input type="number" id="retryCount" value="3" min="0" max="10">
                
                <label>タイムアウト (秒)</label>
                <input type="number" id="timeout" value="30" min="10" max="120">
            </div>
            
            <div class="metric-box">
                <h3>ダウンロード設定</h3>
                <div class="setting-row">
                    <div class="setting-label">
                        並列ダウンロード (実験的機能)<br>
                        <small style="color: #999;">10チャンク以上のファイルで8並列接続を使用</small>
                    </div>
                    <label class="toggle-switch">
                        <input type="checkbox" id="parallelDownloadToggle" onchange="toggleParallelDownload()">
                        <span class="toggle-slider"></span>
                    </label>
                </div>
            </div>
            
            <div class="metric-box">
                <h3>ログエクスポート</h3>
                <button onclick="exportLogs()">ログをJSON形式でエクスポート</button>
                <button onclick="clearLogs()">ログをクリア</button>
            </div>
            
            <div class="metric-box">
                <h3>アップロード履歴</h3>
                <div id="uploadHistory"></div>
            </div>
        </div>
    </div>

    <!-- System Log -->
    <div class="container">
        <h3>📝 システムログ</h3>
        <div class="log-container" id="systemLog"></div>
        <button class="copy-btn" onclick="copyLog()">ログをコピー</button>
    </div>

    <script type="module">
        // Global state
        let kaspa = null;
        let rpcClient = null;
        let currentFile = null;
        let currentPassword = null;
        let processedChunks = [];
        let kaspaMetadata = null;
        let wsMonitorActive = false;
        let monitoredTransactions = new Map();
        let uploadHistory = [];
        let systemLogs = [];
        let privateKey = null;
        let address = null;
        let progressManager = null;
        let wsConnection = null;
        let wsConnected = false;
        let wsReconnectInterval = null;
        let workspaceHandle = null; // File System Access API directory handle
        let progressFileMap = new Map(); // Map of filename -> {cid, fileHandle}
        let historyManager = null; // Upload history manager
        let wsMonitorTimeout = null; // WebSocket monitoring timeout
        let uploadingChunksCount = 0; // Number of chunks being uploaded
        let uploadingMetaTx = false; // Whether meta-tx is being uploaded
        let isUploadingFile = false; // Overall file upload status (v3.6.3 fix)
        
        // Parallel download settings (v3.6.2)
        let parallelDownloadEnabled = false; // Default OFF for v3.5.0 compatibility
        
        // Load parallel download setting from localStorage
        function loadParallelSetting() {
            const saved = localStorage.getItem('kaspaParallelDownload');
            if (saved !== null) {
                parallelDownloadEnabled = saved === 'true';
                const toggle = document.getElementById('parallelDownloadToggle');
                if (toggle) {
                    toggle.checked = parallelDownloadEnabled;
                }
            }
        }
        
        // Upload History Manager Class
        class UploadHistoryManager {
            constructor() {
                this.dbName = 'kaspa-upload-history';
                this.fileName = 'kaspa-uploads.kenv';
                this.maxSize = 100 * 1024 * 1024; // 100MB
                this.archiveSize = 10 * 1024 * 1024; // 10MB chunks
                this.encryptionKey = null;
                log('[UploadHistoryManager] インスタンスを初期化しました', 'debug');
            }
            
            async initialize(privateKey) {
                log('[UploadHistoryManager] 初期化を開始します', 'debug');
                try {
                    // Derive encryption key from private key
                    const keyData = new TextEncoder().encode(privateKey);
                    const hashBuffer = await crypto.subtle.digest('SHA-256', keyData);
                    this.encryptionKey = await crypto.subtle.importKey(
                        'raw',
                        hashBuffer,
                        { name: 'AES-GCM', length: 256 },
                        false,
                        ['encrypt', 'decrypt']
                    );
                    log('[UploadHistoryManager] 暗号化キーを初期化しました', 'success');
                    
                    // Load existing history from workspace
                    if (window.workspaceHandle) {
                        log('[UploadHistoryManager] ワークスペースハンドルが存在します。履歴の読み込みを開始します', 'debug');
                        await this.loadFromFile();
                    } else {
                        log('[UploadHistoryManager] ワークスペースハンドルが存在しません', 'info');
                    }
                } catch (error) {
                    log(`[UploadHistoryManager] 初期化エラー: ${error.message}`, 'error');
                    throw error;
                }
            }
            
            async loadFromFile() {
                log(`[UploadHistoryManager] .kenvファイル「${this.fileName}」の読み込みを開始します`, 'debug');
                try {
                    const fileHandle = await window.workspaceHandle.getFileHandle(this.fileName);
                    log('[UploadHistoryManager] .kenvファイルが見つかりました', 'success');
                    
                    const file = await fileHandle.getFile();
                    const fileSize = file.size;
                    log(`[UploadHistoryManager] ファイルサイズ: ${fileSize} bytes`, 'debug');
                    
                    const encryptedData = await file.text();
                    const data = JSON.parse(encryptedData);
                    log(`[UploadHistoryManager] ファイルのバージョン: ${data.version}、暗号化: ${data.encrypted}`, 'debug');
                    
                    if (data.encrypted) {
                        const decrypted = await this.decrypt(data.data);
                        const kenv = JSON.parse(decrypted);
                        log(`[UploadHistoryManager] 復号化成功。履歴数: ${kenv.uploads?.length || 0}件`, 'debug');
                        
                        // Load into localStorage
                        localStorage.setItem(this.dbName, JSON.stringify(kenv.uploads || []));
                        this.updateHistoryUI();
                        log(`履歴を読み込みました: ${kenv.uploads?.length || 0}件`, 'success');
                    } else {
                        log('[UploadHistoryManager] ファイルが暗号化されていません', 'error');
                    }
                } catch (error) {
                    // File doesn't exist or error reading
                    if (error.name === 'NotFoundError') {
                        log(`[UploadHistoryManager] .kenvファイル「${this.fileName}」が見つかりません`, 'info');
                    } else {
                        log(`[UploadHistoryManager] ファイル読み込みエラー: ${error.name} - ${error.message}`, 'error');
                    }
                }
            }
            
            async saveToFile() {
                if (!window.workspaceHandle) {
                    log('[UploadHistoryManager] ワークスペースハンドルがないため保存をスキップします', 'debug');
                    return;
                }
                
                log('[UploadHistoryManager] 履歴の保存を開始します', 'debug');
                try {
                    const history = this.getHistory();
                    const stats = this.calculateStats();
                    log(`[UploadHistoryManager] 保存する履歴数: ${history.length}件`, 'debug');
                    
                    const kenv = {
                        version: "1.0",
                        schemaVersion: 1,
                        wallet: address?.toString() || '',
                        created: new Date().toISOString(),
                        lastModified: new Date().toISOString(),
                        uploads: history,
                        stats: stats
                    };
                    
                    // Check size and archive if needed
                    const size = new Blob([JSON.stringify(kenv)]).size;
                    log(`[UploadHistoryManager] ファイルサイズチェック: ${size} bytes (最大: ${this.maxSize} bytes)`, 'debug');
                    if (size > this.maxSize) {
                        log('[UploadHistoryManager] ファイルサイズが上限を超えました。アーカイブを開始します', 'info');
                        await this.archiveOldEntries();
                    }
                    
                    // Encrypt and save
                    log('[UploadHistoryManager] データの暗号化を開始します', 'debug');
                    const encrypted = await this.encrypt(JSON.stringify(kenv));
                    const data = {
                        encrypted: true,
                        version: "1.0",
                        data: encrypted
                    };
                    
                    const fileHandle = await window.workspaceHandle.getFileHandle(this.fileName, { create: true });
                    if (fileHandle) {
                        log(`[UploadHistoryManager] .kenvファイル「${this.fileName}」を作成/更新します`, 'debug');
                    }
                    const writable = await fileHandle.createWritable();
                    await writable.write(JSON.stringify(data, null, 2));
                    await writable.close();
                    
                    log('.kenvファイルを保存しました', 'success');
                } catch (error) {
                    log(`[UploadHistoryManager] 履歴保存エラー: ${error.name} - ${error.message}`, 'error');
                }
            }
            
            async encrypt(text) {
                log(`[UploadHistoryManager] 暗号化を開始します (データサイズ: ${text.length} 文字)`, 'debug');
                try {
                    const encoder = new TextEncoder();
                    const data = encoder.encode(text);
                    const iv = crypto.getRandomValues(new Uint8Array(12));
                    
                    const encrypted = await crypto.subtle.encrypt(
                        { name: 'AES-GCM', iv: iv },
                        this.encryptionKey,
                        data
                    );
                    
                    // Combine iv and encrypted data
                    const combined = new Uint8Array(iv.length + encrypted.byteLength);
                    combined.set(iv, 0);
                    combined.set(new Uint8Array(encrypted), iv.length);
                    
                    const result = btoa(String.fromCharCode(...combined));
                    log(`[UploadHistoryManager] 暗号化完了 (結果サイズ: ${result.length} 文字)`, 'debug');
                    return result;
                } catch (error) {
                    log(`[UploadHistoryManager] 暗号化エラー: ${error.message}`, 'error');
                    throw error;
                }
            }
            
            async decrypt(base64) {
                log(`[UploadHistoryManager] 復号化を開始します (データサイズ: ${base64.length} 文字)`, 'debug');
                try {
                    const combined = Uint8Array.from(atob(base64), c => c.charCodeAt(0));
                    const iv = combined.slice(0, 12);
                    const encrypted = combined.slice(12);
                    
                    const decrypted = await crypto.subtle.decrypt(
                        { name: 'AES-GCM', iv: iv },
                        this.encryptionKey,
                        encrypted
                    );
                    
                    const result = new TextDecoder().decode(decrypted);
                    log(`[UploadHistoryManager] 復号化完了 (結果サイズ: ${result.length} 文字)`, 'debug');
                    return result;
                } catch (error) {
                    log(`[UploadHistoryManager] 復号化エラー: ${error.message}`, 'error');
                    throw error;
                }
            }
            
            async addUpload(uploadData) {
                log(`[UploadHistoryManager] 新しいアップロードエントリを追加します: ${uploadData.fileName}`, 'debug');
                try {
                    const history = this.getHistory();
                    const beforeCount = history.length;
                    history.unshift(uploadData); // Add to beginning
                    localStorage.setItem(this.dbName, JSON.stringify(history));
                    log(`[UploadHistoryManager] 履歴に追加しました (${beforeCount} → ${history.length}件)`, 'success');
                    
                    await this.saveToFile();
                    this.updateUI();
                } catch (error) {
                    log(`[UploadHistoryManager] エントリ追加エラー: ${error.message}`, 'error');
                }
            }
            
            getHistory() {
                const data = localStorage.getItem(this.dbName);
                const history = data ? JSON.parse(data) : [];
                log(`[UploadHistoryManager] 履歴を取得しました: ${history.length}件`, 'debug');
                return history;
            }
            
            calculateStats() {
                const history = this.getHistory();
                const stats = {
                    totalUploads: history.length,
                    totalSize: history.reduce((sum, item) => sum + (item.fileSize || 0), 0),
                    totalCost: history.reduce((sum, item) => sum + (item.totalCost || 0), 0)
                };
                log(`[UploadHistoryManager] 統計情報: アップロード${stats.totalUploads}件、総サイズ${stats.totalSize}bytes、総コスト${stats.totalCost}KAS`, 'debug');
                return stats;
            }
            
            updateUI() {
                log('[UploadHistoryManager] UIを更新します', 'debug');
                const stats = this.calculateStats();
                
                // Update stats
                const totalUploads = document.getElementById('totalUploads');
                const totalSize = document.getElementById('totalSize');
                const totalCost = document.getElementById('totalCost');
                
                if (totalUploads) totalUploads.textContent = stats.totalUploads;
                if (totalSize) totalSize.textContent = formatSize(stats.totalSize);
                if (totalCost) totalCost.textContent = stats.totalCost.toFixed(5);
                
                // Update history list
                const historyList = document.getElementById('historyList');
                if (!historyList) {
                    log('[UploadHistoryManager] historyList要素が見つかりません', 'debug');
                    return;
                }
                
                const history = this.getHistory();
                historyList.innerHTML = history.length === 0 ? 
                    '<p style="text-align: center; color: #666;">アップロード履歴がありません</p>' :
                    history.map(item => this.createHistoryItem(item)).join('');
                log(`[UploadHistoryManager] 履歴リストを更新しました (${history.length}件)`, 'debug');
            }
            
            createHistoryItem(item) {
                // Use blockchain time if available, otherwise fall back to upload date
                const dateToUse = item.blockTime || item.uploadDate;
                const date = new Date(dateToUse).toLocaleString('ja-JP');
                log(`[DEBUG] 履歴アイテム表示 - ファイル: ${item.fileName}, 日時: ${date} (blockTime: ${item.blockTime ? 'あり' : 'なし'})`, 'debug');
                
                const hasPassword = item.password && item.password !== 'なし';
                // 後方互換性を保ちながら、新旧両方のデータ形式をサポート
            const hasMetaTxId = (item.metaTxId && item.metaTxBlockId) || (item.metaTxReference && item.metaTxReference.includes(':'));
                
                // Generate buttons based on available data
                const buttons = [];
                
                // .kaspa buttons
                if (hasPassword) {
                    buttons.push(`<button onclick="window.historyManager.generateKaspaWithPassword('${item.id}')" class="small-button" title="パスワード付き.kaspaファイル">🔐.kaspa</button>`);
                } else {
                    buttons.push(`<button class="small-button disabled" title="パスワードが保存されていません" style="opacity: 0.5; cursor: not-allowed;">🔐.kaspa</button>`);
                }
                buttons.push(`<button onclick="window.historyManager.generateKaspaWithoutPassword('${item.id}')" class="small-button" title="パスワードなし.kaspaファイル">🔓.kaspa</button>`);
                
                // TxID buttons
                if (hasMetaTxId) {
                    if (hasPassword) {
                        buttons.push(`<button onclick="if(window.historyManager) window.historyManager.copyMetaTxIdWithPassword('${item.id}'); else console.error('historyManager not initialized');" class="small-button" title="TxID:BlockID:Password形式でコピー">🔐TxID</button>`);
                    } else {
                        buttons.push(`<button class="small-button disabled" title="パスワードが保存されていません" style="opacity: 0.5; cursor: not-allowed;">🔐TxID</button>`);
                    }
                    buttons.push(`<button onclick="if(window.historyManager) window.historyManager.copyMetaTxIdWithoutPassword('${item.id}'); else console.error('historyManager not initialized');" class="small-button" title="TxID:BlockID形式でコピー">🔓TxID</button>`);
                } else {
                    buttons.push(`<button class="small-button disabled" title="メタトランザクションIDが存在しません" style="opacity: 0.5; cursor: not-allowed;">🔐TxID</button>`);
                    buttons.push(`<button class="small-button disabled" title="メタトランザクションIDが存在しません" style="opacity: 0.5; cursor: not-allowed;">🔓TxID</button>`);
                }
                
                // Password button
                if (hasPassword) {
                    buttons.push(`<button onclick="window.copyToClipboard('${item.password}')" class="small-button" title="パスワードをコピー">🔑Pass</button>`);
                } else {
                    buttons.push(`<button class="small-button disabled" title="パスワードが保存されていません" style="opacity: 0.5; cursor: not-allowed;">🔑Pass</button>`);
                }
                
                return `
                    <div class="history-item">
                        <div class="history-item-header">
                            <div>
                                <strong>${item.fileName}</strong>
                                <span style="color: #666; font-size: 12px; margin-left: 10px;">${formatSize(item.fileSize)}</span>
                            </div>
                            <div class="history-item-actions">
                                ${buttons.join('\n                                ')}
                            </div>
                        </div>
                        <div style="font-size: 12px; color: #999;">
                            <div>日時: ${date}</div>
                            <div>チャンク: ${item.chunks} | コスト: ${item.totalCost?.toFixed(5) || 0} KAS</div>
                            ${item.metaTxId ? `<div>MetaTxID: ${item.metaTxId.substring(0, 16)}...</div>` : ''}
                        </div>
                    </div>
                `;
            }
            
            async generateKaspaWithPassword(uploadId) {
                log(`[UploadHistoryManager] パスワード付き.kaspaファイルの生成を開始します (ID: ${uploadId})`, 'debug');
                const history = this.getHistory();
                const item = history.find(h => h.id === uploadId);
                if (!item) {
                    log(`[UploadHistoryManager] 指定されたIDの履歴が見つかりません: ${uploadId}`, 'error');
                    return;
                }
                
                if (!item.password) {
                    log('パスワードが保存されていません', 'warning');
                    alert('パスワードが保存されていません。鍵なし.kaspaをご利用ください。');
                    return;
                }
                
                await this.generateKaspa(uploadId, true);
            }
            
            async generateKaspaWithoutPassword(uploadId) {
                log(`[UploadHistoryManager] パスワードなし.kaspaファイルの生成を開始します (ID: ${uploadId})`, 'debug');
                await this.generateKaspa(uploadId, false);
            }
            
            async copyMetaTxIdWithPassword(uploadId) {
                log(`[UploadHistoryManager] パスワード付きTxIDのコピーを開始します (ID: ${uploadId})`, 'debug');
                const history = this.getHistory();
                const item = history.find(h => h.id === uploadId);
                if (!item) {
                    log(`[UploadHistoryManager] 指定されたIDの履歴が見つかりません: ${uploadId}`, 'error');
                    return;
                }
                
                // 新旧両方のデータ形式をサポート
                let txId, blockId;
                if (item.metaTxId && item.metaTxBlockId) {
                    // 新形式
                    txId = item.metaTxId;
                    blockId = item.metaTxBlockId;
                } else if (item.metaTxReference && item.metaTxReference.includes(':')) {
                    // 旧形式
                    const parts = item.metaTxReference.split(':');
                    txId = parts[0];
                    blockId = parts[1];
                } else {
                    log('メタトランザクションIDが存在しません', 'warning');
                    alert('メタトランザクションIDが存在しません');
                    return;
                }
                
                if (!item.password) {
                    log('パスワードが保存されていません', 'warning');
                    alert('パスワードが保存されていません。鍵なしTxIDをご利用ください。');
                    return;
                }
                
                const textToCopy = `${txId}:${blockId}:${item.password}`;
                await window.copyToClipboard(textToCopy);
                log('パスワード付きTxIDをコピーしました（パスワードが含まれています）', 'warning');
            }
            
            async copyMetaTxIdWithoutPassword(uploadId) {
                log(`[UploadHistoryManager] パスワードなしTxIDのコピーを開始します (ID: ${uploadId})`, 'debug');
                const history = this.getHistory();
                const item = history.find(h => h.id === uploadId);
                if (!item) {
                    log(`[UploadHistoryManager] 指定されたIDの履歴が見つかりません: ${uploadId}`, 'error');
                    return;
                }
                
                // 新旧両方のデータ形式をサポート
                let txId, blockId;
                if (item.metaTxId && item.metaTxBlockId) {
                    // 新形式
                    txId = item.metaTxId;
                    blockId = item.metaTxBlockId;
                } else if (item.metaTxReference && item.metaTxReference.includes(':')) {
                    // 旧形式
                    const parts = item.metaTxReference.split(':');
                    txId = parts[0];
                    blockId = parts[1];
                } else {
                    log('メタトランザクションIDが存在しません', 'warning');
                    alert('メタトランザクションIDが存在しません');
                    return;
                }
                
                const textToCopy = `${txId}:${blockId}`;
                await window.copyToClipboard(textToCopy);
                log('TxID:BlockID形式でコピーしました', 'success');
            }
            
            async generateKaspa(uploadId, includePassword) {
                log(`[UploadHistoryManager] .kaspaファイルの生成を開始します (ID: ${uploadId}, パスワード含む: ${includePassword})`, 'debug');
                const history = this.getHistory();
                const item = history.find(h => h.id === uploadId);
                if (!item) {
                    log(`[UploadHistoryManager] 指定されたIDの履歴が見つかりません: ${uploadId}`, 'error');
                    return;
                }
                
                log(`[UploadHistoryManager] 履歴項目が見つかりました: ${item.fileName}`, 'debug');
                
                // Create .kaspa metadata from history
                const kaspaMetadata = {
                    version: "2.0",
                    created: item.uploadDate,
                    network: item.network || 'testnet-10',
                    metadata: {
                        metaTxId: item.metaTxId,
                        metaTxBlockId: item.metaTxBlockId,
                        uploadDate: item.uploadDate,
                        blockTime: item.blockTime || item.uploadDate // Use blockTime if available
                    },
                    file: {
                        name: item.fileName,
                        size: item.fileSize,
                        encrypted: true,
                        compression: item.compression || {
                            algorithm: "none",
                            originalSize: item.fileSize,
                            compressedSize: item.fileSize
                        },
                        encryption: {
                            algorithm: "AES-256-GCM",
                            salt: item.salt || ""
                        }
                    },
                    chunks: item.chunkTxIds || [],
                    chunkBlockIds: item.chunkBlockIds || [],
                    recovery: {
                        totalChunks: item.chunks,
                        chunkSize: item.chunkSize || 12288,
                        checksum: item.checksum || "",
                        uploadCost: item.totalCost
                    }
                };
                
                // Include password if requested and available
                if (includePassword && item.password) {
                    kaspaMetadata.password = item.password;
                    kaspaMetadata.auth = {
                        passwordIncluded: true,
                        warning: "パスワードは平文で保存されています。信頼できる相手とのみ共有してください。"
                    };
                    log('パスワードを.kaspaファイルに含めます', 'info');
                } else {
                    log('パスワードなしの.kaspaファイルを生成します', 'info');
                }
                
                // Create and download .kaspa file with CID
                const cid = item.cid || generateRandomCID();
                const filename = generateSafeFilename(item.fileName, cid);
                const blob = new Blob([JSON.stringify(kaspaMetadata, null, 2)], { type: 'application/octet-stream' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = filename;
                a.click();
                URL.revokeObjectURL(url);
                
                const typeStr = includePassword ? 'パスワード付き' : 'パスワードなし';
                log(`${typeStr}.kaspaファイルを生成しました: ${filename}`, 'success');
                log(`[DEBUG] .kaspaファイル生成完了 - サイズ: ${blob.size} bytes`, 'debug');
            }
            
            async exportKenv() {
                log('[UploadHistoryManager] .kenvファイルのエクスポートを開始します', 'debug');
                try {
                    await this.saveToFile();
                    
                    // Also trigger download
                    const fileHandle = await window.workspaceHandle.getFileHandle(this.fileName);
                    const file = await fileHandle.getFile();
                    const content = await file.text();
                    log(`[UploadHistoryManager] エクスポートファイルサイズ: ${content.length} 文字`, 'debug');
                    
                    const blob = new Blob([content], { type: 'application/json' });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = this.fileName;
                    a.click();
                    URL.revokeObjectURL(url);
                    
                    log('.kenvファイルをエクスポートしました', 'success');
                } catch (error) {
                    log(`[UploadHistoryManager] エクスポートエラー: ${error.name} - ${error.message}`, 'error');
                }
            }
            
            async importKenv() {
                log('[UploadHistoryManager] .kenvファイルのインポートを開始します', 'debug');
                try {
                    const input = document.createElement('input');
                    input.type = 'file';
                    input.accept = '.kenv';
                    
                    input.onchange = async (e) => {
                        const file = e.target.files[0];
                        if (!file) {
                            log('[UploadHistoryManager] ファイルが選択されませんでした', 'info');
                            return;
                        }
                        
                        log(`[UploadHistoryManager] インポートファイル: ${file.name} (${file.size} bytes)`, 'debug');
                        
                        try {
                            const content = await file.text();
                            const data = JSON.parse(content);
                            log(`[UploadHistoryManager] ファイルバージョン: ${data.version}、暗号化: ${data.encrypted}`, 'debug');
                            
                            if (data.encrypted && data.data) {
                                const decrypted = await this.decrypt(data.data);
                                const kenv = JSON.parse(decrypted);
                                log(`[UploadHistoryManager] インポートデータ: ${kenv.uploads?.length || 0}件の履歴`, 'debug');
                                
                                // Merge with existing history
                                const existingHistory = this.getHistory();
                                const beforeCount = existingHistory.length;
                                const newHistory = [...kenv.uploads, ...existingHistory];
                                
                                // Remove duplicates by id
                                const uniqueHistory = newHistory.filter((item, index, self) =>
                                    index === self.findIndex(h => h.id === item.id)
                                );
                                const duplicates = newHistory.length - uniqueHistory.length;
                                if (duplicates > 0) {
                                    log(`[UploadHistoryManager] ${duplicates}件の重複を除去しました`, 'info');
                                }
                                
                                localStorage.setItem(this.dbName, JSON.stringify(uniqueHistory));
                                await this.saveToFile();
                                this.updateHistoryUI();
                                
                                const addedCount = uniqueHistory.length - beforeCount;
                                log(`${addedCount}件の履歴をインポートしました (総数: ${uniqueHistory.length}件)`, 'success');
                            } else {
                                log('[UploadHistoryManager] ファイルが暗号化されていないか、データが無効です', 'error');
                            }
                        } catch (error) {
                            log(`[UploadHistoryManager] インポート処理エラー: ${error.message}`, 'error');
                        }
                    };
                    
                    input.click();
                } catch (error) {
                    log(`[UploadHistoryManager] インポートエラー: ${error.message}`, 'error');
                }
            }
            
            async archiveOldEntries() {
                log('[UploadHistoryManager] アーカイブ処理を開始します', 'debug');
                const history = this.getHistory();
                log(`[UploadHistoryManager] 現在の履歴数: ${history.length}件`, 'debug');
                
                if (history.length <= 100) {
                    log('[UploadHistoryManager] 履歴数が100件以下のためアーカイブは不要です', 'debug');
                    return;
                }
                
                // Keep recent 100 entries
                const recentHistory = history.slice(0, 100);
                const archiveHistory = history.slice(100);
                log(`[UploadHistoryManager] アーカイブ対象: ${archiveHistory.length}件、保持: ${recentHistory.length}件`, 'info');
                
                // Save archive
                const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
                const archiveName = `kaspa-uploads-archive-${timestamp}.kenv`;
                log(`[UploadHistoryManager] アーカイブファイル名: ${archiveName}`, 'debug');
                
                try {
                    const archiveData = {
                        version: "1.0",
                        archived: true,
                        uploads: archiveHistory
                    };
                    
                    const encrypted = await this.encrypt(JSON.stringify(archiveData));
                    const data = {
                        encrypted: true,
                        version: "1.0",
                        data: encrypted
                    };
                    
                    const fileHandle = await window.workspaceHandle.getFileHandle(archiveName, { create: true });
                    const writable = await fileHandle.createWritable();
                    await writable.write(JSON.stringify(data, null, 2));
                    await writable.close();
                    log(`[UploadHistoryManager] アーカイブファイルを作成しました: ${archiveName}`, 'success');
                    
                    // Update current history
                    localStorage.setItem(this.dbName, JSON.stringify(recentHistory));
                    log(`${archiveHistory.length}件の古い履歴をアーカイブしました`, 'info');
                } catch (error) {
                    log(`[UploadHistoryManager] アーカイブエラー: ${error.message}`, 'error');
                    throw error;
                }
            }
            
            updateHistoryUI() {
                log('[UploadHistoryManager] updateHistoryUI が呼び出されました', 'debug');
                this.updateUI();
            }
        }
        
        // Utility functions
        function formatSize(bytes) {
            if (bytes === 0) return '0 B';
            const k = 1024;
            const sizes = ['B', 'KB', 'MB', 'GB', 'TB'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
        }
        
        window.copyToClipboard = async function(text) {
            const preview = text && text.length > 20 ? text.substring(0, 20) + '...' : text;
            log(`[DEBUG] copyToClipboard が呼び出されました: ${preview}`, 'debug');
            try {
                await navigator.clipboard.writeText(text);
                log('クリップボードにコピーしました', 'success');
            } catch (err) {
                log(`コピーエラー: ${err.message}`, 'error');
            }
        }
        
        // Progress Manager Class
        class ProgressManager {
            constructor(file, chunkSize, cid = null, type = 'upload') {
                this.file = file;
                this.chunkSize = chunkSize;
                this.cid = cid;
                this.type = type; // 'upload' or 'download'
                // Use .kprogress extension with CID
                const baseName = file.name || 'file';
                this.progressFileName = cid ? `${baseName}.${cid}.kprogress` : `${baseName}.kprogress`;
                this.progress = null;
                this.saveHandle = null;
                this.autoSaveInterval = 10; // chunks
                this.lastSaveTime = 0;
                this.saveThrottle = 5000; // Save at most once every 5 seconds
                this.fileHandle = null; // For File System Access API
            }
            
            async initialize(existingProgress = null) {
                if (existingProgress) {
                    this.progress = existingProgress;
                    log(`既存の進捗から再開: ${this.progress.metadata.completedChunks}/${this.progress.metadata.totalChunks} チャンク完了`, 'info');
                    
                    // Optimize save frequency for resume - more frequent saves
                    this.autoSaveInterval = 5; // Save every 5 chunks for resumed uploads
                    this.saveThrottle = 3000; // Save at most once every 3 seconds
                    log('レジューム時の進捗保存頻度を最適化しました', 'info');
                    
                    return true;
                }
                
                // Generate file hash for verification
                const fileData = await this.file.slice(0, 1024 * 1024).arrayBuffer(); // First 1MB
                const hashBuffer = await crypto.subtle.digest('SHA-256', fileData);
                const hashArray = Array.from(new Uint8Array(hashBuffer));
                const fileHash = hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
                
                this.progress = {
                    version: "2.1",
                    type: this.type, // 'upload' or 'download'
                    cid: this.cid,
                    fileInfo: {
                        name: this.file.name,
                        size: this.file.size,
                        lastModified: this.file.lastModified,
                        sha256: fileHash.substring(0, 16), // First 16 chars of hash
                        mimeType: this.file.type || 'application/octet-stream'
                    },
                    encryption: {
                        algorithm: "AES-256-GCM",
                        salt: null, // Will be set during encryption
                        compressed: null
                    },
                    chunks: [],
                    metadata: {
                        totalChunks: Math.ceil(this.file.size / this.chunkSize),
                        completedChunks: 0,
                        chunkSize: this.chunkSize,
                        totalCost: 0,
                        startedAt: Date.now(),
                        lastUpdateAt: Date.now(),
                        estimatedCompletion: null
                    },
                    resume: {
                        nextChunkIndex: 0,
                        failedChunks: [],
                        retryCount: {}
                    }
                };
                
                return false;
            }
            
            async checkExistingProgress() {
                // This will be called when user selects a progress file
                // Returns the progress object if valid, null otherwise
                return null;
            }
            
            validateProgress(progress) {
                // Check if progress matches current file
                if (!progress || !progress.fileInfo) return false;
                if (progress.fileInfo.name !== this.file.name) return false;
                if (progress.fileInfo.size !== this.file.size) return false;
                // Optional: check lastModified if strict matching needed
                return true;
            }
            
            async markChunkComplete(index, txid, blockId, size) {
                const chunk = {
                    index: index,
                    txid: txid,
                    blockId: blockId,
                    size: size,
                    uploadedAt: Date.now(),
                    verified: true
                };
                
                // Update or add chunk
                const existingIndex = this.progress.chunks.findIndex(c => c.index === index);
                if (existingIndex >= 0) {
                    this.progress.chunks[existingIndex] = chunk;
                } else {
                    this.progress.chunks.push(chunk);
                }
                
                this.progress.metadata.completedChunks = this.progress.chunks.length;
                this.progress.metadata.lastUpdateAt = Date.now();
                this.progress.resume.nextChunkIndex = this.getNextChunkIndex();
                
                // Dynamically adjust save frequency based on progress
                const progressPercentage = (this.progress.metadata.completedChunks / this.progress.metadata.totalChunks) * 100;
                if (progressPercentage > 90) {
                    // Near completion: save every 2 chunks
                    this.autoSaveInterval = 2;
                    this.saveThrottle = 2000;
                } else if (progressPercentage > 75) {
                    // Final stretch: save every 3 chunks
                    this.autoSaveInterval = 3;
                    this.saveThrottle = 2500;
                }
                
                // Calculate estimated completion
                const elapsed = Date.now() - this.progress.metadata.startedAt;
                const rate = this.progress.metadata.completedChunks / elapsed;
                const remaining = this.progress.metadata.totalChunks - this.progress.metadata.completedChunks;
                this.progress.metadata.estimatedCompletion = Date.now() + (remaining / rate);
                
                // Auto-save check
                if (this.progress.metadata.completedChunks % this.autoSaveInterval === 0) {
                    await this.saveProgress();
                }
            }
            
            markChunkFailed(index) {
                if (!this.progress.resume.failedChunks.includes(index)) {
                    this.progress.resume.failedChunks.push(index);
                }
                this.progress.resume.retryCount[index] = (this.progress.resume.retryCount[index] || 0) + 1;
            }
            
            getNextChunkIndex() {
                // First, try failed chunks
                if (this.progress.resume.failedChunks.length > 0) {
                    return this.progress.resume.failedChunks.shift();
                }
                
                // Then find next incomplete chunk
                for (let i = 0; i < this.progress.metadata.totalChunks; i++) {
                    if (!this.progress.chunks.some(c => c.index === i)) {
                        return i;
                    }
                }
                
                return -1; // All done
            }
            
            async saveProgress() {
                try {
                    const progressData = JSON.stringify(this.progress, null, 2);
                    
                    // Save to localStorage as backup
                    try {
                        localStorage.setItem('kaspa-upload-progress', progressData);
                        const metadata = {
                            fileName: this.progress.fileInfo.name,
                            fileSize: this.progress.fileInfo.size,
                            totalChunks: this.progress.metadata.totalChunks,
                            completedChunks: this.progress.metadata.completedChunks,
                            lastUpdate: Date.now()
                        };
                        localStorage.setItem('kaspa-upload-metadata', JSON.stringify(metadata));
                        // Show local save status occasionally
                        if (!this.lastLocalSaveLog || Date.now() - this.lastLocalSaveLog > 10000) {
                            log(`進捗をローカルに保存中`, 'success');
                            this.lastLocalSaveLog = Date.now();
                        }
                    } catch (err) {
                        log(`localStorage保存エラー: ${err.message}`, 'warning');
                    }
                    
                    // Save to file if workspace is available
                    if (window.workspaceHandle) {
                        try {
                            const fileHandle = await window.workspaceHandle.getFileHandle(
                                this.progressFileName,
                                { create: true }
                            );
                            const writable = await fileHandle.createWritable();
                            await writable.write(progressData);
                            await writable.close();
                            
                            // Show status only occasionally
                            if (!this.lastSaveLog || Date.now() - this.lastSaveLog > 10000) {
                                log(`進捗を作業フォルダに保存中`, 'success');
                                this.lastSaveLog = Date.now();
                            }
                            this.updateSaveStatus();
                        } catch (err) {
                            log(`ファイル保存エラー: ${err.message}`, 'warning');
                        }
                    } else {
                        // No workspace - localStorage only, no automatic downloads
                        this.updateSaveStatus();
                    }
                } catch (error) {
                    log(`進捗保存エラー: ${error.message}`, 'error');
                }
            }
            
            updateSaveStatus() {
                const statusEl = document.getElementById('saveStatus');
                if (!statusEl) {
                    const div = document.createElement('div');
                    div.id = 'saveStatus';
                    div.style.cssText = 'position: fixed; top: 10px; right: 10px; background: #4CAF50; color: white; padding: 10px; border-radius: 5px; display: none; z-index: 10000;';
                    document.body.appendChild(div);
                }
                
                const el = document.getElementById('saveStatus');
                if (window.workspaceHandle) {
                    el.textContent = '✓ ファイル保存中';
                } else {
                    el.textContent = '✓ ローカル保存中';
                }
                el.style.display = 'block';
                
                clearTimeout(this.saveStatusTimeout);
                this.saveStatusTimeout = setTimeout(() => {
                    el.style.display = 'none';
                }, 2000);
            }
            
            async exportProgress() {
                // Manual export function for user
                const progressData = JSON.stringify(this.progress, null, 2);
                const blob = new Blob([progressData], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = this.progressFileName;
                
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                
                log(`進捗ファイルをエクスポートしました`, 'success');
            }
            
            async exportAsKaspa(kaspaMetadata) {
                // Convert progress to .kaspa format when upload completes
                const kaspaFile = {
                    ...kaspaMetadata,
                    resume: {
                        supported: true,
                        progressFile: this.progressFileName,
                        chunks: this.progress.chunks
                    }
                };
                
                return kaspaFile;
            }
            
            getStats() {
                const completed = this.progress.metadata.completedChunks;
                const total = this.progress.metadata.totalChunks;
                const progressPercent = (completed / total * 100);
                
                console.log(`ProgressManager Stats: ${completed}/${total} 完了 (${progressPercent.toFixed(1)}%)`);
                
                return {
                    completedChunks: completed,
                    totalChunks: total,
                    percentage: progressPercent,
                    remaining: total - completed,
                    estimatedTime: this.progress.metadata.estimatedCompletion ? 
                        new Date(this.progress.metadata.estimatedCompletion).toLocaleTimeString() : 'N/A'
                };
            }
        }
        
        // Parallel Downloader Class (v3.6.2)
        class ParallelDownloader {
            constructor(rpcClient, concurrency = 8) {
                this.rpcClient = rpcClient;
                this.concurrency = concurrency;
                this.queue = [];
                this.active = 0;
                this.results = new Map();
                this.errors = new Map();
                this.startTime = null;
                this.completedCount = 0;
                this.totalBytes = 0;
                this.queueLock = false;
                this.maxRetries = 3;
            }
            
            async downloadChunks(chunksMetadata, key, kaspaMetadata, progressCallback) {
                this.startTime = Date.now();
                this.queue = chunksMetadata.map((chunk, index) => ({ 
                    chunk, 
                    index, 
                    retries: 0 
                }));
                this.results = new Map();
                this.errors = new Map();
                this.completedCount = 0;
                this.totalBytes = 0;
                this.totalChunks = chunksMetadata.length;
                
                log(`並列ダウンロード開始: ${chunksMetadata.length}チャンク, ${this.concurrency}並列`, 'info');
                
                try {
                    const workers = [];
                    for (let i = 0; i < this.concurrency; i++) {
                        workers.push(this.worker(key, kaspaMetadata, progressCallback));
                    }
                    
                    await Promise.all(workers);
                    
                    if (this.errors.size > 0) {
                        const errorRate = (this.errors.size / chunksMetadata.length) * 100;
                        if (errorRate > 10) {
                            const errorMsg = Array.from(this.errors.entries())
                                .map(([idx, err]) => `チャンク${idx}: ${err}`)
                                .join(', ');
                            throw new Error(`ダウンロードエラー率が高すぎます (${errorRate.toFixed(1)}%): ${errorMsg}`);
                        }
                    }
                    
                    const sortedChunks = [];
                    for (let i = 0; i < chunksMetadata.length; i++) {
                        if (!this.results.has(i)) {
                            if (this.errors.has(i)) {
                                throw new Error(`チャンク${i}のダウンロードに失敗: ${this.errors.get(i)}`);
                            } else {
                                throw new Error(`チャンク${i}が見つかりません`);
                            }
                        }
                        sortedChunks.push(this.results.get(i));
                    }
                    
                    const elapsed = (Date.now() - this.startTime) / 1000;
                    const throughput = (this.totalBytes / 1024 / 1024) / elapsed;
                    log(`並列ダウンロード完了: ${elapsed.toFixed(1)}秒, ${throughput.toFixed(1)} MB/秒`, 'success');
                    
                    return sortedChunks;
                } catch (error) {
                    log(`並列ダウンロードエラー: ${error.message}`, 'error');
                    throw error;
                }
            }
            
            async worker(key, kaspaMetadata, progressCallback) {
                while (true) {
                    let work = null;
                    
                    while (this.queueLock) {
                        await new Promise(resolve => setTimeout(resolve, 10));
                    }
                    
                    this.queueLock = true;
                    try {
                        if (this.queue.length > 0) {
                            work = this.queue.shift();
                            this.active++;
                        }
                    } finally {
                        this.queueLock = false;
                    }
                    
                    if (!work && this.active === 0) {
                        break;
                    }
                    
                    if (!work) {
                        await new Promise(resolve => setTimeout(resolve, 50));
                        continue;
                    }
                    
                    try {
                        const { chunk: chunkMeta, index } = work;
                        
                        let response = null;
                        let lastError = null;
                        
                        for (let retry = 0; retry <= this.maxRetries; retry++) {
                            try {
                                response = await this.rpcClient.getBlock({
                                    hash: chunkMeta.blockId,
                                    includeTransactions: true
                                });
                                break;
                            } catch (error) {
                                lastError = error;
                                if (retry < this.maxRetries) {
                                    log(`チャンク${index}の取得に失敗 (リトライ ${retry + 1}/${this.maxRetries})`, 'warning');
                                    await new Promise(resolve => setTimeout(resolve, 1000 * (retry + 1)));
                                }
                            }
                        }
                        
                        if (!response) {
                            throw lastError || new Error('ブロック取得に失敗');
                        }
                        
                        const block = response?.block?.block || response?.block;
                        if (!block) {
                            throw new Error(`ブロックが見つかりません: ${chunkMeta.blockId}`);
                        }
                        
                        let payload = null;
                        for (const tx of block.transactions || []) {
                            const txId = tx.verboseData?.transactionId || tx.id || tx.transactionId;
                            if (txId === chunkMeta.txid) {
                                if (tx.payload && tx.payload !== '') {
                                    payload = safeHexDecode(tx.payload, 'chunk payload');
                                    break;
                                }
                            }
                        }
                        
                        if (!payload) {
                            throw new Error(`ペイロードが見つかりません`);
                        }
                        
                        const decrypted = await decryptChunk(payload, key, index);
                        const original = kaspaMetadata.compression.enabled ? 
                            lzDecompress(decrypted) : decrypted;
                        
                        this.results.set(index, original);
                        this.completedCount++;
                        this.totalBytes += original.length;
                        
                        const elapsed = (Date.now() - this.startTime) / 1000;
                        const speed = this.completedCount / elapsed;
                        const throughput = (this.totalBytes / 1024 / 1024) / elapsed;
                        
                        if (progressCallback) {
                            progressCallback({
                                completed: this.completedCount,
                                total: this.totalChunks,
                                speed: speed,
                                throughput: throughput
                            });
                        }
                        
                    } catch (error) {
                        work.retries++;
                        if (work.retries <= this.maxRetries) {
                            while (this.queueLock) {
                                await new Promise(resolve => setTimeout(resolve, 10));
                            }
                            this.queueLock = true;
                            try {
                                this.queue.push(work);
                            } finally {
                                this.queueLock = false;
                            }
                            log(`チャンク${work.index}を再試行キューに追加 (${work.retries}/${this.maxRetries})`, 'warning');
                        } else {
                            log(`ワーカーエラー (チャンク${work.index}): ${error.message}`, 'error');
                            this.errors.set(work.index, error.message);
                        }
                    } finally {
                        this.active--;
                    }
                }
            }
        }
        
        // Configuration
        const config = {
            network: 'testnet-10',
            retryCount: 3,
            timeout: 30000,
            testPrivateKey: 'b7e151628aed2a6abf7158809cf4f3c762e7160f38b4da56a784d9045190cfef'
        };

        // Safe hex decode function
        function safeHexDecode(hexString, context = '') {
            try {
                if (!hexString || typeof hexString !== 'string') {
                    throw new Error('Invalid hex string: null or not a string');
                }
                
                // Remove any whitespace
                hexString = hexString.trim();
                
                if (hexString.length === 0) {
                    throw new Error('Invalid hex string: empty');
                }
                
                if (hexString.length % 2 !== 0) {
                    throw new Error(`Invalid hex string: odd length (${hexString.length})`);
                }
                
                if (!/^[0-9a-fA-F]+$/.test(hexString)) {
                    throw new Error('Invalid hex string: contains non-hex characters');
                }
                
                const matches = hexString.match(/.{1,2}/g);
                if (!matches) {
                    throw new Error('Failed to parse hex string');
                }
                
                return new Uint8Array(matches.map(byte => parseInt(byte, 16)));
            } catch (e) {
                const errorMsg = context ? `Hex decode error in ${context}: ${e.message}` : `Hex decode error: ${e.message}`;
                log(errorMsg, 'error');
                throw new Error(errorMsg);
            }
        }
        
        // Logging system
        function log(message, type = 'info') {
            const timestamp = new Date();
            const logEntry = {
                timestamp: timestamp.toISOString(),
                time: timestamp.toLocaleTimeString(),
                type: type,
                message: message
            };
            
            systemLogs.push(logEntry);
            
            const logContainer = document.getElementById('systemLog');
            const entry = document.createElement('div');
            entry.className = 'log-entry';
            entry.innerHTML = `<span class="log-time">[${logEntry.time}]</span> <span class="log-${type}">${message}</span>`;
            logContainer.appendChild(entry);
            logContainer.scrollTop = logContainer.scrollHeight;
        }


        // Network status
        function updateNetworkStatus(status, text) {
            const indicator = document.querySelector('.status-indicator');
            const statusText = document.getElementById('statusText');
            
            indicator.className = 'status-indicator';
            switch(status) {
                case 'online':
                    indicator.classList.add('status-online');
                    break;
                case 'offline':
                    indicator.classList.add('status-offline');
                    break;
                case 'connecting':
                    indicator.classList.add('status-connecting');
                    break;
            }
            statusText.textContent = text;
        }

        // Generate random CID (8 characters)
        function generateRandomCID() {
            const chars = 'abcdefghijklmnopqrstuvwxyz0123456789';
            let result = '';
            for (let i = 0; i < 8; i++) {
                result += chars.charAt(Math.floor(Math.random() * chars.length));
            }
            return result;
        }

        // Generate safe filename with CID
        function generateSafeFilename(originalName, cid) {
            const ext = '.kaspa';
            const maxLength = 240; // 安全マージン
            
            // 1. 通常パターン
            let filename = `${originalName}.${cid}${ext}`;
            
            // 2. 長すぎる場合は元ファイル名を短縮
            if (filename.length > maxLength) {
                const availableLength = maxLength - cid.length - ext.length - 2;
                const truncated = originalName.substring(0, availableLength);
                filename = `${truncated}..${cid}${ext}`;
            }
            
            // 3. それでも長い場合はCIDのみ
            if (filename.length > maxLength) {
                filename = `file.${cid}${ext}`;
            }
            
            return filename;
        }

        // Simple toast notification
        function showToast(message, type = 'info') {
            // For now, just log it. Can be enhanced with visual toast later
            log(message, type);
        }
        
        // Fetch with timeout and retry
        async function fetchWithTimeout(url, options = {}, timeout = 10000, retries = 3) {
            for (let attempt = 1; attempt <= retries; attempt++) {
                try {
                    const controller = new AbortController();
                    const timeoutId = setTimeout(() => controller.abort(), timeout);
                    
                    const response = await fetch(url, {
                        ...options,
                        signal: controller.signal
                    });
                    
                    clearTimeout(timeoutId);
                    return response;
                    
                } catch (error) {
                    if (error.name === 'AbortError') {
                        log(`タイムアウト (${timeout}ms): ${url}`, 'warning');
                    } else {
                        log(`ネットワークエラー: ${error.message}`, 'warning');
                    }
                    
                    if (attempt < retries) {
                        const waitTime = attempt * 1000; // 1s, 2s, 3s
                        log(`${waitTime/1000}秒後にリトライ (${attempt}/${retries})...`, 'info');
                        await new Promise(resolve => setTimeout(resolve, waitTime));
                    } else {
                        throw error;
                    }
                }
            }
        }

        // Tab switching
        window.switchTab = function(tab) {
            document.querySelectorAll('.tab-btn').forEach(btn => btn.classList.remove('active'));
            document.querySelectorAll('.tab-content').forEach(content => content.classList.remove('active'));
            
            const tabIndex = ['upload', 'download', 'history', 'settings'].indexOf(tab);
            document.querySelectorAll('.tab-btn')[tabIndex].classList.add('active');
            document.getElementById(`${tab}-tab`).classList.add('active');
            
            // Update history tab when switching to it
            if (tab === 'history' && window.historyManager) {
                window.historyManager.updateHistoryUI();
            }
        };

        // Filter out trash and system files
        function shouldSkipFile(fileName, filePath = '') {
            // === iOS/iPadOS patterns ===
            if (fileName.startsWith('._')) return true;
            
            const iosHiddenDirs = [
                '.Trashes', '.TemporaryItems', '.fseventsd',
                '.Spotlight-V100', '.DocumentRevisions-V100'
            ];
            if (iosHiddenDirs.includes(fileName)) return true;
            
            // Safari temporary download files
            if (fileName.endsWith('.download') && fileName.length > 9) return true;
            
            // Recently Deleted folders
            if (filePath.includes('Recently Deleted') || 
                filePath.includes('最近削除した項目')) return true;
            
            // === Android patterns ===
            if (fileName.startsWith('.trashed-')) return true;
            if (fileName.startsWith('.trash')) return true;
            if (fileName === '.FilesByGoogleTrash') return true;
            if (fileName === '.thumbnails') return true;
            
            // === Windows patterns ===
            if (/^\$RECYCLE\.BIN$/i.test(fileName)) return true;
            if (/^RECYCLER$/i.test(fileName)) return true;
            if (/^\$[IR][A-Z0-9]{6,7}\./i.test(fileName)) return true;
            
            // === macOS patterns ===
            if (fileName === '.Trash') return true;
            if (fileName === '.DS_Store') return true;
            if (fileName === '.AppleDouble') return true;
            if (fileName === '.LSOverride') return true;
            if (fileName === '__MACOSX') return true;
            
            // === Linux patterns ===
            if (fileName.endsWith('.trashinfo')) return true;
            if (/^\.Trash-\d+$/.test(fileName)) return true;
            if (filePath.includes('.local/share/Trash')) return true;
            
            // === Common system files ===
            const systemFiles = [
                'Thumbs.db', 'desktop.ini', 'System Volume Information',
                'hiberfil.sys', 'pagefile.sys', '.gitignore', '.gitkeep'
            ];
            if (systemFiles.includes(fileName)) return true;
            
            // === Temporary files ===
            if (fileName.startsWith('~$')) return true;
            if (fileName.endsWith('.tmp')) return true;
            if (fileName.endsWith('.temp')) return true;
            if (fileName.endsWith('.cache')) return true;
            if (fileName === 'Cache.db') return true;
            
            return false;
        }

        // Setup workspace directory for File System Access API
        async function setupWorkspace() {
            try {
                const dirHandle = await window.showDirectoryPicker({
                    mode: 'readwrite',
                    startIn: 'downloads'
                });
                
                window.workspaceHandle = dirHandle;
                log(`作業フォルダを設定: ${dirHandle.name}`, 'success');
                
                // Scan for .kprogress files
                progressFileMap.clear();
                let progressCount = 0;
                let skippedCount = 0;
                
                try {
                    for await (const entry of dirHandle.values()) {
                        if (entry.kind === 'file' && entry.name.endsWith('.kprogress')) {
                            // Skip trash/system files
                            if (shouldSkipFile(entry.name)) {
                                skippedCount++;
                                log(`スキップ: ${entry.name}`, 'debug');
                                continue;
                            }
                            
                            // Extract base filename and CID from filename
                            const match = entry.name.match(/^(.+?)\.([a-z0-9]{8})\.kprogress$/);
                            if (match) {
                                const baseFilename = match[1];
                                const cid = match[2];
                                progressFileMap.set(baseFilename, {
                                    cid: cid,
                                    fileHandle: entry,
                                    progressFilename: entry.name
                                });
                                progressCount++;
                                log(`進捗ファイル検出: ${entry.name}`, 'info');
                            }
                        }
                    }
                    
                    if (progressCount > 0) {
                        log(`${progressCount}個の進捗ファイルを検出しました`, 'success');
                        showToast(`レジューム可能: ${progressCount}個のファイル`, 'info');
                    }
                    
                    if (skippedCount > 0) {
                        log(`${skippedCount}個のゴミ箱/システムファイルをスキップしました`, 'debug');
                    }
                } catch (err) {
                    log('進捗ファイルスキャンエラー: ' + err.message, 'warning');
                }
                
                // Check for existing progress file (legacy support)
                try {
                    const fileHandle = await dirHandle.getFileHandle('kaspa-upload-progress.json');
                    const file = await fileHandle.getFile();
                    const content = await file.text();
                    const progress = JSON.parse(content);
                    
                    if (progress && progress.version === '2.0' && 
                        progress.metadata.completedChunks < progress.metadata.totalChunks) {
                        
                        const useExisting = confirm(
                            '作業フォルダに未完了のアップロードが見つかりました。\n\n' +
                            `ファイル: ${progress.fileInfo.name}\n` +
                            `進捗: ${progress.metadata.completedChunks}/${progress.metadata.totalChunks} チャンク\n\n` +
                            'これを続行しますか？'
                        );
                        
                        if (useExisting) {
                            handleProgressLoad(progress);
                        }
                    }
                } catch (err) {
                    // No existing progress file
                }
                
                // Load history if historyManager is initialized
                if (window.historyManager && window.historyManager.encryptionKey) {
                    await window.historyManager.loadFromFile();
                }
                
                // Update UI to show workspace status
                showWorkspaceStatus();
                return true;
                
            } catch (err) {
                if (err.name !== 'AbortError') {
                    log(`作業フォルダ設定エラー: ${err.message}`, 'error');
                }
                return false;
            }
        }
        
        function showWorkspaceStatus() {
            const statusDiv = document.getElementById('workspaceStatus');
            if (!statusDiv) {
                const div = document.createElement('div');
                div.id = 'workspaceStatus';
                div.style.cssText = 'background: #16213e; border: 1px solid #e94560; padding: 10px; margin: 10px 0; border-radius: 5px;';
                const container = document.querySelector('.container');
                if (container) {
                    container.insertBefore(div, container.firstChild);
                }
            }
            
            const status = document.getElementById('workspaceStatus');
            if (status) {
                if (window.workspaceHandle) {
                    status.innerHTML = `
                        <p style="margin: 0; color: #49EACB;">
                            ✓ 作業フォルダ: ${window.workspaceHandle.name}
                            <button onclick="setupWorkspace()" style="margin-left: 10px; padding: 5px 10px; font-size: 12px;">変更</button>
                        </p>
                    `;
                } else {
                    status.innerHTML = `
                        <p style="margin: 0; color: #ffcc66;">
                            作業フォルダ: 未設定 (ブラウザ内保存のみ)
                            <button onclick="setupWorkspace()" style="margin-left: 10px; padding: 5px 10px; font-size: 12px;">設定</button>
                        </p>
                    `;
                }
            }
        }
        
        function loadProgressFromLocalStorage() {
            try {
                const data = localStorage.getItem('kaspa-upload-progress');
                if (data) {
                    return JSON.parse(data);
                }
            } catch (err) {
                // Ignore errors
            }
            return null;
        }
        
        // Progress file handling
        window.loadProgressFile = async function() {
            // Check workspace first
            if (window.workspaceHandle) {
                try {
                    const fileHandle = await window.workspaceHandle.getFileHandle('kaspa-upload-progress.json');
                    const file = await fileHandle.getFile();
                    const content = await file.text();
                    const progress = JSON.parse(content);
                    
                    if (progress && progress.version === '2.0') {
                        handleProgressLoad(progress);
                        return;
                    }
                } catch (err) {
                    // File doesn't exist in workspace
                }
            }
            
            // Try localStorage
            const progress = loadProgressFromLocalStorage();
            if (progress) {
                const metadata = localStorage.getItem('kaspa-upload-metadata');
                let metaInfo = {};
                try {
                    metaInfo = JSON.parse(metadata) || {};
                } catch (err) {}
                
                const useLocal = confirm(
                    '保存された進捗が見つかりました。\n\n' +
                    `ファイル: ${metaInfo.fileName || '不明'}\n` +
                    `進捗: ${metaInfo.completedChunks || '?'}/${metaInfo.totalChunks || '?'} チャンク\n` +
                    `最終更新: ${metaInfo.lastUpdate ? new Date(metaInfo.lastUpdate).toLocaleString() : '不明'}\n\n` +
                    'これを使用しますか？\n\n' +
                    '「キャンセル」を選択するとファイルから読み込みます。'
                );
                
                if (useLocal) {
                    handleProgressLoad(progress);
                    return;
                }
            }
            
            // Load from file as last resort
            document.getElementById('progressFileInput').click();
        };

        window.handleProgressFileSelect = async function(event) {
            const file = event.target.files[0];
            if (!file || !file.name.endsWith('.kprogress')) {
                log('有効な進捗ファイル（.kprogress）を選択してください', 'error');
                return;
            }
            
            try {
                const content = await file.text();
                const progress = JSON.parse(content);
                
                // Extract CID from filename if available
                const match = file.name.match(/\.([a-z0-9]{8})\.kprogress$/);
                if (match && match[1]) {
                    window.currentFileCID = match[1];
                    log(`進捗ファイルからCIDを取得: ${match[1]}`, 'info');
                }
                
                handleProgressLoad(progress);
            } catch (error) {
                log(`進捗ファイル読み込みエラー: ${error.message}`, 'error');
            }
        };
        
        // Handle loaded progress
        function handleProgressLoad(progress) {
            try {
                
                // Validate progress format
                if (!progress.version || !progress.fileInfo || !progress.chunks) {
                    throw new Error('無効な進捗ファイル形式');
                }
                
                // Show resume info
                document.getElementById('resumeInfo').style.display = 'block';
                document.getElementById('resumeDetails').innerHTML = `
                    <p><strong>ファイル:</strong> ${progress.fileInfo.name}</p>
                    <p><strong>サイズ:</strong> ${(progress.fileInfo.size / 1024 / 1024).toFixed(2)} MB</p>
                    <p><strong>進捗:</strong> ${progress.metadata.completedChunks}/${progress.metadata.totalChunks} チャンク (${(progress.metadata.completedChunks / progress.metadata.totalChunks * 100).toFixed(1)}%)</p>
                    <p><strong>最終更新:</strong> ${new Date(progress.metadata.lastUpdateAt).toLocaleString()}</p>
                    <p class="warning">⚠️ 同じファイルを選択してアップロードを続行してください</p>
                `;
                
                // Store progress for later use
                window.pendingProgress = progress;
                log('進捗を読み込みました。同じファイルを選択してください。', 'info');
                
                // Show export button if no workspace
                if (!window.workspaceHandle) {
                    const resumeDiv = document.getElementById('resumeInfo');
                    if (resumeDiv && !document.getElementById('exportProgressBtn')) {
                        const exportBtn = document.createElement('button');
                        exportBtn.id = 'exportProgressBtn';
                        exportBtn.textContent = '進捗ファイルをエクスポート';
                        exportBtn.style.marginTop = '10px';
                        exportBtn.onclick = () => {
                            if (window.pendingProgress) {
                                const progressData = JSON.stringify(window.pendingProgress, null, 2);
                                const blob = new Blob([progressData], { type: 'application/json' });
                                const url = URL.createObjectURL(blob);
                                const a = document.createElement('a');
                                a.href = url;
                                a.download = 'kaspa-upload-progress.json';
                                a.click();
                                URL.revokeObjectURL(url);
                                log('進捗ファイルをエクスポートしました', 'success');
                            }
                        };
                        resumeDiv.appendChild(exportBtn);
                    }
                }
                
            } catch (error) {
                log(`進捗読み込みエラー: ${error.message}`, 'error');
            }
        }

        window.cancelResume = function() {
            window.pendingProgress = null;
            document.getElementById('resumeInfo').style.display = 'none';
            log('レジュームをキャンセルしました', 'info');
        };

        // System initialization
        window.initializeSystem = async function() {
            try {
                log('システム初期化を開始...');
                updateNetworkStatus('connecting', '初期化中...');
                
                // Import WASM SDK
                kaspa = await import('./kaspa-core.js');
                log('kaspa-core.jsをインポートしました');
                
                // Initialize WASM binary
                await kaspa.default('./kaspa-core_bg.wasm');
                log('WASMバイナリを初期化しました');
                
                // Verify functions
                const requiredFunctions = ['RpcClient', 'Resolver', 'createTransactions', 
                    'PrivateKey', 'addressFromScriptPublicKey', 'Address'];
                for (const func of requiredFunctions) {
                    if (typeof kaspa[func] !== 'function') {
                        throw new Error(`必要な関数が見つかりません: ${func}`);
                    }
                }
                log('すべての必要な関数を確認しました', 'success');
                
                // Initialize wallet
                privateKey = new kaspa.PrivateKey(config.testPrivateKey);
                const publicKey = privateKey.toPublicKey();
                address = publicKey.toAddress(config.network);
                
                log(`ウォレットアドレス: ${address.toString()}`, 'success');
                
                // Create RPC client
                rpcClient = new kaspa.RpcClient({
                    resolver: new kaspa.Resolver(),
                    networkId: config.network
                });
                
                log('RPC接続を試行中...');
                await rpcClient.connect();
                
                // Test connection
                const info = await rpcClient.getServerInfo();
                log(`接続成功! サーバー: ${info.serverVersion}`, 'success');
                
                // Get balance
                const { entries } = await rpcClient.getUtxosByAddresses([address.toString()]);
                const balance = entries.reduce((sum, utxo) => sum + Number(utxo.amount), 0) / 1e8;
                log(`残高: ${balance} KAS`, 'info');
                
                // Update UI
                window.kaspa = kaspa;
                document.getElementById('initStatus').style.display = 'block';
                document.getElementById('initStatus').innerHTML = `
                    <p class="success">✅ システム初期化完了</p>
                    <p>アドレス: ${address.toString()}</p>
                    <p>残高: ${balance} KAS</p>
                `;
                document.getElementById('testBtn').disabled = false;
                document.getElementById('uploadBtn').disabled = false;
                
                // Initialize history manager
                if (window.historyManager) {
                    await window.historyManager.initialize(config.testPrivateKey);
                    window.historyManager.updateHistoryUI();
                }
                
                updateNetworkStatus('online', 'オンライン');
                
            } catch (error) {
                log(`初期化エラー: ${error.message}`, 'error');
                updateNetworkStatus('offline', 'エラー');
            }
        };
        
        // Initialize or reinitialize RPC client
        async function initializeRpcClient() {
            try {
                log('RPCクライアントを初期化中...');
                
                // Close existing connection if any
                if (rpcClient) {
                    try {
                        await rpcClient.disconnect();
                    } catch (err) {
                        // Ignore disconnect errors
                    }
                }
                
                // Create new RPC client
                rpcClient = new kaspa.RpcClient({
                    resolver: new kaspa.Resolver(),
                    networkId: config.network
                });
                
                await rpcClient.connect();
                
                // Test connection
                const info = await rpcClient.getServerInfo();
                log(`RPC再接続成功! サーバー: ${info.serverVersion}`, 'success');
                
                updateNetworkStatus('online', 'オンライン');
                return true;
                
            } catch (error) {
                log(`RPC初期化エラー: ${error.message}`, 'error');
                updateNetworkStatus('offline', 'エラー');
                return false;
            }
        }

        // Connection test
        window.testConnection = async function() {
            try {
                log('接続テストを実行中...');
                const startTime = Date.now();
                
                // Test RPC
                const info = await rpcClient.getServerInfo();
                const rpcTime = Date.now() - startTime;
                log(`RPC応答時間: ${rpcTime}ms`, 'success');
                
                // Test Explorer API
                const apiStart = Date.now();
                const response = await fetchWithTimeout('https://api-tn10.kaspa.org/info/health', {}, 5000, 1); // 5s timeout, 1 retry for health check
                const apiTime = Date.now() - apiStart;
                log(`Explorer API応答時間: ${apiTime}ms`, 'success');
                
                alert(`接続テスト成功!\nRPC: ${rpcTime}ms\nAPI: ${apiTime}ms`);
                
            } catch (error) {
                log(`接続テストエラー: ${error.message}`, 'error');
            }
        };

        // File handling
        window.handleFileSelect = async function(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            currentFile = file;
            log(`ファイル選択: ${file.name} (${(file.size/1024).toFixed(1)}KB)`);
            
            // Auto-detect progress file from workspace
            if (!window.pendingProgress && progressFileMap.has(file.name)) {
                const progressInfo = progressFileMap.get(file.name);
                log(`進捗ファイルを自動検出: ${progressInfo.progressFilename}`, 'info');
                
                try {
                    // Load the progress file
                    const progressFile = await progressInfo.fileHandle.getFile();
                    const content = await progressFile.text();
                    const progress = JSON.parse(content);
                    
                    // Verify CID matches (calculate from first chunk)
                    const chunkSize = parseInt(document.getElementById('chunkSize').value) * 1024;
                    const actualChunkSize = calculateSafePayloadSize(chunkSize);
                    const firstChunkEnd = Math.min(actualChunkSize, file.size);
                    const firstChunkBlob = file.slice(0, firstChunkEnd);
                    const firstChunkArrayBuffer = await firstChunkBlob.arrayBuffer();
                    const firstChunkData = new Uint8Array(firstChunkArrayBuffer);
                    const firstChunkHash = await sha256(firstChunkData);
                    const calculatedCID = firstChunkHash.substring(0, 8);
                    
                    if (calculatedCID === progressInfo.cid) {
                        log(`CID検証成功: ${calculatedCID}`, 'success');
                        window.pendingProgress = progress;
                        window.currentFileCID = progressInfo.cid;
                        
                        // Show auto-resume notification
                        // 完了チェック
                        if (progress.metadata.completedChunks >= progress.metadata.totalChunks) {
                            log(`完了済みファイルを検出: ${file.name}`, 'info');
                            // TODO: 履歴に移動して.kprogress削除
                            return;
                        }
                        
                        const resumeConfirm = confirm(
                            `進捗ファイルを自動検出しました！\n\n` +
                            `ファイル: ${file.name}\n` +
                            `進捗: ${progress.metadata.completedChunks}/${progress.metadata.totalChunks} チャンク\n` +
                            `CID: ${progressInfo.cid}\n\n` +
                            `レジュームしますか？`
                        );
                        
                        if (!resumeConfirm) {
                            window.pendingProgress = null;
                            log('自動レジュームをキャンセルしました', 'info');
                        }
                    } else {
                        log(`CID不一致: 期待=${progressInfo.cid}, 実際=${calculatedCID}`, 'warning');
                        log('異なるファイルの可能性があります', 'warning');
                    }
                } catch (error) {
                    log(`進捗ファイル自動読み込みエラー: ${error.message}`, 'error');
                }
            }
            
            // Check if we have pending progress for this file
            if (window.pendingProgress) {
                const chunkSize = parseInt(document.getElementById('chunkSize').value) * 1024;
                // Use CID from progress if available
                const cid = window.currentFileCID || window.pendingProgress.cid || null;
                progressManager = new ProgressManager(file, chunkSize, cid, 'upload');
                
                if (progressManager.validateProgress(window.pendingProgress)) {
                    // Initialize with existing progress
                    await progressManager.initialize(window.pendingProgress);
                    
                    // Update UI to show resume status
                    const stats = progressManager.getStats();
                    const label = document.querySelector('.file-input-label');
                    label.innerHTML = `
                        <strong>${file.name}</strong><br>
                        ${(file.size/1024/1024).toFixed(2)}MB<br>
                        <span class="success">レジューム: ${stats.percentage}% 完了</span>
                    `;
                    
                    log(`レジューム準備完了: ${stats.completed}/${stats.total} チャンク完了`, 'success');
                    
                    // Clear pending progress
                    window.pendingProgress = null;
                    document.getElementById('resumeInfo').style.display = 'none';
                } else {
                    log('進捗ファイルが選択されたファイルと一致しません', 'error');
                    progressManager = null;
                }
            } else {
                // Update UI for new upload
                const label = document.querySelector('.file-input-label');
                label.innerHTML = `
                    <strong>${file.name}</strong><br>
                    ${(file.size/1024/1024).toFixed(2)}MB
                `;
            }
        };

        // Compression logic
        const COMPRESS_SKIP = new Set(['jpg','jpeg','png','gif','webp','mp4','avi','mov','mp3','wav','zip','rar','pdf']);
        
        function shouldCompress(filename) {
            const ext = filename.split('.').pop()?.toLowerCase() || '';
            return !COMPRESS_SKIP.has(ext);
        }

        // LZ compression
        function lzCompress(data) {
            const result = [];
            let i = 0;
            while (i < data.length) {
                let bestLen = 0, bestOff = 0;
                const start = Math.max(0, i - 255);
                for (let j = start; j < i; j++) {
                    let len = 0;
                    while (i + len < data.length && data[j + len] === data[i + len] && len < 255) len++;
                    if (len > bestLen) {
                        bestLen = len;
                        bestOff = i - j;
                    }
                }
                if (bestLen > 3) {
                    result.push(255, bestOff, bestLen);
                    i += bestLen;
                } else {
                    result.push(data[i]);
                    i++;
                }
            }
            return new Uint8Array(result);
        }

        function lzDecompress(data) {
            const result = [];
            let i = 0;
            while (i < data.length) {
                if (data[i] === 255 && i + 2 < data.length) {
                    const off = data[i + 1];
                    const len = data[i + 2];
                    const start = result.length - off;
                    for (let j = 0; j < len; j++) {
                        result.push(result[start + j]);
                    }
                    i += 3;
                } else {
                    result.push(data[i]);
                    i++;
                }
            }
            return new Uint8Array(result);
        }

        // Encryption
        async function deriveKey(password, salt) {
            const encoder = new TextEncoder();
            const keyMaterial = await crypto.subtle.importKey(
                'raw',
                encoder.encode(password),
                'PBKDF2',
                false,
                ['deriveKey']
            );
            
            return crypto.subtle.deriveKey(
                {
                    name: 'PBKDF2',
                    salt: salt,
                    iterations: 10000,
                    hash: 'SHA-256'
                },
                keyMaterial,
                { name: 'AES-GCM', length: 256 },
                false,
                ['encrypt', 'decrypt']
            );
        }

        async function encryptChunk(data, key, chunkIndex) {
            const iv = new Uint8Array(12);
            
            // Special handling for meta-tx (chunkIndex = -1)
            if (chunkIndex === -1) {
                // Use a special pattern for meta-tx
                iv[0] = 0xFF;
                iv[1] = 0xFF;
                for (let i = 2; i < 12; i++) {
                    iv[i] = 0xFF - i;
                }
            } else {
                iv[0] = (chunkIndex >> 8) & 0xFF;
                iv[1] = chunkIndex & 0xFF;
                for (let i = 2; i < 12; i++) {
                    iv[i] = i * 17;
                }
            }
            
            const encrypted = await crypto.subtle.encrypt(
                { name: 'AES-GCM', iv: iv },
                key,
                data
            );
            
            return new Uint8Array(encrypted);
        }

        async function decryptChunk(data, key, chunkIndex) {
            const iv = new Uint8Array(12);
            
            // Special handling for meta-tx (chunkIndex = -1)
            if (chunkIndex === -1) {
                // Use a special pattern for meta-tx
                iv[0] = 0xFF;
                iv[1] = 0xFF;
                for (let i = 2; i < 12; i++) {
                    iv[i] = 0xFF - i;
                }
            } else {
                iv[0] = (chunkIndex >> 8) & 0xFF;
                iv[1] = chunkIndex & 0xFF;
                for (let i = 2; i < 12; i++) {
                    iv[i] = i * 17;
                }
            }
            
            const decrypted = await crypto.subtle.decrypt(
                { name: 'AES-GCM', iv: iv },
                key,
                data
            );
            
            return new Uint8Array(decrypted);
        }

        // Base64
        function toBase64(data) {
            return btoa(String.fromCharCode(...data));
        }

        function fromBase64(str) {
            return new Uint8Array(atob(str).split('').map(c => c.charCodeAt(0)));
        }

        // SHA256
        async function sha256(data) {
            const hash = await crypto.subtle.digest('SHA-256', data);
            return Array.from(new Uint8Array(hash))
                .map(b => b.toString(16).padStart(2, '0'))
                .join('');
        }

        // Calculate safe payload size based on storage mass limit
        function calculateSafePayloadSize(rawChunkSize) {
            // Storage mass limit is 100,000
            // After compression, encryption, and Base64 encoding:
            // - Base64 expands by ~33%
            // - Encryption adds ~16 bytes
            // - UTF-8 encoding of Base64 string
            // Safe limit is around 12KB for raw data
            return Math.min(rawChunkSize, 12288); // 12KB max
        }
        
        // Check if transaction exists on blockchain
        async function verifyTransactionExists(txid, blockId = null) {
            try {
                // First try with blockId if available
                if (blockId) {
                    try {
                        const blockResponse = await rpcClient.getBlock({
                            hash: blockId,
                            includeTransactions: true
                        });
                        
                        const block = blockResponse?.block?.block || blockResponse?.block;
                        if (block && block.transactions) {
                            for (const tx of block.transactions) {
                                const txId = tx.verboseData?.transactionId || tx.id || tx.transactionId;
                                if (txId === txid) {
                                    log(`トランザクション確認: ${txid.substring(0, 16)}...`, 'success');
                                    return true;
                                }
                            }
                        }
                    } catch (err) {
                        log(`ブロック確認エラー: ${err.message}`, 'warning');
                    }
                }
                
                // Fallback to Explorer API
                const apiUrl = `https://api-tn10.kaspa.org/transactions/${txid}`;
                const response = await fetchWithTimeout(apiUrl, {}, 10000, 2); // 10s timeout, 2 retries
                if (response.ok) {
                    log(`トランザクション確認 (API): ${txid.substring(0, 16)}...`, 'success');
                    return true;
                }
                
                return false;
            } catch (error) {
                log(`トランザクション確認エラー: ${error.message}`, 'error');
                return false;
            }
        }
        
        // Verify progress chunks still exist on blockchain
        async function verifyProgressChunks(progress) {
            if (!progress.chunks || progress.chunks.length === 0) {
                return true; // No chunks to verify
            }
            
            log(`既存チャンクの検証を開始: ${progress.chunks.length}個`, 'info');
            const verifiedChunks = [];
            let failedCount = 0;
            
            // Check a sample of chunks (first, last, and some random ones)
            const indicesToCheck = [0, progress.chunks.length - 1];
            if (progress.chunks.length > 10) {
                // Add 3 random indices for larger files
                for (let i = 0; i < 3; i++) {
                    const randomIndex = Math.floor(Math.random() * progress.chunks.length);
                    if (!indicesToCheck.includes(randomIndex)) {
                        indicesToCheck.push(randomIndex);
                    }
                }
            } else {
                // Check all chunks for smaller files
                for (let i = 1; i < progress.chunks.length - 1; i++) {
                    indicesToCheck.push(i);
                }
            }
            
            for (const index of indicesToCheck.sort((a, b) => a - b)) {
                const chunk = progress.chunks[index];
                if (chunk && chunk.txid) {
                    const exists = await verifyTransactionExists(chunk.txid, chunk.blockId);
                    if (exists) {
                        verifiedChunks.push(index);
                    } else {
                        failedCount++;
                        log(`チャンク ${chunk.index + 1} が見つかりません: ${chunk.txid.substring(0, 16)}...`, 'warning');
                    }
                }
            }
            
            if (failedCount > 0) {
                log(`警告: ${failedCount}個のチャンクが確認できませんでした`, 'warning');
                const continueUpload = confirm(
                    `一部のチャンクがブロックチェーン上で確認できません。\n` +
                    `確認済み: ${verifiedChunks.length}個\n` +
                    `未確認: ${failedCount}個\n\n` +
                    `続行しますか？（未確認チャンクは再アップロードされます）`
                );
                return continueUpload;
            }
            
            log(`チャンク検証完了: すべて確認済み`, 'success');
            return true;
        }
        
        // Process and upload file
        window.processAndUpload = async function() {
            if (!currentFile) {
                log('ファイルが選択されていません', 'error');
                return;
            }
            
            const password = document.getElementById('uploadPassword').value;
            if (password.length < 8) {
                log('パスワードは8文字以上必要です', 'error');
                return;
            }
            
            if (!rpcClient) {
                log('先にシステムを初期化してください', 'error');
                return;
            }
            
            currentPassword = password;
            processedChunks = [];
            
            document.getElementById('uploadBtn').disabled = true;
            document.getElementById('uploadProgress').style.display = 'block';
            
            try {
                // v3.6.3 fix: Set upload flag
                isUploadingFile = true;
                
                log(`処理開始: ${currentFile.name}`);
                log(`ファイルサイズ: ${(currentFile.size / 1024 / 1024).toFixed(2)} MB`);
                
                // Generate CID early for progress manager
                let fileCID = '';
                const useRandomCid = document.getElementById('useRandomCid').checked;
                const chunkSize = parseInt(document.getElementById('chunkSize').value) * 1024;
                log(`チャンクサイズ設定: ${chunkSize / 1024} KB`);
                
                if (useRandomCid) {
                    fileCID = generateRandomCID();
                    log(`ランダムCID生成: ${fileCID}`, 'info');
                } else {
                    // Read first chunk to calculate CID
                    const actualChunkSize = calculateSafePayloadSize(chunkSize);
                    const firstChunkEnd = Math.min(actualChunkSize, currentFile.size);
                    const firstChunkBlob = currentFile.slice(0, firstChunkEnd);
                    const firstChunkArrayBuffer = await firstChunkBlob.arrayBuffer();
                    const firstChunkData = new Uint8Array(firstChunkArrayBuffer);
                    const firstChunkHash = await sha256(firstChunkData);
                    fileCID = firstChunkHash.substring(0, 8);
                    log(`決定論的CID生成: ${fileCID}`, 'info');
                }
                
                // Store CID for later use
                window.currentFileCID = fileCID;
                
                // Initialize or use existing progress manager
                if (!progressManager) {
                    log('新規ProgressManagerを作成中...');
                    progressManager = new ProgressManager(currentFile, chunkSize, fileCID, 'upload');
                    await progressManager.initialize();
                    log(`ProgressManager初期化完了 - 総チャンク数: ${progressManager.progress.metadata.totalChunks}`);
                } else {
                    log(`既存のProgressManagerを使用 - 完了済み: ${progressManager.progress.metadata.completedChunks}/${progressManager.progress.metadata.totalChunks}`);
                    
                    // Verify existing chunks on blockchain
                    const verified = await verifyProgressChunks(progressManager.progress);
                    if (!verified) {
                        log('チャンク検証に失敗したため、レジュームをキャンセルします', 'error');
                        progressManager = null;
                        return;
                    }
                }
                
                // Get file hash for the entire file (expensive for large files, consider chunked hashing)
                let fileHash;
                if (currentFile.size < 10 * 1024 * 1024) { // Only hash small files completely
                    log('小さなファイル - 全体をハッシュ化中...');
                    const data = new Uint8Array(await currentFile.arrayBuffer());
                    fileHash = await sha256(data);
                } else {
                    // For large files, hash first and last 1MB
                    log('大きなファイル - 最初と最後の1MBをハッシュ化中...');
                    const firstChunk = await currentFile.slice(0, 1024 * 1024).arrayBuffer();
                    const lastChunk = await currentFile.slice(-1024 * 1024).arrayBuffer();
                    const combined = new Uint8Array(firstChunk.byteLength + lastChunk.byteLength);
                    combined.set(new Uint8Array(firstChunk), 0);
                    combined.set(new Uint8Array(lastChunk), firstChunk.byteLength);
                    fileHash = await sha256(combined);
                }
                log(`ファイルハッシュ: ${fileHash}`);
                
                // Compression strategy
                const useCompression = shouldCompress(currentFile.name);
                log(`圧縮: ${useCompression ? '有効' : '無効'}`);
                
                // Generate salt
                const saltBase = fileHash + currentFile.name;
                const saltHash = await sha256(new TextEncoder().encode(saltBase));
                const salt = safeHexDecode(saltHash.substring(0, 32), 'salt generation');
                
                const key = await deriveKey(password, salt);
                
                // Update progress manager with encryption info
                progressManager.progress.encryption.salt = toBase64(salt);
                progressManager.progress.encryption.compressed = useCompression;
                
                // Get chunk size and apply safety limit
                const requestedChunkSize = parseInt(document.getElementById('chunkSize').value) * 1024;
                const actualChunkSize = calculateSafePayloadSize(requestedChunkSize);
                
                if (actualChunkSize < requestedChunkSize) {
                    log(`チャンクサイズを安全な値に調整: ${(actualChunkSize/1024).toFixed(1)}KB`, 'warning');
                }
                
                const totalChunks = progressManager.progress.metadata.totalChunks;
                log(`総チャンク数: ${totalChunks}`);
                
                // Initial UTXO fetch
                let currentUtxos = null;
                
                // Start WebSocket monitoring for transaction confirmations
                if (!wsMonitorActive) {
                    log('WebSocket監視を開始します...', 'info');
                    await startMonitoring();
                } else {
                    log('WebSocket監視は既に動作中です', 'info');
                    // log(`現在監視中のトランザクション数: ${monitoredTransactions.size}`, 'info');
                }
                
                
                // Process chunks with resume support
                const chunksList = document.getElementById('chunksList');
                chunksList.innerHTML = '';
                
                // Continue from next incomplete chunk
                let nextChunkIndex = progressManager.getNextChunkIndex();
                while (nextChunkIndex >= 0) {
                    // Get fresh UTXOs for each chunk
                    log(`チャンク ${nextChunkIndex + 1}/${totalChunks} の処理を開始...`);
                    const { entries } = await rpcClient.getUtxosByAddresses([address.toString()]);
                    if (!entries || entries.length === 0) {
                        throw new Error('利用可能なUTXOがありません');
                    }
                    
                    const i = nextChunkIndex;
                    log(`チャンク ${i + 1}: ${entries.length} UTXOs 利用可能`);
                    
                    // Read chunk from file
                    const start = i * actualChunkSize;
                    const end = Math.min(start + actualChunkSize, currentFile.size);
                    log(`ファイルから読み込み: オフセット ${start} - ${end} (${end - start} バイト)`);
                    
                    const chunkBlob = currentFile.slice(start, end);
                    const chunkArrayBuffer = await chunkBlob.arrayBuffer();
                    const chunk = new Uint8Array(chunkArrayBuffer);
                    log(`チャンクサイズ: ${chunk.length} バイト`);
                    
                    // Create chunk UI
                    const chunkDiv = document.createElement('div');
                    chunkDiv.className = 'chunk-item';
                    chunkDiv.innerHTML = `
                        <div>Chunk ${i + 1}/${totalChunks} (${(chunk.length/1024).toFixed(1)}KB)</div>
                        <div class="chunk-status pending" id="chunk-status-${i}">
                            <span>待機中</span>
                        </div>
                    `;
                    chunksList.appendChild(chunkDiv);
                    
                    // Process chunk
                    const compressed = useCompression ? lzCompress(chunk) : chunk;
                    const encrypted = await encryptChunk(compressed, key, i);
                    // No Base64 encoding - use raw binary
                    const payloadBytes = encrypted; // Direct binary payload
                    
                    // Update status
                    document.getElementById(`chunk-status-${i}`).innerHTML = '<span class="uploading">アップロード中...</span>';
                    
                    // Upload to blockchain with retry
                    let txid = null;
                    let blockId = null;
                    let retries = 0;
                    
                    while (retries < config.retryCount && !txid) {
                        try {
                            // Create transaction with raw binary payload
                            
                            // Check payload size before sending
                            if (payloadBytes.length > 24000) {
                                throw new Error(`Payload too large: ${payloadBytes.length} bytes (max 24000)`);
                            }
                            
                            log(`Chunk ${i + 1} payload size: ${payloadBytes.length} bytes`);

                            
                            // Format current UTXOs
                            const formattedUtxos = entries.map(utxo => ({
                                address: address.toString(),
                                outpoint: {
                                    transactionId: utxo.outpoint.transactionId,
                                    index: utxo.outpoint.index
                                },
                                scriptPublicKey: utxo.scriptPublicKey,
                                amount: BigInt(utxo.amount),
                                isCoinbase: utxo.isCoinbase || false,
                                blockDaaScore: BigInt(utxo.blockDaaScore)
                            }));
                            
                            const result = await kaspa.createTransactions({
                                entries: formattedUtxos,
                                outputs: [{
                                    address: address.toString(),
                                    amount: 100000000n // 1 KAS
                                }],
                                changeAddress: address.toString(),
                                priorityFee: 10000n,
                                networkId: config.network,
                                payload: payloadBytes
                            });
                            
                            // Sign and submit transaction
                            if (!result.transactions || result.transactions.length === 0) {
                                throw new Error('No transactions generated');
                            }
                            
                            const pendingTx = result.transactions[0];
                            
                            // Sign the transaction
                            log(`トランザクションに署名中...`);
                            await pendingTx.sign([privateKey]);
                            
                            // Submit to network
                            log(`ネットワークに送信中...`);
                            txid = await pendingTx.submit(rpcClient);
                            
                            log(`チャンク ${i + 1} TxID: ${txid.substring(0, 16)}...`, 'success');
                            
                            // Add to monitoring list
                            uploadingChunksCount++;
                            monitoredTransactions.set(txid, {
                                type: 'chunk',
                                chunkIndex: i,
                                timestamp: Date.now(),
                                blockId: null
                            });
                            log(`[DEBUG] WebSocket監視リストに追加: TxID: ${txid.substring(0, 16)}... (チャンク ${i + 1}/${totalChunks})`, 'debug');
                            
                            log(`トランザクション送信完了: ${txid.substring(0, 16)}...`);
                            
                            // Wait for transaction to be accepted
                            log(`トランザクションの確認待ち...`);
                            await new Promise(resolve => setTimeout(resolve, 2000));
                            
                            // Try WebSocket monitoring first
                            log(`トランザクション確認を待機中...`);
                            
                            // Wait for confirmation (WebSocket or RPC)
                            let waitTime = 0;
                            const maxWaitTime = 30000; // 30 seconds for RPC check
                            
                            while (!blockId && waitTime < maxWaitTime) {
                                // Check WebSocket monitor first
                                if (wsMonitorActive && monitoredTransactions && monitoredTransactions.has(txid)) {
                                    const monitorData = monitoredTransactions.get(txid);
                                    if (monitorData.blockId) {
                                        blockId = monitorData.blockId;
                                        log(`WebSocket経由でBlockID取得: ${blockId.substring(0, 16)}...`);
                                        // Remove from monitoring list
                                        monitoredTransactions.delete(txid);
                                        uploadingChunksCount--;
                                        log(`[DEBUG] WebSocket監視リストから削除: TxID: ${txid.substring(0, 16)}... (BlockID取得済み)`, 'debug');
                                        break;
                                    }
                                }
                                
                                // After 30 seconds, try RPC
                                if (waitTime >= 30000) {
                                    try {
                                        log('30秒経過 - RPCで確認を試みます...');
                                        const txInfo = await rpcClient.getTransaction({
                                            transactionId: txid,
                                            includeBlockInfo: true
                                        });
                                        
                                        if (txInfo && txInfo.blockHash) {
                                            blockId = txInfo.blockHash;
                                            log(`RPC経由でBlockID取得: ${blockId.substring(0, 16)}...`);
                                            // Remove from monitoring list if found via RPC
                                            if (monitoredTransactions.has(txid)) {
                                                monitoredTransactions.delete(txid);
                                                uploadingChunksCount--;
                                                log(`[DEBUG] WebSocket監視リストから削除: TxID: ${txid.substring(0, 16)}... (RPC経由でBlockID取得)`, 'debug');
                                            }
                                            break;
                                        }
                                    } catch (err) {
                                        // Transaction might not be confirmed yet
                                    }
                                }
                                
                                await new Promise(resolve => setTimeout(resolve, 500));
                                waitTime += 500;
                            }
                            
                            // Fallback to Explorer API
                            if (!blockId) {
                                if (wsMonitorActive && monitoredTransactions.has(txid)) {
                                    const elapsed = Date.now() - monitoredTransactions.get(txid).timestamp;
                                    log(`WebSocketで${elapsed/1000}秒間見つからず - Explorer APIを使用`);
                                } else {
                                    log(`RPC待機タイムアウト - Explorer APIを使用`);
                                }
                                const apiUrl = `https://api-tn10.kaspa.org/transactions/${txid}`;
                                const response = await fetchWithTimeout(apiUrl, {}, 15000, 3); // 15s timeout, 3 retries for important upload
                                if (response.ok) {
                                    const data = await response.json();
                                    blockId = data.block_hash?.[0] || data.accepting_block_hash;
                                    if (blockId) {
                                        log(`Explorer API経由でBlockID取得: ${blockId.substring(0, 16)}...`);
                                    }
                                }
                            }
                            
                            if (!blockId) {
                                throw new Error('BlockID取得失敗');
                            }
                            
                            // Update status
                            document.getElementById(`chunk-status-${i}`).innerHTML = '<span class="success">✅ 完了</span>';
                            log(`チャンク ${i + 1} アップロード完了`);
                            
                            // Get block time from monitored transactions
                            let chunkBlockTime = null;
                            if (monitoredTransactions.has(txid)) {
                                const txData = monitoredTransactions.get(txid);
                                if (txData.blockTime) {
                                    chunkBlockTime = txData.blockTime;
                                    log(`[DEBUG] チャンク ${i + 1} のブロック時刻を取得: ${chunkBlockTime.toISOString()}`, 'debug');
                                }
                            }
                            
                            // Store chunk info
                            processedChunks.push({
                                index: i,
                                txid: txid,
                                blockId: blockId,
                                blockTime: chunkBlockTime,
                                originalSize: chunk.length,
                                compressedSize: compressed.length,
                                payloadSize: payloadBytes.length,
                                uploadedAt: Date.now()
                            });
                            
                            // Update progress manager
                            log(`進捗情報を更新中...`);
                            await progressManager.markChunkComplete(i, txid, blockId, payloadBytes.length);
                            
                            break;
                            
                        } catch (error) {
                            retries++;
                            log(`チャンク ${i + 1} エラー (試行 ${retries}/${config.retryCount}): ${error.message || error}`, 'error');
                            console.error('詳細エラー:', error);
                            console.error('スタックトレース:', error.stack);
                            
                            if (retries >= config.retryCount) {
                                document.getElementById(`chunk-status-${i}`).innerHTML = '<span class="error">❌ 失敗</span>';
                                progressManager.markChunkFailed(i);
                                log(`チャンク ${i + 1} のアップロードが失敗 - 進捗を保存`);
                                await progressManager.saveProgress(); // Save progress on failure
                                throw error;
                            }
                            log(`2秒待機後にリトライ...`);
                            await new Promise(resolve => setTimeout(resolve, 2000));
                        }
                    }
                    
                    // Update progress
                    const stats = progressManager.getStats();
                    const progress = stats.percentage;
                    document.getElementById('uploadProgressBar').style.width = progress + '%';
                    document.getElementById('uploadProgressBar').textContent = progress + '%';
                    
                    // Get next chunk
                    nextChunkIndex = progressManager.getNextChunkIndex();
                }
                
                // Calculate cost
                const totalPayloadKB = processedChunks.reduce((sum, c) => sum + c.payloadSize, 0) / 1024;
                const totalCost = totalChunks * 0.00005 + totalPayloadKB * 0.00001;
                
                // Final progress save
                await progressManager.saveProgress();
                log('最終進捗を保存しました', 'success');
                
                // Prepare metadata
                kaspaMetadata = {
                    version: "2.0",
                    kaspa: {
                        network: config.network,
                        sdkVersion: "1.0.0"
                    },
                    file: {
                        name: currentFile.name,
                        size: currentFile.size,
                        mimeType: currentFile.type || 'application/octet-stream',
                        sha256: fileHash
                    },
                    encryption: {
                        algorithm: "AES-256-GCM",
                        pbkdf2: {
                            iterations: 10000,
                            salt: toBase64(salt)
                        }
                    },
                    compression: {
                        algorithm: useCompression ? "LZ77" : "none",
                        enabled: useCompression
                    },
                    chunks: processedChunks.map(c => ({
                        index: c.index,
                        txid: c.txid,
                        blockId: c.blockId,
                        originalSize: c.originalSize,
                        compressedSize: c.compressedSize,
                        payloadSize: c.payloadSize,
                        uploadedAt: c.uploadedAt
                    })),
                    metadata: {
                        createdAt: Date.now(),
                        totalChunks: totalChunks,
                        totalKAS: totalCost,
                        uploadedBy: address.toString()
                    }
                };
                
                // Save to history
                uploadHistory.push({
                    filename: currentFile.name,
                    timestamp: Date.now(),
                    metadata: kaspaMetadata
                });
                
                log(`アップロード完了! 総コスト: ${totalCost.toFixed(5)} KAS`, 'success');
                
                // Add to history
                if (window.historyManager) {
                    // Get block time from last chunk or meta-tx
                    // Get block time from the last chunk
                    let blockTime = null;
                    if (processedChunks.length > 0) {
                        const lastChunk = processedChunks[processedChunks.length - 1];
                        if (lastChunk.blockTime) {
                            blockTime = lastChunk.blockTime.toISOString();
                            log(`[DEBUG] 最後のチャンクのブロック時刻を取得: ${blockTime}`, 'debug');
                        }
                    }
                    
                    const uploadData = {
                        id: `upload_${Date.now()}`,
                        fileName: currentFile.name,
                        fileSize: currentFile.size,
                        fileSha256: fileHash,
                        uploadDate: new Date().toISOString(),
                        blockTime: blockTime, // Add blockchain time if available
                        chunks: totalChunks,
                        totalCost: totalCost,
                        metaTxId: null, // Will be set if meta-tx is used
                        metaTxBlockId: null, // Will be set if meta-tx is used
                        firstChunkTxId: processedChunks[0]?.txid || '',
                        cid: window.currentFileCID || '',
                        password: currentPassword || null,
                        metadata: kaspaMetadata,
                        chunkTxIds: processedChunks.map(c => c.txid),
                        chunkBlockIds: processedChunks.map(c => c.blockId),
                        chunkSize: config.chunkSize,
                        salt: kaspaMetadata.encryption?.pbkdf2?.salt || '',
                        compression: kaspaMetadata.compression,
                        network: config.network
                    };
                    log(`[DEBUG] 履歴データ生成完了 - ID: ${uploadData.id}`, 'debug');
                    await window.historyManager.addUpload(uploadData);
                    
                    // Delete .kprogress file if exists
                    if (progressManager && window.workspaceHandle) {
                        try {
                            await window.workspaceHandle.removeEntry(progressManager.progressFileName);
                            log('.kprogressファイルを削除しました', 'info');
                        } catch (err) {
                            // File might not exist
                        }
                    }
                }
                
                // Check if meta-tx option is enabled
                const useMetaTx = document.getElementById('useMetaTx').checked;
                if (useMetaTx) {
                    await createAndUploadMetaTx();
                } else {
                    // Auto-stop monitoring for non-meta-tx uploads
                    if (window.wsMonitorActive) {
                        log('アップロード完了 - WebSocket監視を自動停止します', 'info');
                        await stopMonitoring();
                    }
                    log('🎉 アップロードが完了しました！履歴タブで詳細を確認してください', 'success');
                    // Switch to History tab
                    switchTab('history');
                }
                
            } catch (error) {
                log(`アップロードエラー: ${error.message}`, 'error');
            } finally {
                // v3.6.3 fix: Clear upload flag
                isUploadingFile = false;
                document.getElementById('uploadBtn').disabled = false;
            }
        };

        // Generate .kaspa file - DEPRECATED: Now handled in History tab
        // Keeping for backward compatibility if needed
        /* window.generateKaspaFile = function() {
            if (!kaspaMetadata) {
                log('.kaspaファイル生成データがありません', 'error');
                return;
            }
            
            try {
                const includePassword = document.getElementById('includePassword').checked;
                const kaspaData = JSON.parse(JSON.stringify(kaspaMetadata));
                
                if (includePassword && currentPassword) {
                    kaspaData.auth = {
                        passwordIncluded: true,
                        password: currentPassword,
                        warning: "パスワードは平文で保存されています。信頼できる相手とのみ共有してください。"
                    };
                    log('⚠️ パスワードが.kaspaファイルに含まれています', 'warning');
                }
                
                const kaspaFileContent = JSON.stringify(kaspaData, null, 2);
                const blob = new Blob([kaspaFileContent], { type: 'application/octet-stream' });
                const url = URL.createObjectURL(blob);
                
                const a = document.createElement('a');
                a.href = url;
                // Use CID in filename if available
                const cid = window.currentFileCID || generateRandomCID();
                a.download = generateSafeFilename(currentFile.name, cid);
                a.click();
                
                URL.revokeObjectURL(url);
                
                const kaspaResultElement = document.getElementById('kaspaResult');
                if (kaspaResultElement) {
                    kaspaResultElement.innerHTML = `
                        <div class="metric-box">
                            <h4 class="success">✅ .kaspaファイル生成完了</h4>
                            <p>ファイル名: ${generateSafeFilename(currentFile.name, cid)}</p>
                            <p>サイズ: ${(kaspaFileContent.length/1024).toFixed(1)}KB</p>
                            ${includePassword ? '<p class="warning">⚠️ パスワードが含まれています</p>' : ''}
                        </div>
                    `;
                }
                
                log('.kaspaファイルをダウンロードしました', 'success');
                
            } catch (error) {
                log(`.kaspaファイル生成エラー: ${error.message}`, 'error');
            }
        }; */

        // Create and upload meta transaction
        window.createAndUploadMetaTx = async function() {
            try {
                log('メタトランザクション作成を開始します...', 'info');
                
                // Prepare meta-tx data (similar to .kaspa file but with version 2.1)
                const metaTxData = {
                    version: "2.1",
                    type: "kaspa-meta-tx",
                    kaspa: kaspaMetadata.kaspa,
                    file: kaspaMetadata.file,
                    encryption: kaspaMetadata.encryption,
                    compression: kaspaMetadata.compression,
                    chunks: kaspaMetadata.chunks,
                    metadata: kaspaMetadata.metadata
                };
                
                // Encrypt meta-tx data with the same password
                const metaDataString = JSON.stringify(metaTxData);
                const metaDataBytes = new TextEncoder().encode(metaDataString);
                
                // Use the same salt and key from file encryption
                const salt = fromBase64(kaspaMetadata.encryption.pbkdf2.salt);
                const key = await deriveKey(currentPassword, salt);
                
                // Encrypt with chunk index -1 to indicate meta-tx
                const encryptedMetaData = await encryptChunk(metaDataBytes, key, -1);
                
                // Prepend salt to encrypted data for self-contained decryption
                const metaPayload = new Uint8Array(salt.length + encryptedMetaData.length);
                metaPayload.set(salt, 0);
                metaPayload.set(encryptedMetaData, salt.length);
                
                log(`メタデータサイズ: ${metaDataBytes.length} bytes → 暗号化後: ${metaPayload.length} bytes (salt含む)`);
                
                // Upload meta-tx to blockchain
                const utxoResponse = await rpcClient.getUtxosByAddresses([address.toString()]);
                const entries = utxoResponse.entries || [];
                
                log(`${entries.length} UTXOs available for meta-tx`);
                
                const formattedUtxos = entries.map(utxo => {
                    try {
                        return {
                            address: address.toString(),
                            outpoint: {
                                transactionId: utxo.outpoint.transactionId,
                                index: utxo.outpoint.index
                            },
                            scriptPublicKey: utxo.scriptPublicKey,
                            amount: BigInt(utxo.amount),
                            isCoinbase: utxo.isCoinbase || false,
                            blockDaaScore: BigInt(utxo.blockDaaScore)
                        };
                    } catch (e) {
                        log(`UTXO formatting error: ${e.message}`, 'error');
                        console.error('UTXO:', utxo);
                        throw e;
                    }
                });
                
                log(`Creating meta-tx with ${formattedUtxos.length} UTXOs, payload size: ${metaPayload.length} bytes`);
                
                let result;
                try {
                    // Use same amount as regular chunks (1 KAS)
                    const amount = 100000000n; // 1 KAS
                    
                    result = await kaspa.createTransactions({
                        entries: formattedUtxos,
                        outputs: [{
                            address: address.toString(),
                            amount: amount
                        }],
                        changeAddress: address.toString(),
                        priorityFee: 10000n,
                        networkId: config.network,
                        payload: metaPayload
                    });
                } catch (e) {
                    log(`createTransactions error: ${e.message || e}`, 'error');
                    throw e;
                }
                
                if (!result) {
                    throw new Error('createTransactions returned null/undefined');
                }
                
                if (!result.transactions || result.transactions.length === 0) {
                    throw new Error('メタトランザクション生成失敗 - no transactions in result');
                }
                
                const pendingTx = result.transactions[0];
                await pendingTx.sign([privateKey]);
                const metaTxId = await pendingTx.submit(rpcClient);
                
                log(`メタトランザクションを送信しました: ${metaTxId}`, 'success');
                
                // Add to monitoring list
                uploadingMetaTx = true;
                monitoredTransactions.set(metaTxId, {
                    type: 'meta-tx',
                    timestamp: Date.now(),
                    blockId: null
                });
                log(`[DEBUG] WebSocket監視リストに追加: TxID: ${metaTxId.substring(0, 16)}... (メタトランザクション)`, 'debug');
                
                // Wait for BlockID from WebSocket monitor
                log(`メタトランザクションのBlockIDを待機中...`);
                let metaBlockId = null;
                let waitTime = 0;
                const maxWaitTime = 30000; // 30 seconds max
                
                while (!metaBlockId && waitTime < maxWaitTime) {
                    if (monitoredTransactions.has(metaTxId)) {
                        const monitorData = monitoredTransactions.get(metaTxId);
                        if (monitorData.blockId) {
                            metaBlockId = monitorData.blockId;
                            // Remove from monitoring list
                            monitoredTransactions.delete(metaTxId);
                            uploadingMetaTx = false;
                            log(`[DEBUG] WebSocket監視リストから削除: TxID: ${metaTxId.substring(0, 16)}... (メタTx BlockID取得済み)`, 'debug');
                            break;
                        }
                    }
                    await new Promise(resolve => setTimeout(resolve, 500));
                    waitTime += 500;
                }
                
                let metaTxReference = metaTxId;
                if (metaBlockId) {
                    log(`BlockID取得成功: ${metaBlockId}`, 'success');
                    metaTxReference = `${metaTxId}:${metaBlockId}`;
                } else {
                    log(`BlockID取得タイムアウト - メタTxIDのみで保存`, 'warning');
                }
                
                // Log meta-tx creation success
                log(`🎉 メタトランザクション作成完了！ ${metaBlockId ? 'TxID:BlockID' : 'TxID'}: ${metaTxReference}`, 'success');
                if (metaBlockId) {
                    log('✅ REST API不要で復元可能です', 'success');
                } else {
                    log('⚠️ BlockID取得に失敗しました。復元時にREST APIが必要です', 'warning');
                }
                
                // Add meta-tx to metadata for .kaspa file generation
                kaspaMetadata.metaTx = {
                    txid: metaTxId,
                    blockId: metaBlockId,
                    reference: metaTxReference,
                    createdAt: Date.now()
                };
                
                // Update history with metaTxId
                if (window.historyManager && window.currentFileCID) {
                    const history = window.historyManager.getHistory();
                    const latestUpload = history.find(h => h.cid === window.currentFileCID);
                    if (latestUpload) {
                        // 両方のプロパティを正しく設定
                        latestUpload.metaTxId = metaTxId;
                        latestUpload.metaTxBlockId = metaBlockId;
                        latestUpload.metaTxReference = metaTxReference; // 後方互換性のため
                        // Save updated history
                        localStorage.setItem(window.historyManager.dbName, JSON.stringify(history));
                        await window.historyManager.saveToFile();
                        log('[UploadHistoryManager] メタTxIDとBlockIDを履歴に追加しました', 'debug');
                    }
                }
                
                // Auto-stop WebSocket monitoring after meta-tx creation
                if (window.wsMonitorActive) {
                    log('メタトランザクション作成完了 - WebSocket監視を自動停止します', 'info');
                    await stopMonitoring();
                }
                
                // Switch to History tab
                log('履歴タブで詳細を確認してください', 'info');
                switchTab('history');
                
            } catch (error) {
                log(`メタトランザクション作成エラー: ${error.message || error}`, 'error');
                console.error('Meta-tx creation error:', error);
                
                // Try to log more details
                if (error.stack) {
                    console.error('Error stack:', error.stack);
                }
                
                // Error occurred - no fallback needed as .kaspa generation is in History tab
            }
        };

        // Load .kaspa file
        window.loadKaspaFile = async function(event) {
            log('=== loadKaspaFile 開始 ===', 'info');
            log(`event: ${event}`, 'info');
            log(`event.target: ${event?.target}`, 'info');
            log(`event.target.files: ${event?.target?.files}`, 'info');
            log(`files.length: ${event?.target?.files?.length || 0}`, 'info');
            
            const file = event?.target?.files?.[0];
            log(`file: ${file}`, 'info');
            
            if (file) {
                log(`file.name: ${file.name}`, 'info');
                log(`file.type: ${file.type}`, 'info');
                log(`file.size: ${file.size} bytes`, 'info');
                log(`endsWith('.kaspa'): ${file.name.endsWith('.kaspa')}`, 'info');
                log(`toLowerCase().endsWith('.kaspa'): ${file.name.toLowerCase().endsWith('.kaspa')}`, 'info');
            }
            
            if (!file || !file.name.endsWith('.kaspa')) {
                log('有効な.kaspaファイルを選択してください', 'error');
                log(`理由: file=${!!file}, name=${file?.name}, endsWith=${file?.name?.endsWith('.kaspa')}`, 'error');
                return;
            }
            
            try {
                log('ファイル内容を読み込み中...', 'info');
                const content = await file.text();
                log(`ファイル内容の長さ: ${content.length} 文字`, 'info');
                log(`最初の100文字: ${content.substring(0, 100)}...`, 'info');
                
                kaspaMetadata = JSON.parse(content);
                log('JSON parse成功', 'info');
                log(`kaspaMetadata.version: ${kaspaMetadata.version}`, 'info');
                log(`kaspaMetadata.chunks: ${kaspaMetadata.chunks?.length || 0} chunks`, 'info');
                
                if (!kaspaMetadata.version || !kaspaMetadata.chunks) {
                    throw new Error('無効な.kaspaファイル形式');
                }
                
                // v3.6.5 fix: Check for different metadata structures and cost fields
                const network = kaspaMetadata.kaspa?.network || kaspaMetadata.network || 'unknown';
                const createdAt = kaspaMetadata.metadata?.createdAt || kaspaMetadata.created || new Date().toISOString();
                const totalKAS = kaspaMetadata.metadata?.totalKAS || kaspaMetadata.recovery?.uploadCost || 0;
                
                document.getElementById('fileInfo').textContent = 
                    `ファイル: ${kaspaMetadata.file.name}\n` +
                    `サイズ: ${(kaspaMetadata.file.size/1024/1024).toFixed(2)}MB\n` +
                    `チャンク: ${kaspaMetadata.chunks.length}\n` +
                    `ネットワーク: ${network}\n` +
                    `作成日時: ${new Date(createdAt).toLocaleString()}\n` +
                    `コスト: ${totalKAS.toFixed(5)} KAS`;
                
                // Handle password
                const passwordSection = document.getElementById('passwordSection');
                if (kaspaMetadata.auth?.passwordIncluded) {
                    // Keep the password input field but hide it
                    document.getElementById('downloadPassword').style.display = 'none';
                    document.getElementById('downloadPassword').value = kaspaMetadata.auth.password;
                    
                    // Show info message
                    const infoDiv = document.createElement('div');
                    infoDiv.className = 'metric-box';
                    infoDiv.innerHTML = '<p class="success">✅ パスワードは.kaspaファイルに含まれています</p>';
                    passwordSection.insertBefore(infoDiv, passwordSection.firstChild);
                } else {
                    // Show password input
                    document.getElementById('downloadPassword').style.display = 'block';
                }
                
                document.getElementById('downloadSection').style.display = 'block';
                log('.kaspaファイルを読み込みました', 'success');
                
            } catch (error) {
                log(`.kaspaファイル読み込みエラー: ${error.message}`, 'error');
            }
        };

        // Load from Meta-TxID
        window.loadFromMetaTxId = async function() {
            const metaTxIdInput = document.getElementById('metaTxIdInput').value.trim();
            let passwordFromField = document.getElementById('metaTxPassword').value;
            
            // Check input format (supports 3 patterns)
            let metaTxId, blockId, password;
            const parts = metaTxIdInput.split(':');
            
            if (parts.length === 3) {
                // Format: TxID:BlockID:Password
                metaTxId = parts[0];
                blockId = parts[1];
                password = parts[2];
                log(`TxID:BlockID:Password形式で復元: ${metaTxId.substring(0, 16)}...:${blockId.substring(0, 16)}...:****`, 'info');
                
                // Auto-fill password field for user visibility
                document.getElementById('metaTxPassword').value = password;
            } else if (parts.length === 2) {
                // Format: TxID:BlockID
                metaTxId = parts[0];
                blockId = parts[1];
                password = passwordFromField;
                log(`TxID:BlockID形式で復元: ${metaTxId.substring(0, 16)}...:${blockId.substring(0, 16)}...`, 'info');
            } else {
                // Format: TxID only
                metaTxId = parts[0];
                blockId = null;
                password = passwordFromField;
                log(`メタTxIDのみで復元（REST API使用）: ${metaTxId.substring(0, 16)}...`, 'info');
            }
            
            if (!metaTxId || metaTxId.length !== 64) {
                log('有効なメタTxID（64文字）を入力してください', 'error');
                return;
            }
            
            if (blockId && blockId.length !== 64) {
                log('有効なBlockID（64文字）を入力してください', 'error');
                return;
            }
            
            if (!password) {
                log('パスワードを入力してください', 'error');
                return;
            }
            
            if (!rpcClient) {
                log('先にシステムを初期化してください', 'error');
                return;
            }
            
            try {
                // Get transaction from blockchain
                let payload = null;
                
                // If we have BlockID, use RPC directly (no REST API needed)
                if (blockId) {
                    log(`BlockIDを使用してRPC経由で取得中...`, 'info');
                    try {
                        const blockResponse = await rpcClient.getBlock({
                            hash: blockId,
                            includeTransactions: true
                        });
                        
                        const block = blockResponse?.block?.block || blockResponse?.block;
                        if (!block) {
                            throw new Error(`ブロックが見つかりません: ${blockId}`);
                        }
                        
                        // Find the meta transaction in the block
                        for (const tx of block.transactions || []) {
                            const txId = tx.verboseData?.transactionId || tx.id || tx.transactionId;
                            if (txId === metaTxId) {
                                if (tx.payload && tx.payload !== '') {
                                    const hexPayload = tx.payload;
                                    payload = safeHexDecode(hexPayload, 'meta-tx payload from RPC');
                                    log(`メタトランザクションをブロックから取得: ${payload.length} bytes`, 'success');
                                    break;
                                }
                            }
                        }
                        
                        if (!payload) {
                            throw new Error(`ブロック内にメタトランザクションが見つかりません`);
                        }
                    } catch (rpcError) {
                        log(`RPCエラー: ${rpcError.message}`, 'error');
                        throw rpcError;
                    }
                } else {
                    // Fall back to REST API if no BlockID provided
                    log(`メタTxID ${metaTxId.substring(0, 16)}... からREST API経由で復元を開始`, 'info');
                    
                    try {
                    // First try to get via Explorer API (more reliable)
                    log('Explorer API経由でメタトランザクションを取得中...', 'info');
                    const apiUrl = `https://api-tn10.kaspa.org/transactions/${metaTxId}`;
                    const response = await fetchWithTimeout(apiUrl, {}, 15000, 3); // 15s timeout, 3 retries
                    
                    if (response.ok) {
                        const data = await response.json();
                        
                        log(`Transaction data received, checking for payload...`, 'info');
                        
                        // First, check if there's a direct payload field
                        if (data.payload) {
                            log(`Found direct payload field, length: ${data.payload.length} chars`, 'info');
                            log(`Payload preview: ${data.payload.substring(0, 100)}...`, 'info');
                            
                            // The payload is a hex string, convert it to bytes
                            const hexString = data.payload;
                            
                            // Check if it's valid hex
                            if (!/^[0-9a-fA-F]+$/.test(hexString)) {
                                log('Warning: Payload contains non-hex characters', 'warning');
                            }
                            
                            // The blockchain returns the payload as hex, decode it directly
                            // Same as chunk download (line 1746)
                            payload = safeHexDecode(hexString, 'meta-tx payload from REST API');
                            log(`Decoded payload: ${payload.length} bytes`, 'info');
                            
                        } else if (data.outputs && data.outputs.length > 0) {
                            // Extract payload from transaction outputs
                            log(`Checking ${data.outputs.length} outputs for payload...`, 'info');
                            
                            for (let i = 0; i < data.outputs.length; i++) {
                                const output = data.outputs[i];
                                log(`Output ${i}: type=${output.script_public_key_type}, script length=${output.script_public_key?.length || 0}`, 'info');
                                
                                if (output.script_public_key_type === 'pubkey' && output.script_public_key) {
                                    const scriptHex = output.script_public_key;
                                    
                                    // In Kaspa, payload transactions have a different script structure
                                    // The script should contain the payload data embedded
                                    if (scriptHex.length > 140) {
                                        log(`Found long script (${scriptHex.length} chars), attempting to extract payload...`, 'info');
                                        log(`Script preview: ${scriptHex.substring(0, 100)}...`, 'info');
                                        
                                        // Try different extraction methods
                                        // Method 1: Skip first 4 chars and last 68 chars
                                        const payloadHex = scriptHex.substring(4, scriptHex.length - 68);
                                        payload = safeHexDecode(payloadHex, 'meta-tx payload from script');
                                        log(`Extracted payload size: ${payload.length} bytes`, 'info');
                                        break;
                                    }
                                }
                            }
                        }
                        
                        // Check if we have transaction with payload in a different format
                        if (!payload && data.subnetwork_id === "0000000000000000000000000000000000000000") {
                            log(`Checking for payload in transaction data...`, 'info');
                            console.log('Full transaction data:', data);
                        }
                    }
                } catch (apiError) {
                    log(`Explorer APIエラー: ${apiError.message}`, 'warning');
                }
                
                // If Explorer API failed or payload is incomplete, try RPC
                if (!payload || payload.length < 100) {
                    log('Explorer APIのペイロードが不完全、RPC経由で再試行...', 'warning');
                    
                    try {
                        // Get transaction via RPC
                        const txResponse = await rpcClient.getTransaction({
                            transactionId: metaTxId,
                            includeBlockInfo: true
                        });
                        
                        if (txResponse && txResponse.transaction) {
                            log('RPC経由でトランザクション取得成功', 'info');
                            
                            // Extract payload from transaction
                            const tx = txResponse.transaction;
                            if (tx.payload) {
                                // RPC might return hex or base64 encoded payload
                                // Check if it's hex
                                if (/^[0-9a-fA-F]+$/.test(tx.payload)) {
                                    payload = safeHexDecode(tx.payload, 'meta-tx payload from block tx');
                                    log(`RPC hex payload: ${payload.length} bytes`, 'info');
                                } else {
                                    // Assume base64
                                    payload = fromBase64(tx.payload);
                                    log(`RPC base64 payload: ${payload.length} bytes`, 'info');
                                }
                            } else if (tx.verboseData && tx.verboseData.payload) {
                                if (/^[0-9a-fA-F]+$/.test(tx.verboseData.payload)) {
                                    payload = safeHexDecode(tx.verboseData.payload, 'meta-tx payload from verbose data');
                                    log(`RPC verbose hex payload: ${payload.length} bytes`, 'info');
                                } else {
                                    payload = fromBase64(tx.verboseData.payload);
                                    log(`RPC verbose base64 payload: ${payload.length} bytes`, 'info');
                                }
                            }
                        }
                    } catch (rpcError) {
                        log(`RPC取得エラー: ${rpcError.message}`, 'error');
                    }
                }
                }
                
                if (!payload) {
                    throw new Error('メタトランザクションのペイロードが見つかりません');
                }
                
                log(`ペイロード取得成功: ${payload.length} bytes`, 'info');
                
                // Try to decrypt the payload
                try {
                    // First, try to derive key with a temporary salt (we'll get the real salt from decrypted data)
                    // Use the metaTxId as a deterministic salt source for the first attempt
                    const tempSalt = new Uint8Array(16);
                    for (let i = 0; i < 16; i++) {
                        tempSalt[i] = parseInt(metaTxId.substr(i * 2, 2), 16);
                    }
                    
                    // Try decrypting with chunk index -1 (meta-tx indicator)
                    let decrypted;
                    let metaData;
                    
                    // We need to try different approaches since we don't have the salt yet
                    // The actual implementation would need to extract salt from the encrypted data
                    // or use a standardized approach
                    
                    // For now, let's try to extract the salt from the beginning of the payload
                    if (payload.length > 16) {
                        const salt = payload.slice(0, 16);
                        const encryptedData = payload.slice(16);
                        
                        const key = await deriveKey(password, salt);
                        
                        try {
                            log(`Attempting to decrypt with salt (${salt.length} bytes) and encrypted data (${encryptedData.length} bytes)`, 'info');
                            decrypted = await decryptChunk(encryptedData, key, -1);
                            const metaDataString = new TextDecoder().decode(decrypted);
                            log(`Decrypted string preview: ${metaDataString.substring(0, 50)}...`, 'info');
                            metaData = JSON.parse(metaDataString);
                        } catch (e) {
                            log('復号化失敗 - パスワードが間違っている可能性があります', 'error');
                            log(`Decryption error details: ${e.message || e}`, 'error');
                            console.error('Decryption error:', e);
                            
                            // Log first few bytes of payload for debugging
                            const payloadPreview = Array.from(payload.slice(0, 32)).map(b => b.toString(16).padStart(2, '0')).join(' ');
                            log(`Payload hex preview: ${payloadPreview}`, 'info');
                            throw e;
                        }
                    } else {
                        throw new Error('ペイロードが短すぎます');
                    }
                    
                    // Verify this is a meta-tx
                    if (metaData.version === "2.1" && metaData.type === "kaspa-meta-tx") {
                        log('メタトランザクションを正常に復号化しました', 'success');
                        
                        // Set kaspaMetadata from meta-tx data
                        kaspaMetadata = {
                            version: "2.0", // Convert back to standard format
                            kaspa: metaData.kaspa,
                            file: metaData.file,
                            encryption: metaData.encryption,
                            compression: metaData.compression,
                            chunks: metaData.chunks,
                            metadata: metaData.metadata,
                            metaTx: {
                                txid: metaTxId,
                                loadedAt: Date.now()
                            }
                        };
                        
                        // Show file info
                        document.getElementById('fileInfo').textContent = 
                            `ファイル名: ${kaspaMetadata.file.name}\n` +
                            `サイズ: ${(kaspaMetadata.file.size / 1024).toFixed(1)} KB\n` +
                            `チャンク数: ${kaspaMetadata.chunks.length}\n` +
                            `暗号化: ${kaspaMetadata.encryption.algorithm}\n` +
                            `圧縮: ${kaspaMetadata.compression.enabled ? kaspaMetadata.compression.algorithm : 'なし'}\n` +
                            `作成日時: ${new Date(kaspaMetadata.metadata.createdAt).toLocaleString()}\n` +
                            `メタTxID: ${metaTxId.substring(0, 16)}...`;
                        
                        // Set password for download
                        document.getElementById('downloadPassword').value = password;
                        document.getElementById('downloadPassword').style.display = 'none';
                        
                        // Show download section
                        document.getElementById('downloadSection').style.display = 'block';
                        
                        log('メタTxIDからの復元準備完了！ダウンロードボタンをクリックしてください。', 'success');
                        
                    } else {
                        throw new Error('これは有効なメタトランザクションではありません');
                    }
                    
                } catch (error) {
                    log(`復号化エラー: ${error.message}`, 'error');
                    throw error;
                }
                
            } catch (error) {
                log(`メタTxID復元エラー: ${error.message}`, 'error');
            }
        };

        // Download file
        window.downloadFile = async function() {
            let password = document.getElementById('downloadPassword').value;
            
            if (kaspaMetadata.auth?.passwordIncluded && kaspaMetadata.auth?.password) {
                password = kaspaMetadata.auth.password;
            }
            
            if (!password) {
                log('パスワードを入力してください', 'error');
                return;
            }
            
            if (!kaspaMetadata) {
                log('.kaspaファイルが読み込まれていません', 'error');
                return;
            }
            
            if (!rpcClient) {
                log('先にシステムを初期化してください', 'error');
                return;
            }
            
            document.getElementById('downloadProgress').style.display = 'block';
            
            try {
                log(`ダウンロード開始: ${kaspaMetadata.file.name}`);
                
                // Derive key
                const salt = fromBase64(kaspaMetadata.encryption.pbkdf2.salt);
                const key = await deriveKey(password, salt);
                
                const chunks = [];
                
                // Check if parallel download should be used
                const useParallel = parallelDownloadEnabled && kaspaMetadata.chunks.length >= 10;
                
                if (useParallel) {
                    // Parallel download
                    log(`並列ダウンロードモードを使用します (${kaspaMetadata.chunks.length}チャンク)`, 'info');
                    
                    try {
                        const downloader = new ParallelDownloader(rpcClient, 8);
                        
                        const parallelChunks = await downloader.downloadChunks(
                            kaspaMetadata.chunks,
                            key,
                            kaspaMetadata,
                            (progress) => {
                                const percent = ((progress.completed / progress.total) * 100).toFixed(0);
                                document.getElementById('downloadProgressBar').style.width = percent + '%';
                                document.getElementById('downloadProgressBar').textContent = percent + '%';
                                document.getElementById('downloadStatus').textContent = 
                                    `${progress.completed}/${progress.total} チャンク (${progress.speed.toFixed(1)} チャンク/秒, ${progress.throughput.toFixed(1)} MB/秒)`;
                            }
                        );
                        
                        chunks.push(...parallelChunks);
                    } catch (parallelError) {
                        log(`並列ダウンロードエラー: ${parallelError.message}`, 'error');
                        log('シーケンシャルダウンロードにフォールバックします', 'warning');
                        
                        // Fallback to sequential
                        chunks.length = 0;
                        for (let i = 0; i < kaspaMetadata.chunks.length; i++) {
                    const chunkMeta = kaspaMetadata.chunks[i];
                    
                    document.getElementById('downloadStatus').textContent = 
                        `チャンク ${i + 1}/${kaspaMetadata.chunks.length} を取得中...`;
                    
                    try {
                        log(`チャンク ${i + 1}: BlockID ${chunkMeta.blockId.substring(0, 16)}...`, 'info');
                        
                        // Get block data
                        const request = { 
                            hash: chunkMeta.blockId, 
                            includeTransactions: true 
                        };
                        log(`RPC getBlock request: ${JSON.stringify(request)}`, 'info');
                        
                        let response;
                        try {
                            response = await rpcClient.getBlock(request);
                            log(`RPC getBlock response received`, 'info');
                            log(`Response type: ${typeof response}`, 'info');
                            log(`Response keys: ${Object.keys(response || {}).join(', ')}`, 'info');
                        } catch (rpcError) {
                            log(`RPC getBlock error: ${rpcError.message || rpcError}`, 'error');
                            log(`Error type: ${rpcError.constructor.name}`, 'error');
                            throw rpcError;
                        }
                        
                        const block = response?.block?.block || response?.block;
                        log(`Block extracted: ${!!block}`, 'info');
                        
                        if (!block) {
                            log(`Block not found in response structure`, 'error');
                            throw new Error(`ブロックが見つかりません: ${chunkMeta.blockId}`);
                        }
                        
                        // Find transaction with matching TxID
                        let payload = null;
                        const txCount = block.transactions?.length || 0;
                        log(`ブロック内のトランザクション数: ${txCount}`, 'info');
                        
                        if (txCount === 0) {
                            log(`警告: トランザクションが含まれていません`, 'warning');
                            // BigIntを含む可能性があるのでJSON.stringifyは避ける
                            log(`Block has header.hash: ${block.header?.hash}`, 'warning');
                        }
                        
                        for (const tx of block.transactions || []) {
                            // BigIntを含む可能性があるのでJSON.stringifyは避ける
                            log(`Checking transaction...`, 'info');
                            const txId = tx.verboseData?.transactionId || tx.id || tx.transactionId;
                            log(`Transaction ID variants: verboseData.transactionId=${tx.verboseData?.transactionId}, tx.id=${tx.id}, tx.transactionId=${tx.transactionId}`, 'info');
                            
                            if (txId === chunkMeta.txid) {
                                log(`TxID一致: ${txId.substring(0, 16)}...`, 'info');
                                log(`tx.payload exists: ${!!tx.payload}, length: ${tx.payload?.length || 0}`, 'info');
                                
                                if (tx.payload && tx.payload !== '') {
                                    // Get raw binary payload from hex (blockchain stores as hex)
                                    const hexPayload = tx.payload;
                                    log(`ペイロード長: ${hexPayload.length} 文字 (hex)`, 'info');
                                    log(`最初の100文字: ${hexPayload.substring(0, 100)}...`, 'info');
                                    
                                    // Blockchain stores binary payloads as hex strings
                                    try {
                                        payload = safeHexDecode(hexPayload, 'chunk payload');
                                        log(`Hex decode成功: ${payload.length} バイト (生バイナリ)`, 'info');
                                    } catch (e) {
                                        log(`Hex decode error details: ${e.stack || e}`, 'error');
                                        throw new Error(`ペイロードのデコードに失敗: ${e.message}`);
                                    }
                                    break;
                                } else {
                                    log(`警告: ペイロードが空です (TxID: ${txId})`, 'warning');
                                }
                            } else {
                                log(`TxID不一致: ${txId} !== ${chunkMeta.txid}`, 'info');
                            }
                        }
                        
                        if (!payload) {
                            throw new Error(`チャンク ${i + 1} のペイロードが見つかりません`);
                        }
                        
                        // Decrypt and decompress
                        const encrypted = payload; // Already binary Uint8Array
                        const compressed = await decryptChunk(encrypted, key, i);
                        const original = kaspaMetadata.compression.enabled ? lzDecompress(compressed) : compressed;
                        
                        chunks.push(original);
                        
                        // Update progress
                        const progress = ((i + 1) / kaspaMetadata.chunks.length * 100).toFixed(0);
                        document.getElementById('downloadProgressBar').style.width = progress + '%';
                        document.getElementById('downloadProgressBar').textContent = progress + '%';
                        
                        log(`チャンク ${i + 1} 取得成功`);
                        
                    } catch (error) {
                        log(`チャンク ${i + 1} エラー: ${error.message}`, 'error');
                        throw error;
                    }
                }
                    }
                } else {
                    // Sequential download (default)
                    log(`シーケンシャルダウンロードモードを使用します (${kaspaMetadata.chunks.length}チャンク)`, 'info');
                    
                    for (let i = 0; i < kaspaMetadata.chunks.length; i++) {
                        const chunkMeta = kaspaMetadata.chunks[i];
                        
                        document.getElementById('downloadStatus').textContent = 
                            `チャンク ${i + 1}/${kaspaMetadata.chunks.length} を取得中...`;
                        
                        try {
                            log(`チャンク ${i + 1}: BlockID ${chunkMeta.blockId.substring(0, 16)}...`, 'info');
                            
                            // Get block data
                            const request = { 
                                hash: chunkMeta.blockId, 
                                includeTransactions: true 
                            };
                            log(`RPC getBlock request: ${JSON.stringify(request)}`, 'info');
                            
                            let response;
                            try {
                                response = await rpcClient.getBlock(request);
                                log(`RPC getBlock response received`, 'info');
                                log(`Response type: ${typeof response}`, 'info');
                                log(`Response keys: ${Object.keys(response || {}).join(', ')}`, 'info');
                            } catch (rpcError) {
                                log(`RPC getBlock error: ${rpcError.message || rpcError}`, 'error');
                                log(`Error type: ${rpcError.constructor.name}`, 'error');
                                throw rpcError;
                            }
                            
                            const block = response?.block?.block || response?.block;
                            log(`Block extracted: ${!!block}`, 'info');
                            
                            if (!block) {
                                log(`Block not found in response structure`, 'error');
                                throw new Error(`ブロックが見つかりません: ${chunkMeta.blockId}`);
                            }
                            
                            // Find transaction with matching TxID
                            let payload = null;
                            const txCount = block.transactions?.length || 0;
                            log(`ブロック内のトランザクション数: ${txCount}`, 'info');
                            
                            if (txCount === 0) {
                                log(`警告: トランザクションが含まれていません`, 'warning');
                                // BigIntを含む可能性があるのでJSON.stringifyは避ける
                                log(`Block has header.hash: ${block.header?.hash}`, 'warning');
                            }
                            
                            for (const tx of block.transactions || []) {
                                // BigIntを含む可能性があるのでJSON.stringifyは避ける
                                log(`Checking transaction...`, 'info');
                                const txId = tx.verboseData?.transactionId || tx.id || tx.transactionId;
                                log(`Transaction ID variants: verboseData.transactionId=${tx.verboseData?.transactionId}, tx.id=${tx.id}, tx.transactionId=${tx.transactionId}`, 'info');
                                
                                if (txId === chunkMeta.txid) {
                                    log(`TxID一致: ${txId.substring(0, 16)}...`, 'info');
                                    log(`tx.payload exists: ${!!tx.payload}, length: ${tx.payload?.length || 0}`, 'info');
                                    
                                    if (tx.payload && tx.payload !== '') {
                                        // Get raw binary payload from hex (blockchain stores as hex)
                                        payload = safeHexDecode(tx.payload, 'chunk payload');
                                        log(`ペイロード取得成功: ${payload.length} bytes`, 'info');
                                        break;
                                    }
                                }
                            }
                            
                            if (!payload) {
                                throw new Error(`チャンク ${i + 1} のペイロードが見つかりません`);
                            }
                            
                            // Decrypt and decompress
                            const encrypted = payload; // Already binary Uint8Array
                            const compressed = await decryptChunk(encrypted, key, i);
                            const original = kaspaMetadata.compression.enabled ? lzDecompress(compressed) : compressed;
                            
                            chunks.push(original);
                            
                            // Update progress
                            const progress = ((i + 1) / kaspaMetadata.chunks.length * 100).toFixed(0);
                            document.getElementById('downloadProgressBar').style.width = progress + '%';
                            document.getElementById('downloadProgressBar').textContent = progress + '%';
                            
                            log(`チャンク ${i + 1} 取得成功`);
                            
                        } catch (error) {
                            log(`チャンク ${i + 1} エラー: ${error.message}`, 'error');
                            throw error;
                        }
                    }
                }
                
                // Combine chunks
                const totalSize = chunks.reduce((sum, chunk) => sum + chunk.length, 0);
                const combined = new Uint8Array(totalSize);
                let offset = 0;
                for (const chunk of chunks) {
                    combined.set(chunk, offset);
                    offset += chunk.length;
                }
                
                // Verify hash
                const downloadedHash = await sha256(combined);
                if (downloadedHash !== kaspaMetadata.file.sha256) {
                    throw new Error('ファイル整合性チェック失敗！');
                }
                
                // Download
                const blob = new Blob([combined], { type: kaspaMetadata.file.mimeType });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = kaspaMetadata.file.name;
                a.click();
                URL.revokeObjectURL(url);
                
                log(`ダウンロード完了: ${kaspaMetadata.file.name}`, 'success');
                
            } catch (error) {
                log(`ダウンロードエラー: ${error.message}`, 'error');
            }
        };

        // Check if monitoring should stop
        async function checkMonitoringStop() {
            // v3.6.3 fix: Check overall upload status
            if (uploadingChunksCount === 0 && !uploadingMetaTx && !isUploadingFile) {
                log(`[DEBUG] WebSocket監視: 残り0件 - 自動停止します`, 'debug');
                await stopMonitoring();
            }
        }
        
        // WebSocket monitoring
        window.startMonitoring = async function() {
            if (!rpcClient) {
                log('先にシステムを初期化してください', 'error');
                return;
            }
            
            if (wsMonitorActive) {
                log('すでに監視中です', 'warning');
                return;
            }
            
            try {
                log('WebSocket監視を開始...', 'info');
                wsMonitorActive = true;
                
                // Set 5 minute timeout
                if (wsMonitorTimeout) {
                    clearTimeout(wsMonitorTimeout);
                }
                wsMonitorTimeout = setTimeout(async () => {
                    log('WebSocket監視: 5分タイムアウト - 自動停止', 'warning');
                    await stopMonitoring();
                }, 5 * 60 * 1000);
                
                await rpcClient.subscribeBlockAdded();
                log('Block Addedイベントを購読しました', 'success');
                
                log('WebSocket監視を開始しました', 'success');
                
            } catch (error) {
                log(`監視開始エラー: ${error.message}`, 'error');
                wsMonitorActive = false;
            }
        };

        window.stopMonitoring = async function() {
            if (!wsMonitorActive) {
                log('監視は開始されていません', 'warning');
                return;
            }
            
            try {
                if (rpcClient) {
                    await rpcClient.unsubscribeBlockAdded();
                }
                wsMonitorActive = false;
                
                // Clear timeout
                if (wsMonitorTimeout) {
                    clearTimeout(wsMonitorTimeout);
                    wsMonitorTimeout = null;
                }
                
                // Reset counters
                uploadingChunksCount = 0;
                uploadingMetaTx = false;
                
                log('WebSocket監視を停止しました', 'info');
                
            } catch (error) {
                log(`監視停止エラー: ${error.message}`, 'error');
            }
        };

        // Toggle parallel download
        window.toggleParallelDownload = function() {
            parallelDownloadEnabled = document.getElementById('parallelDownloadToggle').checked;
            localStorage.setItem('kaspaParallelDownload', parallelDownloadEnabled.toString());
            
            if (parallelDownloadEnabled) {
                log('並列ダウンロードを有効にしました（実験的機能）', 'warning');
            } else {
                log('並列ダウンロードを無効にしました（安定モード）', 'success');
            }
        };
        
        // Settings functions
        window.exportLogs = function() {
            const exportData = {
                timestamp: new Date().toISOString(),
                logs: systemLogs,
                uploadHistory: uploadHistory,
                monitoredTransactions: Array.from(monitoredTransactions.entries())
            };
            
            const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `kaspa-p2p-logs-${Date.now()}.json`;
            a.click();
            URL.revokeObjectURL(url);
            
            log('ログをエクスポートしました', 'success');
        };

        window.clearLogs = function() {
            if (confirm('すべてのログをクリアしますか？')) {
                systemLogs = [];
                document.getElementById('systemLog').innerHTML = '';
                document.getElementById('monitorLog').innerHTML = '';
                log('ログをクリアしました', 'info');
            }
        };

        window.copyLog = function() {
            const logText = systemLogs.map(log => 
                `[${log.time}] ${log.type.toUpperCase()}: ${log.message}`
            ).join('\n');
            
            navigator.clipboard.writeText(logText).then(() => {
                alert('ログをクリップボードにコピーしました');
            });
        };

        // Drag and drop
        window.handleDragOver = function(e) {
            e.preventDefault();
            e.currentTarget.classList.add('dragover');
        };

        window.handleDragLeave = function(e) {
            e.preventDefault();
            e.currentTarget.classList.remove('dragover');
        };

        window.handleKaspaDrop = function(e) {
            e.preventDefault();
            e.currentTarget.classList.remove('dragover');
            
            log('=== handleKaspaDrop 開始 ===', 'info');
            log(`e.dataTransfer.files: ${e.dataTransfer.files}`, 'info');
            log(`files.length: ${e.dataTransfer.files.length}`, 'info');
            
            const file = e.dataTransfer.files[0];
            log(`file: ${file}`, 'info');
            
            if (file) {
                log(`file.name: ${file.name}`, 'info');
                log(`file.type: ${file.type}`, 'info');
                log(`file.size: ${file.size} bytes`, 'info');
                log(`endsWith('.kaspa'): ${file.name.endsWith('.kaspa')}`, 'info');
            }
            
            if (file && file.name.endsWith('.kaspa')) {
                document.getElementById('kaspaFileInput').files = e.dataTransfer.files;
                loadKaspaFile({ target: { files: [file] } });
            } else {
                log('ドロップされたファイルは.kaspaファイルではありません', 'error');
            }
        };

        // File upload drag and drop
        document.addEventListener('DOMContentLoaded', () => {
            const fileLabel = document.querySelector('.file-input-label');
            
            fileLabel.addEventListener('dragover', handleDragOver);
            fileLabel.addEventListener('dragleave', handleDragLeave);
            fileLabel.addEventListener('drop', (e) => {
                e.preventDefault();
                e.currentTarget.classList.remove('dragover');
                
                const file = e.dataTransfer.files[0];
                if (file) {
                    document.getElementById('fileInput').files = e.dataTransfer.files;
                    handleFileSelect({ target: { files: [file] } });
                }
            });
            
            // Update config from settings
            document.getElementById('networkSelect').addEventListener('change', (e) => {
                config.network = e.target.value;
                log(`ネットワーク変更: ${config.network}`, 'info');
            });
            
            document.getElementById('retryCount').addEventListener('change', (e) => {
                config.retryCount = parseInt(e.target.value);
                log(`リトライ回数変更: ${config.retryCount}`, 'info');
            });
            
            document.getElementById('timeout').addEventListener('change', (e) => {
                config.timeout = parseInt(e.target.value) * 1000;
                log(`タイムアウト変更: ${config.timeout/1000}秒`, 'info');
            });
            
            // Display upload history
            setInterval(() => {
                const historyDiv = document.getElementById('uploadHistory');
                if (uploadHistory.length > 0) {
                    historyDiv.innerHTML = uploadHistory.slice(-5).reverse().map(item => `
                        <div class="metric-box">
                            <strong>${item.filename}</strong><br>
                            ${new Date(item.timestamp).toLocaleString()}<br>
                            ${item.metadata.chunks.length} チャンク
                        </div>
                    `).join('');
                } else {
                    historyDiv.innerHTML = '<p>アップロード履歴はありません</p>';
                }
            }, 5000);
            
            // Debug: Add event listener to file input
            const kaspaFileInput = document.getElementById('kaspaFileInput');
            if (kaspaFileInput) {
                log('kaspaFileInput要素が見つかりました', 'info');
                kaspaFileInput.addEventListener('change', (e) => {
                    log('=== kaspaFileInput change event ===', 'info');
                    log(`Event fired, files: ${e.target.files?.length || 0}`, 'info');
                });
            } else {
                log('警告: kaspaFileInput要素が見つかりません', 'error');
            }
            
            log('🚀 Kaspa P2P v3.6.7 準備完了！', 'info');
            log('📋 v3.6.7: WebSocket監視修正 + 並列ダウンロード + Historyタブ修正', 'info');
            log('✨ 並列ダウンロード: ' + (parallelDownloadEnabled ? '有効' : '無効'), 'info');
            log('システムを初期化してください', 'info');
            
            // Initialize workspace prompt
            setTimeout(async () => {
                // Check if File System Access API is available
                if ('showDirectoryPicker' in window) {
                    const hasWorkspace = window.workspaceHandle !== null;
                    if (!hasWorkspace) {
                        const useFileAPI = confirm(
                            'Kaspa P2P File Storage\n\n' +
                            '作業フォルダを設定しますか？\n\n' +
                            '設定すると：\n' +
                            '✓ 進捗がファイルに自動保存されます\n' +
                            '✓ ダウンロードファイルが整理されます\n' +
                            '✓ ブラウザを閉じても進捗が残ります\n\n' +
                            '設定しない場合：\n' +
                            '✓ ブラウザ内に進捗が保存されます\n' +
                            '✓ ファイルの自動ダウンロードはありません\n\n' +
                            '※「作業フォルダ設定」ボタンで後から設定できます'
                        );
                        
                        if (useFileAPI) {
                            await setupWorkspace();
                        } else {
                            log('作業フォルダ未設定 - ブラウザ内に進捗を保存します', 'info');
                            showWorkspaceStatus();
                        }
                    } else {
                        showWorkspaceStatus();
                    }
                } else {
                    log('File System Access APIはこのブラウザでは利用できません', 'warning');
                }
                
                // Check for saved progress
                const metadata = localStorage.getItem('kaspa-upload-metadata');
                if (metadata) {
                    try {
                        const meta = JSON.parse(metadata);
                        if (meta.completedChunks < meta.totalChunks) {
                            const hoursSince = (Date.now() - meta.lastUpdate) / (1000 * 60 * 60);
                            if (hoursSince < 24) {
                                log(`未完了のアップロードが見つかりました`, 'warning');
                                log(`ファイル: ${meta.fileName} (${meta.completedChunks}/${meta.totalChunks} チャンク)`, 'info');
                                log('「進捗ファイルから再開」ボタンをクリックして続行', 'info');
                            }
                        }
                    } catch (err) {}
                }
            }, 1000);
            
            // Network status monitoring
            window.addEventListener('online', async () => {
                log('ネットワーク接続が復活しました', 'success');
                if (rpcClient) {
                    updateNetworkStatus('online', 'オンライン');
                    
                    // Check if we need to reconnect RPC client
                    if (progressManager && progressManager.progress && 
                        progressManager.progress.metadata.completedChunks < progressManager.progress.metadata.totalChunks) {
                        log('アップロード中 - RPC接続を確認します', 'info');
                        
                        // Test RPC connection
                        try {
                            const info = await rpcClient.getServerInfo();
                            log(`RPC接続確認: ${info.serverVersion}`, 'success');
                        } catch (err) {
                            log('RPC接続エラー - 再接続を試みます', 'error');
                            // Reinitialize RPC client
                            await initializeRpcClient();
                            
                            // Restart WebSocket monitoring if it was active
                            if (wsMonitorActive) {
                                log('WebSocket監視を再開します', 'info');
                                await restartMonitoring();
                            }
                        }
                    }
                }
            });
            
            window.addEventListener('offline', async () => {
                log('ネットワーク接続が切断されました', 'error');
                updateNetworkStatus('offline', 'オフライン');
                
                // Save progress if uploading
                if (progressManager && progressManager.progress) {
                    await progressManager.saveProgress();
                    log('進捗を自動保存しました', 'info');
                }
            });
            
            // Periodic cleanup of old progress data
            setInterval(() => {
                const metadata = localStorage.getItem('kaspa-upload-metadata');
                if (metadata) {
                    try {
                        const meta = JSON.parse(metadata);
                        const daysSince = (Date.now() - meta.lastUpdate) / (1000 * 60 * 60 * 24);
                        if (daysSince > 7) {
                            // Clean up old progress after 7 days
                            localStorage.removeItem('kaspa-upload-progress');
                            localStorage.removeItem('kaspa-upload-metadata');
                            log('古い進捗データを削除しました', 'info');
                        }
                    } catch (err) {}
                }
            }, 3600000); // Every hour
            
            // Make functions available globally
            window.setupWorkspace = setupWorkspace;
            window.showWorkspaceStatus = showWorkspaceStatus;
        });
        
        // WebSocket monitoring (from complete.html with network recovery enhancements)
        window.startMonitoring = async function() {
            if (!rpcClient) {
                log('先にシステムを初期化してください', 'error');
                return;
            }
            
            if (wsMonitorActive) {
                log('すでに監視中です', 'warning');
                return;
            }
            
            try {
                log('WebSocket監視を開始しました', 'info');
                wsMonitorActive = true;
                
                await rpcClient.subscribeBlockAdded();
                log('Block Addedイベントを購読しました', 'success');
                log('WebSocket経由でブロック追加イベントの監視を開始', 'info');
                
                rpcClient.addEventListener('block-added', (event) => {
                    const block = event.data.block;
                    const blockId = block.header.hash;
                    const blockTime = new Date(Number(block.header.timestamp));
                    
                    // Clean up old transactions (older than 90 seconds)
                    const now = Date.now();
                    for (const [txid, txData] of monitoredTransactions.entries()) {
                        if (now - txData.timestamp > 90000) {
                            monitoredTransactions.delete(txid);
                            // log(`WebSocket監視から古いトランザクションを削除: ${txid.substring(0, 16)}... (90秒経過)`, 'debug');
                        }
                    }
                    
                    if (block.transactions && block.transactions.length > 0) {
                        let myTransactionFound = false;
                        
                        for (const tx of block.transactions) {
                            const txId = tx.verboseData?.transactionId || tx.id || tx.transactionId;
                            if (txId) {
                                // Check if this is one of our monitored transactions
                                if (monitoredTransactions.has(txId)) {
                                    // Update existing entry (preserve original data)
                                    const existing = monitoredTransactions.get(txId);
                                    existing.blockId = blockId;
                                    existing.blockTime = blockTime;
                                    existing.foundAt = new Date();
                                    
                                    log(`[DEBUG] WebSocket: 監視中のトランザクション検出！ TxID: ${txId.substring(0, 16)}... BlockID: ${blockId.substring(0, 16)}...`, 'debug');
                                    log(`[DEBUG] WebSocket: ブロック時刻を保存 - Time: ${blockTime.toISOString()}`, 'debug');
                                    myTransactionFound = true;
                                    
                                    // Check if upload is complete after finding this transaction
                                    setTimeout(checkMonitoringStop, 100);
                                } else {
                                    // Skip monitoring other transactions to reduce noise
                                    // We only care about our own transactions
                                }
                            }
                        }
                        
                        
                        // Only log if we found our transaction or if it's a small block
                        if (myTransactionFound) {
                            log(`✅ WebSocket: ブロック ${blockId.substring(0, 16)}... で監視中のトランザクションを確認`, 'success');
                        } else if (block.transactions.length <= 5) {
                            // Only log small blocks to reduce noise
                            // log(`WebSocket: ブロック ${blockId.substring(0, 16)}... に ${block.transactions.length} トランザクション`, 'debug');
                        }
                    }
                });
                
                // log(`現在監視中のトランザクション数: ${monitoredTransactions.size}`, 'info');
                
            } catch (error) {
                log(`WebSocket監視エラー: ${error.message}`, 'error');
                wsMonitorActive = false;
                
                // Network error recovery - will retry on reconnect
                if (error.message.includes('network') || error.message.includes('connection')) {
                    log('ネットワークエラーを検出 - 再接続時に再試行します', 'warning');
                }
            }
        };

        window.stopMonitoring = async function() {
            if (!wsMonitorActive) {
                monitorLog('監視は開始されていません', 'warning');
                return;
            }
            
            try {
                if (rpcClient) {
                    await rpcClient.unsubscribeBlockAdded();
                    monitorLog('監視を停止しました', 'success');
                    log('WebSocket監視を停止しました', 'info');
                }
                wsMonitorActive = false;
                
            } catch (error) {
                monitorLog(`監視停止エラー: ${error.message}`, 'error');
                log(`WebSocket監視停止エラー: ${error.message}`, 'error');
            }
        };
        
        // Restart monitoring after network recovery
        async function restartMonitoring() {
            if (wsMonitorActive) {
                log('WebSocket監視の再起動を試みます', 'info');
                await stopMonitoring();
                await new Promise(resolve => setTimeout(resolve, 1000)); // Wait 1 second
                await startMonitoring();
            }
        }
        
        // Initialize history manager on load
        window.historyManager = new UploadHistoryManager();
        
        // Auto-initialize WASM on page load
        window.addEventListener('DOMContentLoaded', async function() {
            log('ページ読み込み完了 - システムを自動初期化します', 'info');
            loadParallelSetting(); // Load parallel download setting
            await initializeSystem();
        });
    </script>
</body>
</html><!-- Force GitHub Pages update: Sat Jul  5 09:53:35 JST 2025 -->

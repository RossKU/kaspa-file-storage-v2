<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Kaspa P2P File Storage v4.7.41 DEBUG - Variable Chunk Compression Analysis</title>
    <style>
        body {
            font-family: 'Arial', sans-serif;
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
            background: #1a1a2e;
            color: #eee;
        }
        .header {
            background: linear-gradient(135deg, #16213e 0%, #0f3460 100%);
            padding: 30px;
            border-radius: 10px;
            text-align: center;
            margin-bottom: 30px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.3);
        }
        h1 {
            margin: 0;
            color: #e94560;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
        }
        .container {
            background: #0f3460;
            padding: 25px;
            border-radius: 10px;
            margin-bottom: 20px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.2);
        }
        .log-container {
            background: #0a0a0a;
            color: #0f0;
            font-family: 'Consolas', monospace;
            font-size: 12px;
            padding: 10px;
            height: 600px;
            overflow-y: auto;
            border-radius: 5px;
            margin: 10px 0;
            white-space: pre-wrap;
            word-wrap: break-word;
        }
        .log-error { color: #ff5252; }
        .log-success { color: #4CAF50; }
        .log-info { color: #2196F3; }
        .log-warning { color: #ffc107; }
        .log-debug { color: #9c27b0; }
        button {
            background: #e94560;
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
            margin: 5px;
            transition: all 0.3s;
        }
        button:hover {
            background: #c13651;
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(233, 69, 96, 0.3);
        }
        input[type="text"], input[type="password"] {
            width: 100%;
            background: #16213e;
            color: #eee;
            border: 1px solid #e94560;
            padding: 10px;
            border-radius: 5px;
            margin: 5px 0;
            font-family: 'Consolas', monospace;
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>🔧 Kaspa P2P v4.7.41 DEBUG</h1>
        <p>可変チャンク圧縮ファイルの復号化問題デバッグ版</p>
    </div>

    <div class="container">
        <h2>📥 デバッグモード ダウンロードテスト</h2>
        <div>
            <label>メタTxID:BlockID:パスワード</label>
            <input type="text" id="testInput" value="331bb84717cd3c63fe5dd2a2a8bb45a8c88a60f8e7f5d8d7f1e013c95ba50dd4:7683c34ad6e0fb31dc3e456bb67ad6787e19fa20d5bb7bb1f37c088e4bb8cce3:12345678" style="width: 100%; padding: 10px; margin: 10px 0;">
        </div>
        <button onclick="startDebugDownload()">デバッグダウンロード開始</button>
        <button onclick="clearLog()">ログクリア</button>
        <div class="log-container" id="logContainer"></div>
    </div>

    <script>
        // Logging function
        function log(message, type = 'info') {
            const logContainer = document.getElementById('logContainer');
            const timestamp = new Date().toLocaleTimeString('ja-JP');
            const logEntry = document.createElement('div');
            logEntry.className = `log-entry log-${type}`;
            logEntry.textContent = `[${timestamp}] ${message}`;
            logContainer.appendChild(logEntry);
            logContainer.scrollTop = logContainer.scrollHeight;
            console.log(`[${type.toUpperCase()}] ${message}`);
        }

        function clearLog() {
            document.getElementById('logContainer').innerHTML = '';
        }

        // Base64 functions
        function toBase64(data) {
            return btoa(String.fromCharCode(...data));
        }

        function fromBase64(str) {
            return new Uint8Array(atob(str).split('').map(c => c.charCodeAt(0)));
        }

        // Hex decode with detailed logging
        function safeHexDecode(hexString, context = 'unknown') {
            log(`Hex decode for ${context}: input length = ${hexString.length}`, 'debug');
            
            if (!hexString || hexString.length === 0) {
                log(`Empty hex string for ${context}`, 'error');
                return new Uint8Array(0);
            }
            
            // Remove any whitespace
            hexString = hexString.replace(/\s+/g, '');
            
            if (hexString.length % 2 !== 0) {
                log(`Invalid hex string length for ${context}: ${hexString.length}`, 'error');
                hexString = '0' + hexString;
            }
            
            const bytes = new Uint8Array(hexString.length / 2);
            for (let i = 0; i < hexString.length; i += 2) {
                bytes[i / 2] = parseInt(hexString.substr(i, 2), 16);
            }
            
            log(`Hex decode complete for ${context}: output = ${bytes.length} bytes`, 'debug');
            return bytes;
        }

        // Key derivation with logging
        async function deriveKey(password, salt, iterations = 100000) {
            log(`Key derivation start: iterations=${iterations}, salt length=${salt.length}`, 'debug');
            
            const encoder = new TextEncoder();
            const passwordData = encoder.encode(password);
            
            const keyMaterial = await crypto.subtle.importKey(
                'raw',
                passwordData,
                'PBKDF2',
                false,
                ['deriveKey']
            );
            
            const key = await crypto.subtle.deriveKey(
                {
                    name: 'PBKDF2',
                    salt: salt,
                    iterations: iterations,
                    hash: 'SHA-256'
                },
                keyMaterial,
                { name: 'AES-GCM', length: 256 },
                false,
                ['encrypt', 'decrypt']
            );
            
            log(`Key derivation complete`, 'debug');
            return key;
        }

        // Decrypt chunk with detailed IV logging
        async function decryptChunk(data, key, chunkIndex) {
            try {
                const iv = new Uint8Array(12);
                
                // Special handling for meta-tx (chunkIndex = -1)
                if (chunkIndex === -1) {
                    // Use a special pattern for meta-tx
                    iv[0] = 0xFF;
                    iv[1] = 0xFF;
                    for (let i = 2; i < 12; i++) {
                        iv[i] = 0xFF - i;
                    }
                } else {
                    iv[0] = (chunkIndex >> 8) & 0xFF;
                    iv[1] = chunkIndex & 0xFF;
                    for (let i = 2; i < 12; i++) {
                        iv[i] = i * 17;
                    }
                }
                
                const ivHex = Array.from(iv).map(b => b.toString(16).padStart(2, '0')).join(' ');
                log(`Decrypting chunk ${chunkIndex}: data length=${data.length}, IV=${ivHex}`, 'debug');
                
                // Log first 16 bytes of encrypted data
                const dataPreview = Array.from(data.slice(0, 16)).map(b => b.toString(16).padStart(2, '0')).join(' ');
                log(`Encrypted data preview: ${dataPreview}...`, 'debug');
                
                const decrypted = await crypto.subtle.decrypt(
                    { name: 'AES-GCM', iv: iv },
                    key,
                    data
                );
                
                const decryptedArray = new Uint8Array(decrypted);
                log(`Decryption successful for chunk ${chunkIndex}: ${decryptedArray.length} bytes`, 'success');
                
                return decryptedArray;
            } catch (error) {
                log(`復号化エラー (チャンク ${chunkIndex}): ${error.message || error}`, 'error');
                log(`エラー詳細: ${error.stack}`, 'error');
                throw error;
            }
        }

        // Test variable chunk compression handling
        async function analyzeChunkStructure(metadata) {
            log('=== チャンク構造分析開始 ===', 'warning');
            
            if (metadata.metadata?.chunkBoundaries) {
                log('チャンクバウンダリ情報が存在します', 'success');
                log(`チャンク数: ${metadata.metadata.chunkBoundaries.length}`, 'info');
                
                metadata.metadata.chunkBoundaries.forEach((boundary, i) => {
                    log(`Boundary ${i}: index=${boundary.index}, offset=${boundary.offset}, size=${boundary.size}, originalSize=${boundary.originalSize}`, 'debug');
                });
                
                // Calculate total encrypted size
                const totalEncryptedSize = metadata.metadata.chunkBoundaries.reduce((sum, b) => sum + b.size, 0);
                log(`合計暗号化サイズ: ${totalEncryptedSize} bytes`, 'info');
                
                // Check if chunks array matches boundaries
                log(`chunks配列の長さ: ${metadata.chunks.length}`, 'info');
                log(`chunkBoundaries配列の長さ: ${metadata.metadata.chunkBoundaries.length}`, 'info');
                
                if (metadata.chunks.length !== metadata.metadata.chunkBoundaries.length) {
                    log('警告: chunks配列とchunkBoundaries配列の長さが一致しません！', 'warning');
                }
            } else {
                log('チャンクバウンダリ情報が存在しません', 'warning');
            }
            
            log('=== チャンク構造分析完了 ===', 'warning');
        }

        // Main debug download function
        async function startDebugDownload() {
            clearLog();
            log('=== デバッグダウンロード開始 ===', 'warning');
            
            const input = document.getElementById('testInput').value;
            const [metaTxId, blockId, password] = input.split(':');
            
            log(`MetaTxID: ${metaTxId}`, 'info');
            log(`BlockID: ${blockId}`, 'info');
            log(`Password: ${'*'.repeat(password.length)}`, 'info');

            try {
                // Step 1: Fetch metadata
                log('Step 1: メタデータ取得', 'warning');
                const metadataResponse = await fetch(`https://api-tn10.kaspa.org/transactions/${metaTxId}`);
                
                if (!metadataResponse.ok) {
                    throw new Error(`メタデータ取得失敗: ${metadataResponse.status}`);
                }
                
                const metadataJson = await metadataResponse.json();
                log(`API Response payload length: ${metadataJson.payload?.length || 0}`, 'debug');
                
                // Decode payload
                const payload = safeHexDecode(metadataJson.payload, 'metadata');
                log(`Decoded payload: ${payload.length} bytes`, 'info');
                
                // Extract salt and encrypted data
                const salt = payload.slice(0, 16);
                const encryptedMetadata = payload.slice(16);
                
                log(`Salt: ${toBase64(salt)}`, 'debug');
                log(`Encrypted metadata: ${encryptedMetadata.length} bytes`, 'debug');
                
                // Step 2: Derive key
                log('Step 2: キー導出', 'warning');
                const key = await deriveKey(password, salt, 100000);
                
                // Step 3: Decrypt metadata
                log('Step 3: メタデータ復号化', 'warning');
                const decryptedMetadata = await decryptChunk(encryptedMetadata, key, -1);
                const metadataString = new TextDecoder().decode(decryptedMetadata);
                const metadata = JSON.parse(metadataString);
                
                log('メタデータ復号化成功', 'success');
                log(`Version: ${metadata.version}`, 'info');
                log(`File: ${metadata.file.name}`, 'info');
                log(`Compression: ${metadata.file.compression?.enabled ? 'Yes' : 'No'}`, 'info');
                
                // Step 4: Analyze chunk structure
                await analyzeChunkStructure(metadata);
                
                // Step 5: Test chunk download and decryption
                log('Step 5: チャンクダウンロードテスト', 'warning');
                
                if (metadata.chunks.length > 0) {
                    const firstChunkTxId = metadata.chunks[0];
                    const firstChunkBlockId = metadata.chunkBlockIds[0];
                    
                    log(`First chunk TxID: ${firstChunkTxId}`, 'info');
                    log(`First chunk BlockID: ${firstChunkBlockId}`, 'info');
                    
                    // Fetch first chunk
                    const chunkResponse = await fetch(`https://api-tn10.kaspa.org/transactions/${firstChunkTxId}`);
                    if (!chunkResponse.ok) {
                        throw new Error(`チャンク取得失敗: ${chunkResponse.status}`);
                    }
                    
                    const chunkJson = await chunkResponse.json();
                    const chunkPayload = safeHexDecode(chunkJson.payload, 'chunk 0');
                    
                    log(`First chunk payload: ${chunkPayload.length} bytes`, 'info');
                    
                    // Try different decryption approaches
                    log('=== 復号化テスト ===', 'warning');
                    
                    // Test 1: Direct decryption with index 0
                    log('Test 1: インデックス0で直接復号化', 'info');
                    try {
                        await decryptChunk(chunkPayload, key, 0);
                    } catch (e) {
                        log(`Test 1 失敗: ${e.message}`, 'error');
                    }
                    
                    // Test 2: Use boundary index if available
                    if (metadata.metadata?.chunkBoundaries) {
                        const boundary = metadata.metadata.chunkBoundaries[0];
                        log(`Test 2: boundary.index=${boundary.index}で復号化`, 'info');
                        try {
                            await decryptChunk(chunkPayload, key, boundary.index);
                        } catch (e) {
                            log(`Test 2 失敗: ${e.message}`, 'error');
                        }
                    }
                    
                    // Test 3: Check if this is part of a larger encrypted stream
                    log('Test 3: ストリーム暗号化の可能性を検証', 'info');
                    if (metadata.file?.compression?.enabled && metadata.metadata?.payloadSplit) {
                        log('これは圧縮後に分割されたストリーム暗号化の可能性があります', 'warning');
                        log('解決策: 全チャンクを結合してから復号化する必要があります', 'success');
                    }
                }
                
            } catch (error) {
                log(`エラー: ${error.message}`, 'error');
                log(`スタックトレース: ${error.stack}`, 'error');
            }
            
            log('=== デバッグ完了 ===', 'warning');
        }
    </script>
</body>
</html>